"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@hello-pangea";
exports.ids = ["vendor-chunks/@hello-pangea"];
exports.modules = {

/***/ "(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@hello-pangea/dnd/dist/dnd.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragDropContext: () => (/* binding */ DragDropContext),\n/* harmony export */   Draggable: () => (/* binding */ PublicDraggable),\n/* harmony export */   Droppable: () => (/* binding */ ConnectedDroppable$1),\n/* harmony export */   resetServerContext: () => (/* binding */ resetServerContext),\n/* harmony export */   useKeyboardSensor: () => (/* binding */ useKeyboardSensor),\n/* harmony export */   useMouseSensor: () => (/* binding */ useMouseSensor),\n/* harmony export */   useTouchSensor: () => (/* binding */ useTouchSensor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/es/redux.js\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/es/index.js\");\n/* harmony import */ var use_memo_one__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! use-memo-one */ \"(ssr)/./node_modules/use-memo-one/dist/use-memo-one.esm.js\");\n/* harmony import */ var css_box_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! css-box-model */ \"(ssr)/./node_modules/css-box-model/dist/css-box-model.esm.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! memoize-one */ \"(ssr)/./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var raf_schd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! raf-schd */ \"(ssr)/./node_modules/raf-schd/dist/raf-schd.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n\n\n\n\n\n\n\n\n\nconst isProduction$1 = \"development\" === \"production\";\nconst spacesAndTabs = /[ \\t]{2,}/g;\nconst lineStartWithSpaces = /^[ \\t]*/gm;\nconst clean$2 = (value)=>value.replace(spacesAndTabs, \" \").replace(lineStartWithSpaces, \"\").trim();\nconst getDevMessage = (message)=>clean$2(`\n  %c@hello-pangea/dnd\n\n  %c${clean$2(message)}\n\n  %c👷‍ This is a development only message. It will be removed in production builds.\n`);\nconst getFormattedMessage = (message)=>[\n        getDevMessage(message),\n        \"color: #00C584; font-size: 1.2em; font-weight: bold;\",\n        \"line-height: 1.5\",\n        \"color: #723874;\"\n    ];\nconst isDisabledFlag = \"__@hello-pangea/dnd-disable-dev-warnings\";\nfunction log(type, message) {\n    if (isProduction$1) {\n        return;\n    }\n    if (false) {}\n    console[type](...getFormattedMessage(message));\n}\nconst warning = log.bind(null, \"warn\");\nconst error = log.bind(null, \"error\");\nfunction noop$2() {}\nfunction getOptions(shared, fromBinding) {\n    return {\n        ...shared,\n        ...fromBinding\n    };\n}\nfunction bindEvents(el, bindings, sharedOptions) {\n    const unbindings = bindings.map((binding)=>{\n        const options = getOptions(sharedOptions, binding.options);\n        el.addEventListener(binding.eventName, binding.fn, options);\n        return function unbind() {\n            el.removeEventListener(binding.eventName, binding.fn, options);\n        };\n    });\n    return function unbindAll() {\n        unbindings.forEach((unbind)=>{\n            unbind();\n        });\n    };\n}\nconst isProduction = \"development\" === \"production\";\nconst prefix$1 = \"Invariant failed\";\nclass RbdInvariant extends Error {\n}\nRbdInvariant.prototype.toString = function toString() {\n    return this.message;\n};\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new RbdInvariant(prefix$1);\n    } else {\n        throw new RbdInvariant(`${prefix$1}: ${message || \"\"}`);\n    }\n}\nclass ErrorBoundary extends (react__WEBPACK_IMPORTED_MODULE_0___default().Component) {\n    constructor(){\n        super(...arguments);\n        this.callbacks = null;\n        this.unbind = noop$2;\n        this.onWindowError = (event)=>{\n            const callbacks = this.getCallbacks();\n            if (callbacks.isDragging()) {\n                callbacks.tryAbort();\n                 true ? warning(`\n        An error was caught by our window 'error' event listener while a drag was occurring.\n        The active drag has been aborted.\n      `) : 0;\n            }\n            const err = event.error;\n            if (err instanceof RbdInvariant) {\n                event.preventDefault();\n                if (true) {\n                    error(err.message);\n                }\n            }\n        };\n        this.getCallbacks = ()=>{\n            if (!this.callbacks) {\n                throw new Error(\"Unable to find AppCallbacks in <ErrorBoundary/>\");\n            }\n            return this.callbacks;\n        };\n        this.setCallbacks = (callbacks)=>{\n            this.callbacks = callbacks;\n        };\n    }\n    componentDidMount() {\n        this.unbind = bindEvents(window, [\n            {\n                eventName: \"error\",\n                fn: this.onWindowError\n            }\n        ]);\n    }\n    componentDidCatch(err) {\n        if (err instanceof RbdInvariant) {\n            if (true) {\n                error(err.message);\n            }\n            this.setState({});\n            return;\n        }\n        throw err;\n    }\n    componentWillUnmount() {\n        this.unbind();\n    }\n    render() {\n        return this.props.children(this.setCallbacks);\n    }\n}\nconst dragHandleUsageInstructions = `\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n`;\nconst position = (index)=>index + 1;\nconst onDragStart = (start)=>`\n  You have lifted an item in position ${position(start.source.index)}\n`;\nconst withLocation = (source, destination)=>{\n    const isInHomeList = source.droppableId === destination.droppableId;\n    const startPosition = position(source.index);\n    const endPosition = position(destination.index);\n    if (isInHomeList) {\n        return `\n      You have moved the item from position ${startPosition}\n      to position ${endPosition}\n    `;\n    }\n    return `\n    You have moved the item from position ${startPosition}\n    in list ${source.droppableId}\n    to list ${destination.droppableId}\n    in position ${endPosition}\n  `;\n};\nconst withCombine = (id, source, combine)=>{\n    const inHomeList = source.droppableId === combine.droppableId;\n    if (inHomeList) {\n        return `\n      The item ${id}\n      has been combined with ${combine.draggableId}`;\n    }\n    return `\n      The item ${id}\n      in list ${source.droppableId}\n      has been combined with ${combine.draggableId}\n      in list ${combine.droppableId}\n    `;\n};\nconst onDragUpdate = (update)=>{\n    const location = update.destination;\n    if (location) {\n        return withLocation(update.source, location);\n    }\n    const combine = update.combine;\n    if (combine) {\n        return withCombine(update.draggableId, update.source, combine);\n    }\n    return \"You are over an area that cannot be dropped on\";\n};\nconst returnedToStart = (source)=>`\n  The item has returned to its starting position\n  of ${position(source.index)}\n`;\nconst onDragEnd = (result)=>{\n    if (result.reason === \"CANCEL\") {\n        return `\n      Movement cancelled.\n      ${returnedToStart(result.source)}\n    `;\n    }\n    const location = result.destination;\n    const combine = result.combine;\n    if (location) {\n        return `\n      You have dropped the item.\n      ${withLocation(result.source, location)}\n    `;\n    }\n    if (combine) {\n        return `\n      You have dropped the item.\n      ${withCombine(result.draggableId, result.source, combine)}\n    `;\n    }\n    return `\n    The item has been dropped while not over a drop area.\n    ${returnedToStart(result.source)}\n  `;\n};\nconst preset = {\n    dragHandleUsageInstructions,\n    onDragStart,\n    onDragUpdate,\n    onDragEnd\n};\nvar preset$1 = preset;\nconst origin = {\n    x: 0,\n    y: 0\n};\nconst add = (point1, point2)=>({\n        x: point1.x + point2.x,\n        y: point1.y + point2.y\n    });\nconst subtract = (point1, point2)=>({\n        x: point1.x - point2.x,\n        y: point1.y - point2.y\n    });\nconst isEqual$1 = (point1, point2)=>point1.x === point2.x && point1.y === point2.y;\nconst negate = (point)=>({\n        x: point.x !== 0 ? -point.x : 0,\n        y: point.y !== 0 ? -point.y : 0\n    });\nconst patch = function(line, value, otherValue) {\n    if (otherValue === void 0) {\n        otherValue = 0;\n    }\n    if (line === \"x\") {\n        return {\n            x: value,\n            y: otherValue\n        };\n    }\n    return {\n        x: otherValue,\n        y: value\n    };\n};\nconst distance = (point1, point2)=>Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);\nconst closest$1 = (target, points)=>Math.min(...points.map((point)=>distance(target, point)));\nconst apply = (fn)=>(point)=>({\n            x: fn(point.x),\n            y: fn(point.y)\n        });\nvar executeClip = (frame, subject)=>{\n    const result = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)({\n        top: Math.max(subject.top, frame.top),\n        right: Math.min(subject.right, frame.right),\n        bottom: Math.min(subject.bottom, frame.bottom),\n        left: Math.max(subject.left, frame.left)\n    });\n    if (result.width <= 0 || result.height <= 0) {\n        return null;\n    }\n    return result;\n};\nconst offsetByPosition = (spacing, point)=>({\n        top: spacing.top + point.y,\n        left: spacing.left + point.x,\n        bottom: spacing.bottom + point.y,\n        right: spacing.right + point.x\n    });\nconst getCorners = (spacing)=>[\n        {\n            x: spacing.left,\n            y: spacing.top\n        },\n        {\n            x: spacing.right,\n            y: spacing.top\n        },\n        {\n            x: spacing.left,\n            y: spacing.bottom\n        },\n        {\n            x: spacing.right,\n            y: spacing.bottom\n        }\n    ];\nconst noSpacing = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n};\nconst scroll$1 = (target, frame)=>{\n    if (!frame) {\n        return target;\n    }\n    return offsetByPosition(target, frame.scroll.diff.displacement);\n};\nconst increase = (target, axis, withPlaceholder)=>{\n    if (withPlaceholder && withPlaceholder.increasedBy) {\n        return {\n            ...target,\n            [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line]\n        };\n    }\n    return target;\n};\nconst clip = (target, frame)=>{\n    if (frame && frame.shouldClipSubject) {\n        return executeClip(frame.pageMarginBox, target);\n    }\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)(target);\n};\nvar getSubject = (_ref)=>{\n    let { page, withPlaceholder, axis, frame } = _ref;\n    const scrolled = scroll$1(page.marginBox, frame);\n    const increased = increase(scrolled, axis, withPlaceholder);\n    const clipped = clip(increased, frame);\n    return {\n        page,\n        withPlaceholder,\n        active: clipped\n    };\n};\nvar scrollDroppable = (droppable, newScroll)=>{\n    !droppable.frame ?  true ? invariant(false) : 0 : void 0;\n    const scrollable = droppable.frame;\n    const scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n    const scrollDisplacement = negate(scrollDiff);\n    const frame = {\n        ...scrollable,\n        scroll: {\n            initial: scrollable.scroll.initial,\n            current: newScroll,\n            diff: {\n                value: scrollDiff,\n                displacement: scrollDisplacement\n            },\n            max: scrollable.scroll.max\n        }\n    };\n    const subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: droppable.subject.withPlaceholder,\n        axis: droppable.axis,\n        frame\n    });\n    const result = {\n        ...droppable,\n        frame,\n        subject\n    };\n    return result;\n};\nconst toDroppableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((droppables)=>droppables.reduce((previous, current)=>{\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {}));\nconst toDraggableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((draggables)=>draggables.reduce((previous, current)=>{\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {}));\nconst toDroppableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((droppables)=>Object.values(droppables));\nconst toDraggableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((draggables)=>Object.values(draggables));\nvar getDraggablesInsideDroppable = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((droppableId, draggables)=>{\n    const result = toDraggableList(draggables).filter((draggable)=>droppableId === draggable.descriptor.droppableId).sort((a, b)=>a.descriptor.index - b.descriptor.index);\n    return result;\n});\nfunction tryGetDestination(impact) {\n    if (impact.at && impact.at.type === \"REORDER\") {\n        return impact.at.destination;\n    }\n    return null;\n}\nfunction tryGetCombine(impact) {\n    if (impact.at && impact.at.type === \"COMBINE\") {\n        return impact.at.combine;\n    }\n    return null;\n}\nvar removeDraggableFromList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((remove, list)=>list.filter((item)=>item.descriptor.id !== remove.descriptor.id));\nvar moveToNextCombine = (_ref)=>{\n    let { isMovingForward, draggable, destination, insideDestination, previousImpact } = _ref;\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const location = tryGetDestination(previousImpact);\n    if (!location) {\n        return null;\n    }\n    function getImpact(target) {\n        const at = {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: target,\n                droppableId: destination.descriptor.id\n            }\n        };\n        return {\n            ...previousImpact,\n            at\n        };\n    }\n    const all = previousImpact.displaced.all;\n    const closestId = all.length ? all[0] : null;\n    if (isMovingForward) {\n        return closestId ? getImpact(closestId) : null;\n    }\n    const withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n    if (!closestId) {\n        if (!withoutDraggable.length) {\n            return null;\n        }\n        const last = withoutDraggable[withoutDraggable.length - 1];\n        return getImpact(last.descriptor.id);\n    }\n    const indexOfClosest = withoutDraggable.findIndex((d)=>d.descriptor.id === closestId);\n    !(indexOfClosest !== -1) ?  true ? invariant(false, \"Could not find displaced item in set\") : 0 : void 0;\n    const proposedIndex = indexOfClosest - 1;\n    if (proposedIndex < 0) {\n        return null;\n    }\n    const before = withoutDraggable[proposedIndex];\n    return getImpact(before.descriptor.id);\n};\nvar isHomeOf = (draggable, destination)=>draggable.descriptor.droppableId === destination.descriptor.id;\nconst noDisplacedBy = {\n    point: origin,\n    value: 0\n};\nconst emptyGroups = {\n    invisible: {},\n    visible: {},\n    all: []\n};\nconst noImpact = {\n    displaced: emptyGroups,\n    displacedBy: noDisplacedBy,\n    at: null\n};\nvar noImpact$1 = noImpact;\nvar isWithin = (lowerBound, upperBound)=>(value)=>lowerBound <= value && value <= upperBound;\nvar isPartiallyVisibleThroughFrame = (frame)=>{\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return (subject)=>{\n        const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        if (isContained) {\n            return true;\n        }\n        const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n        const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n        const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n        if (isPartiallyContained) {\n            return true;\n        }\n        const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n        const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n        const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n        if (isTargetBiggerThanFrame) {\n            return true;\n        }\n        const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n        return isTargetBiggerOnOneAxis;\n    };\n};\nvar isTotallyVisibleThroughFrame = (frame)=>{\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return (subject)=>{\n        const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        return isContained;\n    };\n};\nconst vertical = {\n    direction: \"vertical\",\n    line: \"y\",\n    crossAxisLine: \"x\",\n    start: \"top\",\n    end: \"bottom\",\n    size: \"height\",\n    crossAxisStart: \"left\",\n    crossAxisEnd: \"right\",\n    crossAxisSize: \"width\"\n};\nconst horizontal = {\n    direction: \"horizontal\",\n    line: \"x\",\n    crossAxisLine: \"y\",\n    start: \"left\",\n    end: \"right\",\n    size: \"width\",\n    crossAxisStart: \"top\",\n    crossAxisEnd: \"bottom\",\n    crossAxisSize: \"height\"\n};\nvar isTotallyVisibleThroughFrameOnAxis = (axis)=>(frame)=>{\n        const isWithinVertical = isWithin(frame.top, frame.bottom);\n        const isWithinHorizontal = isWithin(frame.left, frame.right);\n        return (subject)=>{\n            if (axis === vertical) {\n                return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n            }\n            return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        };\n    };\nconst getDroppableDisplaced = (target, destination)=>{\n    const displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n    return offsetByPosition(target, displacement);\n};\nconst isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn)=>{\n    if (!destination.subject.active) {\n        return false;\n    }\n    return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\nconst isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn)=>isVisibleThroughFrameFn(viewport)(target);\nconst isVisible$1 = (_ref)=>{\n    let { target: toBeDisplaced, destination, viewport, withDroppableDisplacement, isVisibleThroughFrameFn } = _ref;\n    const displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n    return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\nconst isPartiallyVisible = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n    });\nconst isTotallyVisible = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n    });\nconst isTotallyVisibleOnAxis = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n    });\nconst getShouldAnimate = (id, last, forceShouldAnimate)=>{\n    if (typeof forceShouldAnimate === \"boolean\") {\n        return forceShouldAnimate;\n    }\n    if (!last) {\n        return true;\n    }\n    const { invisible, visible } = last;\n    if (invisible[id]) {\n        return false;\n    }\n    const previous = visible[id];\n    return previous ? previous.shouldAnimate : true;\n};\nfunction getTarget(draggable, displacedBy) {\n    const marginBox = draggable.page.marginBox;\n    const expandBy = {\n        top: displacedBy.point.y,\n        right: 0,\n        bottom: 0,\n        left: displacedBy.point.x\n    };\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)((0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.expand)(marginBox, expandBy));\n}\nfunction getDisplacementGroups(_ref) {\n    let { afterDragging, destination, displacedBy, viewport, forceShouldAnimate, last } = _ref;\n    return afterDragging.reduce(function process(groups, draggable) {\n        const target = getTarget(draggable, displacedBy);\n        const id = draggable.descriptor.id;\n        groups.all.push(id);\n        const isVisible = isPartiallyVisible({\n            target,\n            destination,\n            viewport,\n            withDroppableDisplacement: true\n        });\n        if (!isVisible) {\n            groups.invisible[draggable.descriptor.id] = true;\n            return groups;\n        }\n        const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n        const displacement = {\n            draggableId: id,\n            shouldAnimate\n        };\n        groups.visible[id] = displacement;\n        return groups;\n    }, {\n        all: [],\n        visible: {},\n        invisible: {}\n    });\n}\nfunction getIndexOfLastItem(draggables, options) {\n    if (!draggables.length) {\n        return 0;\n    }\n    const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n    return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\nfunction goAtEnd(_ref) {\n    let { insideDestination, inHomeList, displacedBy, destination } = _ref;\n    const newIndex = getIndexOfLastItem(insideDestination, {\n        inHomeList\n    });\n    return {\n        displaced: emptyGroups,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index: newIndex\n            }\n        }\n    };\n}\nfunction calculateReorderImpact(_ref2) {\n    let { draggable, insideDestination, destination, viewport, displacedBy, last, index, forceShouldAnimate } = _ref2;\n    const inHomeList = isHomeOf(draggable, destination);\n    if (index == null) {\n        return goAtEnd({\n            insideDestination,\n            inHomeList,\n            displacedBy,\n            destination\n        });\n    }\n    const match = insideDestination.find((item)=>item.descriptor.index === index);\n    if (!match) {\n        return goAtEnd({\n            insideDestination,\n            inHomeList,\n            displacedBy,\n            destination\n        });\n    }\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const sliceFrom = insideDestination.indexOf(match);\n    const impacted = withoutDragging.slice(sliceFrom);\n    const displaced = getDisplacementGroups({\n        afterDragging: impacted,\n        destination,\n        displacedBy,\n        last,\n        viewport: viewport.frame,\n        forceShouldAnimate\n    });\n    return {\n        displaced,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index\n            }\n        }\n    };\n}\nfunction didStartAfterCritical(draggableId, afterCritical) {\n    return Boolean(afterCritical.effected[draggableId]);\n}\nvar fromCombine = (_ref)=>{\n    let { isMovingForward, destination, draggables, combine, afterCritical } = _ref;\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const combineId = combine.draggableId;\n    const combineWith = draggables[combineId];\n    const combineWithIndex = combineWith.descriptor.index;\n    const didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n    if (didCombineWithStartAfterCritical) {\n        if (isMovingForward) {\n            return combineWithIndex;\n        }\n        return combineWithIndex - 1;\n    }\n    if (isMovingForward) {\n        return combineWithIndex + 1;\n    }\n    return combineWithIndex;\n};\nvar fromReorder = (_ref)=>{\n    let { isMovingForward, isInHomeList, insideDestination, location } = _ref;\n    if (!insideDestination.length) {\n        return null;\n    }\n    const currentIndex = location.index;\n    const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n    const firstIndex = insideDestination[0].descriptor.index;\n    const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n    const upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n    if (proposedIndex < firstIndex) {\n        return null;\n    }\n    if (proposedIndex > upperBound) {\n        return null;\n    }\n    return proposedIndex;\n};\nvar moveToNextIndex = (_ref)=>{\n    let { isMovingForward, isInHomeList, draggable, draggables, destination, insideDestination, previousImpact, viewport, afterCritical } = _ref;\n    const wasAt = previousImpact.at;\n    !wasAt ?  true ? invariant(false, \"Cannot move in direction without previous impact location\") : 0 : void 0;\n    if (wasAt.type === \"REORDER\") {\n        const newIndex = fromReorder({\n            isMovingForward,\n            isInHomeList,\n            location: wasAt.destination,\n            insideDestination\n        });\n        if (newIndex == null) {\n            return null;\n        }\n        return calculateReorderImpact({\n            draggable,\n            insideDestination,\n            destination,\n            viewport,\n            last: previousImpact.displaced,\n            displacedBy: previousImpact.displacedBy,\n            index: newIndex\n        });\n    }\n    const newIndex = fromCombine({\n        isMovingForward,\n        destination,\n        displaced: previousImpact.displaced,\n        draggables,\n        combine: wasAt.combine,\n        afterCritical\n    });\n    if (newIndex == null) {\n        return null;\n    }\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        last: previousImpact.displaced,\n        displacedBy: previousImpact.displacedBy,\n        index: newIndex\n    });\n};\nvar getCombinedItemDisplacement = (_ref)=>{\n    let { displaced, afterCritical, combineWith, displacedBy } = _ref;\n    const isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n    if (didStartAfterCritical(combineWith, afterCritical)) {\n        return isDisplaced ? origin : negate(displacedBy.point);\n    }\n    return isDisplaced ? displacedBy.point : origin;\n};\nvar whenCombining = (_ref)=>{\n    let { afterCritical, impact, draggables } = _ref;\n    const combine = tryGetCombine(impact);\n    !combine ?  true ? invariant(false) : 0 : void 0;\n    const combineWith = combine.draggableId;\n    const center = draggables[combineWith].page.borderBox.center;\n    const displaceBy = getCombinedItemDisplacement({\n        displaced: impact.displaced,\n        afterCritical,\n        combineWith,\n        displacedBy: impact.displacedBy\n    });\n    return add(center, displaceBy);\n};\nconst distanceFromStartToBorderBoxCenter = (axis, box)=>box.margin[axis.start] + box.borderBox[axis.size] / 2;\nconst distanceFromEndToBorderBoxCenter = (axis, box)=>box.margin[axis.end] + box.borderBox[axis.size] / 2;\nconst getCrossAxisBorderBoxCenter = (axis, target, isMoving)=>target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\nconst goAfter = (_ref)=>{\n    let { axis, moveRelativeTo, isMoving } = _ref;\n    return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nconst goBefore = (_ref2)=>{\n    let { axis, moveRelativeTo, isMoving } = _ref2;\n    return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nconst goIntoStart = (_ref3)=>{\n    let { axis, moveInto, isMoving } = _ref3;\n    return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\n};\nvar whenReordering = (_ref)=>{\n    let { impact, draggable, draggables, droppable, afterCritical } = _ref;\n    const insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    const draggablePage = draggable.page;\n    const axis = droppable.axis;\n    if (!insideDestination.length) {\n        return goIntoStart({\n            axis,\n            moveInto: droppable.page,\n            isMoving: draggablePage\n        });\n    }\n    const { displaced, displacedBy } = impact;\n    const closestAfter = displaced.all[0];\n    if (closestAfter) {\n        const closest = draggables[closestAfter];\n        if (didStartAfterCritical(closestAfter, afterCritical)) {\n            return goBefore({\n                axis,\n                moveRelativeTo: closest.page,\n                isMoving: draggablePage\n            });\n        }\n        const withDisplacement = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.offset)(closest.page, displacedBy.point);\n        return goBefore({\n            axis,\n            moveRelativeTo: withDisplacement,\n            isMoving: draggablePage\n        });\n    }\n    const last = insideDestination[insideDestination.length - 1];\n    if (last.descriptor.id === draggable.descriptor.id) {\n        return draggablePage.borderBox.center;\n    }\n    if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n        const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.offset)(last.page, negate(afterCritical.displacedBy.point));\n        return goAfter({\n            axis,\n            moveRelativeTo: page,\n            isMoving: draggablePage\n        });\n    }\n    return goAfter({\n        axis,\n        moveRelativeTo: last.page,\n        isMoving: draggablePage\n    });\n};\nvar withDroppableDisplacement = (droppable, point)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return point;\n    }\n    return add(point, frame.scroll.diff.displacement);\n};\nconst getResultWithoutDroppableDisplacement = (_ref)=>{\n    let { impact, draggable, droppable, draggables, afterCritical } = _ref;\n    const original = draggable.page.borderBox.center;\n    const at = impact.at;\n    if (!droppable) {\n        return original;\n    }\n    if (!at) {\n        return original;\n    }\n    if (at.type === \"REORDER\") {\n        return whenReordering({\n            impact,\n            draggable,\n            draggables,\n            droppable,\n            afterCritical\n        });\n    }\n    return whenCombining({\n        impact,\n        draggables,\n        afterCritical\n    });\n};\nvar getPageBorderBoxCenterFromImpact = (args)=>{\n    const withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n    const droppable = args.droppable;\n    const withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n    return withDisplacement;\n};\nvar scrollViewport = (viewport, newScroll)=>{\n    const diff = subtract(newScroll, viewport.scroll.initial);\n    const displacement = negate(diff);\n    const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)({\n        top: newScroll.y,\n        bottom: newScroll.y + viewport.frame.height,\n        left: newScroll.x,\n        right: newScroll.x + viewport.frame.width\n    });\n    const updated = {\n        frame,\n        scroll: {\n            initial: viewport.scroll.initial,\n            max: viewport.scroll.max,\n            current: newScroll,\n            diff: {\n                value: diff,\n                displacement\n            }\n        }\n    };\n    return updated;\n};\nfunction getDraggables$1(ids, draggables) {\n    return ids.map((id)=>draggables[id]);\n}\nfunction tryGetVisible(id, groups) {\n    for(let i = 0; i < groups.length; i++){\n        const displacement = groups[i].visible[id];\n        if (displacement) {\n            return displacement;\n        }\n    }\n    return null;\n}\nvar speculativelyIncrease = (_ref)=>{\n    let { impact, viewport, destination, draggables, maxScrollChange } = _ref;\n    const scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n    const scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n    const last = impact.displaced;\n    const withViewportScroll = getDisplacementGroups({\n        afterDragging: getDraggables$1(last.all, draggables),\n        destination,\n        displacedBy: impact.displacedBy,\n        viewport: scrolledViewport.frame,\n        last,\n        forceShouldAnimate: false\n    });\n    const withDroppableScroll = getDisplacementGroups({\n        afterDragging: getDraggables$1(last.all, draggables),\n        destination: scrolledDroppable,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        last,\n        forceShouldAnimate: false\n    });\n    const invisible = {};\n    const visible = {};\n    const groups = [\n        last,\n        withViewportScroll,\n        withDroppableScroll\n    ];\n    last.all.forEach((id)=>{\n        const displacement = tryGetVisible(id, groups);\n        if (displacement) {\n            visible[id] = displacement;\n            return;\n        }\n        invisible[id] = true;\n    });\n    const newImpact = {\n        ...impact,\n        displaced: {\n            all: last.all,\n            invisible,\n            visible\n        }\n    };\n    return newImpact;\n};\nvar withViewportDisplacement = (viewport, point)=>add(viewport.scroll.diff.displacement, point);\nvar getClientFromPageBorderBoxCenter = (_ref)=>{\n    let { pageBorderBoxCenter, draggable, viewport } = _ref;\n    const withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n    const offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n    return add(draggable.client.borderBox.center, offset);\n};\nvar isTotallyVisibleInNewLocation = (_ref)=>{\n    let { draggable, destination, newPageBorderBoxCenter, viewport, withDroppableDisplacement, onlyOnMainAxis = false } = _ref;\n    const changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n    const shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n    const args = {\n        target: shifted,\n        destination,\n        withDroppableDisplacement,\n        viewport\n    };\n    return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n};\nvar moveToNextPlace = (_ref)=>{\n    let { isMovingForward, draggable, destination, draggables, previousImpact, viewport, previousPageBorderBoxCenter, previousClientSelection, afterCritical } = _ref;\n    if (!destination.isEnabled) {\n        return null;\n    }\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const isInHomeList = isHomeOf(draggable, destination);\n    const impact = moveToNextCombine({\n        isMovingForward,\n        draggable,\n        destination,\n        insideDestination,\n        previousImpact\n    }) || moveToNextIndex({\n        isMovingForward,\n        isInHomeList,\n        draggable,\n        draggables,\n        destination,\n        insideDestination,\n        previousImpact,\n        viewport,\n        afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        afterCritical\n    });\n    const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n        draggable,\n        destination,\n        newPageBorderBoxCenter: pageBorderBoxCenter,\n        viewport: viewport.frame,\n        withDroppableDisplacement: false,\n        onlyOnMainAxis: true\n    });\n    if (isVisibleInNewLocation) {\n        const clientSelection = getClientFromPageBorderBoxCenter({\n            pageBorderBoxCenter,\n            draggable,\n            viewport\n        });\n        return {\n            clientSelection,\n            impact,\n            scrollJumpRequest: null\n        };\n    }\n    const distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n    const cautious = speculativelyIncrease({\n        impact,\n        viewport,\n        destination,\n        draggables,\n        maxScrollChange: distance\n    });\n    return {\n        clientSelection: previousClientSelection,\n        impact: cautious,\n        scrollJumpRequest: distance\n    };\n};\nconst getKnownActive = (droppable)=>{\n    const rect = droppable.subject.active;\n    !rect ?  true ? invariant(false, \"Cannot get clipped area from droppable\") : 0 : void 0;\n    return rect;\n};\nvar getBestCrossAxisDroppable = (_ref)=>{\n    let { isMovingForward, pageBorderBoxCenter, source, droppables, viewport } = _ref;\n    const active = source.subject.active;\n    if (!active) {\n        return null;\n    }\n    const axis = source.axis;\n    const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n    const candidates = toDroppableList(droppables).filter((droppable)=>droppable !== source).filter((droppable)=>droppable.isEnabled).filter((droppable)=>Boolean(droppable.subject.active)).filter((droppable)=>isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter((droppable)=>{\n        const activeOfTarget = getKnownActive(droppable);\n        if (isMovingForward) {\n            return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n        }\n        return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n    }).filter((droppable)=>{\n        const activeOfTarget = getKnownActive(droppable);\n        const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n        return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n    }).sort((a, b)=>{\n        const first = getKnownActive(a)[axis.crossAxisStart];\n        const second = getKnownActive(b)[axis.crossAxisStart];\n        if (isMovingForward) {\n            return first - second;\n        }\n        return second - first;\n    }).filter((droppable, index, array)=>getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0];\n    }\n    const contains = candidates.filter((droppable)=>{\n        const isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n        return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n    });\n    if (contains.length === 1) {\n        return contains[0];\n    }\n    if (contains.length > 1) {\n        return contains.sort((a, b)=>getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start])[0];\n    }\n    return candidates.sort((a, b)=>{\n        const first = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n        const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n        if (first !== second) {\n            return first - second;\n        }\n        return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n    })[0];\n};\nconst getCurrentPageBorderBoxCenter = (draggable, afterCritical)=>{\n    const original = draggable.page.borderBox.center;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nconst getCurrentPageBorderBox = (draggable, afterCritical)=>{\n    const original = draggable.page.borderBox;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\nvar getClosestDraggable = (_ref)=>{\n    let { pageBorderBoxCenter, viewport, destination, insideDestination, afterCritical } = _ref;\n    const sorted = insideDestination.filter((draggable)=>isTotallyVisible({\n            target: getCurrentPageBorderBox(draggable, afterCritical),\n            destination,\n            viewport: viewport.frame,\n            withDroppableDisplacement: true\n        })).sort((a, b)=>{\n        const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n        const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n        if (distanceToA < distanceToB) {\n            return -1;\n        }\n        if (distanceToB < distanceToA) {\n            return 1;\n        }\n        return a.descriptor.index - b.descriptor.index;\n    });\n    return sorted[0] || null;\n};\nvar getDisplacedBy = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function getDisplacedBy(axis, displaceBy) {\n    const displacement = displaceBy[axis.line];\n    return {\n        value: displacement,\n        point: patch(axis.line, displacement)\n    };\n});\nconst getRequiredGrowthForPlaceholder = (droppable, placeholderSize, draggables)=>{\n    const axis = droppable.axis;\n    if (droppable.descriptor.mode === \"virtual\") {\n        return patch(axis.line, placeholderSize[axis.line]);\n    }\n    const availableSpace = droppable.subject.page.contentBox[axis.size];\n    const insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    const spaceUsed = insideDroppable.reduce((sum, dimension)=>sum + dimension.client.marginBox[axis.size], 0);\n    const requiredSpace = spaceUsed + placeholderSize[axis.line];\n    const needsToGrowBy = requiredSpace - availableSpace;\n    if (needsToGrowBy <= 0) {\n        return null;\n    }\n    return patch(axis.line, needsToGrowBy);\n};\nconst withMaxScroll = (frame, max)=>({\n        ...frame,\n        scroll: {\n            ...frame.scroll,\n            max\n        }\n    });\nconst addPlaceholder = (droppable, draggable, draggables)=>{\n    const frame = droppable.frame;\n    !!isHomeOf(draggable, droppable) ?  true ? invariant(false, \"Should not add placeholder space to home list\") : 0 : void 0;\n    !!droppable.subject.withPlaceholder ?  true ? invariant(false, \"Cannot add placeholder size to a subject when it already has one\") : 0 : void 0;\n    const placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n    const requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n    const added = {\n        placeholderSize,\n        increasedBy: requiredGrowth,\n        oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n    };\n    if (!frame) {\n        const subject = getSubject({\n            page: droppable.subject.page,\n            withPlaceholder: added,\n            axis: droppable.axis,\n            frame: droppable.frame\n        });\n        return {\n            ...droppable,\n            subject\n        };\n    }\n    const maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n    const newFrame = withMaxScroll(frame, maxScroll);\n    const subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: added,\n        axis: droppable.axis,\n        frame: newFrame\n    });\n    return {\n        ...droppable,\n        subject,\n        frame: newFrame\n    };\n};\nconst removePlaceholder = (droppable)=>{\n    const added = droppable.subject.withPlaceholder;\n    !added ?  true ? invariant(false, \"Cannot remove placeholder form subject when there was none\") : 0 : void 0;\n    const frame = droppable.frame;\n    if (!frame) {\n        const subject = getSubject({\n            page: droppable.subject.page,\n            axis: droppable.axis,\n            frame: null,\n            withPlaceholder: null\n        });\n        return {\n            ...droppable,\n            subject\n        };\n    }\n    const oldMaxScroll = added.oldFrameMaxScroll;\n    !oldMaxScroll ?  true ? invariant(false, \"Expected droppable with frame to have old max frame scroll when removing placeholder\") : 0 : void 0;\n    const newFrame = withMaxScroll(frame, oldMaxScroll);\n    const subject = getSubject({\n        page: droppable.subject.page,\n        axis: droppable.axis,\n        frame: newFrame,\n        withPlaceholder: null\n    });\n    return {\n        ...droppable,\n        subject,\n        frame: newFrame\n    };\n};\nvar moveToNewDroppable = (_ref)=>{\n    let { previousPageBorderBoxCenter, moveRelativeTo, insideDestination, draggable, draggables, destination, viewport, afterCritical } = _ref;\n    if (!moveRelativeTo) {\n        if (insideDestination.length) {\n            return null;\n        }\n        const proposed = {\n            displaced: emptyGroups,\n            displacedBy: noDisplacedBy,\n            at: {\n                type: \"REORDER\",\n                destination: {\n                    droppableId: destination.descriptor.id,\n                    index: 0\n                }\n            }\n        };\n        const proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n            impact: proposed,\n            draggable,\n            droppable: destination,\n            draggables,\n            afterCritical\n        });\n        const withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n        const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n            draggable,\n            destination: withPlaceholder,\n            newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n            viewport: viewport.frame,\n            withDroppableDisplacement: false,\n            onlyOnMainAxis: true\n        });\n        return isVisibleInNewLocation ? proposed : null;\n    }\n    const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n    const proposedIndex = (()=>{\n        const relativeTo = moveRelativeTo.descriptor.index;\n        if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n            return relativeTo;\n        }\n        if (isGoingBeforeTarget) {\n            return relativeTo;\n        }\n        return relativeTo + 1;\n    })();\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        displacedBy,\n        last: emptyGroups,\n        index: proposedIndex\n    });\n};\nvar moveCrossAxis = (_ref)=>{\n    let { isMovingForward, previousPageBorderBoxCenter, draggable, isOver, draggables, droppables, viewport, afterCritical } = _ref;\n    const destination = getBestCrossAxisDroppable({\n        isMovingForward,\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        source: isOver,\n        droppables,\n        viewport\n    });\n    if (!destination) {\n        return null;\n    }\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const moveRelativeTo = getClosestDraggable({\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        viewport,\n        destination,\n        insideDestination,\n        afterCritical\n    });\n    const impact = moveToNewDroppable({\n        previousPageBorderBoxCenter,\n        destination,\n        draggable,\n        draggables,\n        moveRelativeTo,\n        insideDestination,\n        viewport,\n        afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        afterCritical\n    });\n    const clientSelection = getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter,\n        draggable,\n        viewport\n    });\n    return {\n        clientSelection,\n        impact,\n        scrollJumpRequest: null\n    };\n};\nvar whatIsDraggedOver = (impact)=>{\n    const at = impact.at;\n    if (!at) {\n        return null;\n    }\n    if (at.type === \"REORDER\") {\n        return at.destination.droppableId;\n    }\n    return at.combine.droppableId;\n};\nconst getDroppableOver$1 = (impact, droppables)=>{\n    const id = whatIsDraggedOver(impact);\n    return id ? droppables[id] : null;\n};\nvar moveInDirection = (_ref)=>{\n    let { state, type } = _ref;\n    const isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);\n    const isMainAxisMovementAllowed = Boolean(isActuallyOver);\n    const home = state.dimensions.droppables[state.critical.droppable.id];\n    const isOver = isActuallyOver || home;\n    const direction = isOver.axis.direction;\n    const isMovingOnMainAxis = direction === \"vertical\" && (type === \"MOVE_UP\" || type === \"MOVE_DOWN\") || direction === \"horizontal\" && (type === \"MOVE_LEFT\" || type === \"MOVE_RIGHT\");\n    if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n        return null;\n    }\n    const isMovingForward = type === \"MOVE_DOWN\" || type === \"MOVE_RIGHT\";\n    const draggable = state.dimensions.draggables[state.critical.draggable.id];\n    const previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n    const { draggables, droppables } = state.dimensions;\n    return isMovingOnMainAxis ? moveToNextPlace({\n        isMovingForward,\n        previousPageBorderBoxCenter,\n        draggable,\n        destination: isOver,\n        draggables,\n        viewport: state.viewport,\n        previousClientSelection: state.current.client.selection,\n        previousImpact: state.impact,\n        afterCritical: state.afterCritical\n    }) : moveCrossAxis({\n        isMovingForward,\n        previousPageBorderBoxCenter,\n        draggable,\n        isOver,\n        draggables,\n        droppables,\n        viewport: state.viewport,\n        afterCritical: state.afterCritical\n    });\n};\nfunction isMovementAllowed(state) {\n    return state.phase === \"DRAGGING\" || state.phase === \"COLLECTING\";\n}\nfunction isPositionInFrame(frame) {\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function run(point) {\n        return isWithinVertical(point.y) && isWithinHorizontal(point.x);\n    };\n}\nfunction getHasOverlap(first, second) {\n    return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;\n}\nfunction getFurthestAway(_ref) {\n    let { pageBorderBox, draggable, candidates } = _ref;\n    const startCenter = draggable.page.borderBox.center;\n    const sorted = candidates.map((candidate)=>{\n        const axis = candidate.axis;\n        const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);\n        return {\n            id: candidate.descriptor.id,\n            distance: distance(startCenter, target)\n        };\n    }).sort((a, b)=>b.distance - a.distance);\n    return sorted[0] ? sorted[0].id : null;\n}\nfunction getDroppableOver(_ref2) {\n    let { pageBorderBox, draggable, droppables } = _ref2;\n    const candidates = toDroppableList(droppables).filter((item)=>{\n        if (!item.isEnabled) {\n            return false;\n        }\n        const active = item.subject.active;\n        if (!active) {\n            return false;\n        }\n        if (!getHasOverlap(pageBorderBox, active)) {\n            return false;\n        }\n        if (isPositionInFrame(active)(pageBorderBox.center)) {\n            return true;\n        }\n        const axis = item.axis;\n        const childCenter = active.center[axis.crossAxisLine];\n        const crossAxisStart = pageBorderBox[axis.crossAxisStart];\n        const crossAxisEnd = pageBorderBox[axis.crossAxisEnd];\n        const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);\n        const isStartContained = isContained(crossAxisStart);\n        const isEndContained = isContained(crossAxisEnd);\n        if (!isStartContained && !isEndContained) {\n            return true;\n        }\n        if (isStartContained) {\n            return crossAxisStart < childCenter;\n        }\n        return crossAxisEnd > childCenter;\n    });\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0].descriptor.id;\n    }\n    return getFurthestAway({\n        pageBorderBox,\n        draggable,\n        candidates\n    });\n}\nconst offsetRectByPosition = (rect, point)=>(0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)(offsetByPosition(rect, point));\nvar withDroppableScroll = (droppable, area)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return area;\n    }\n    return offsetRectByPosition(area, frame.scroll.diff.value);\n};\nfunction getIsDisplaced(_ref) {\n    let { displaced, id } = _ref;\n    return Boolean(displaced.visible[id] || displaced.invisible[id]);\n}\nfunction atIndex(_ref) {\n    let { draggable, closest, inHomeList } = _ref;\n    if (!closest) {\n        return null;\n    }\n    if (!inHomeList) {\n        return closest.descriptor.index;\n    }\n    if (closest.descriptor.index > draggable.descriptor.index) {\n        return closest.descriptor.index - 1;\n    }\n    return closest.descriptor.index;\n}\nvar getReorderImpact = (_ref2)=>{\n    let { pageBorderBoxWithDroppableScroll: targetRect, draggable, destination, insideDestination, last, viewport, afterCritical } = _ref2;\n    const axis = destination.axis;\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    const displacement = displacedBy.value;\n    const targetStart = targetRect[axis.start];\n    const targetEnd = targetRect[axis.end];\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const closest = withoutDragging.find((child)=>{\n        const id = child.descriptor.id;\n        const childCenter = child.page.borderBox.center[axis.line];\n        const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        const isDisplaced = getIsDisplaced({\n            displaced: last,\n            id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd <= childCenter;\n            }\n            return targetStart < childCenter - displacement;\n        }\n        if (isDisplaced) {\n            return targetEnd <= childCenter + displacement;\n        }\n        return targetStart < childCenter;\n    }) || null;\n    const newIndex = atIndex({\n        draggable,\n        closest,\n        inHomeList: isHomeOf(draggable, destination)\n    });\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        last,\n        displacedBy,\n        index: newIndex\n    });\n};\nconst combineThresholdDivisor = 4;\nvar getCombineImpact = (_ref)=>{\n    let { draggable, pageBorderBoxWithDroppableScroll: targetRect, previousImpact, destination, insideDestination, afterCritical } = _ref;\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const axis = destination.axis;\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    const displacement = displacedBy.value;\n    const targetStart = targetRect[axis.start];\n    const targetEnd = targetRect[axis.end];\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const combineWith = withoutDragging.find((child)=>{\n        const id = child.descriptor.id;\n        const childRect = child.page.borderBox;\n        const childSize = childRect[axis.size];\n        const threshold = childSize / combineThresholdDivisor;\n        const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        const isDisplaced = getIsDisplaced({\n            displaced: previousImpact.displaced,\n            id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;\n            }\n            return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;\n        }\n        if (isDisplaced) {\n            return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;\n        }\n        return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;\n    });\n    if (!combineWith) {\n        return null;\n    }\n    const impact = {\n        displacedBy,\n        displaced: previousImpact.displaced,\n        at: {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: combineWith.descriptor.id,\n                droppableId: destination.descriptor.id\n            }\n        }\n    };\n    return impact;\n};\nvar getDragImpact = (_ref)=>{\n    let { pageOffset, draggable, draggables, droppables, previousImpact, viewport, afterCritical } = _ref;\n    const pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);\n    const destinationId = getDroppableOver({\n        pageBorderBox,\n        draggable,\n        droppables\n    });\n    if (!destinationId) {\n        return noImpact$1;\n    }\n    const destination = droppables[destinationId];\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);\n    return getCombineImpact({\n        pageBorderBoxWithDroppableScroll,\n        draggable,\n        previousImpact,\n        destination,\n        insideDestination,\n        afterCritical\n    }) || getReorderImpact({\n        pageBorderBoxWithDroppableScroll,\n        draggable,\n        destination,\n        insideDestination,\n        last: previousImpact.displaced,\n        viewport,\n        afterCritical\n    });\n};\nvar patchDroppableMap = (droppables, updated)=>({\n        ...droppables,\n        [updated.descriptor.id]: updated\n    });\nconst clearUnusedPlaceholder = (_ref)=>{\n    let { previousImpact, impact, droppables } = _ref;\n    const last = whatIsDraggedOver(previousImpact);\n    const now = whatIsDraggedOver(impact);\n    if (!last) {\n        return droppables;\n    }\n    if (last === now) {\n        return droppables;\n    }\n    const lastDroppable = droppables[last];\n    if (!lastDroppable.subject.withPlaceholder) {\n        return droppables;\n    }\n    const updated = removePlaceholder(lastDroppable);\n    return patchDroppableMap(droppables, updated);\n};\nvar recomputePlaceholders = (_ref2)=>{\n    let { draggable, draggables, droppables, previousImpact, impact } = _ref2;\n    const cleaned = clearUnusedPlaceholder({\n        previousImpact,\n        impact,\n        droppables\n    });\n    const isOver = whatIsDraggedOver(impact);\n    if (!isOver) {\n        return cleaned;\n    }\n    const droppable = droppables[isOver];\n    if (isHomeOf(draggable, droppable)) {\n        return cleaned;\n    }\n    if (droppable.subject.withPlaceholder) {\n        return cleaned;\n    }\n    const patched = addPlaceholder(droppable, draggable, draggables);\n    return patchDroppableMap(cleaned, patched);\n};\nvar update = (_ref)=>{\n    let { state, clientSelection: forcedClientSelection, dimensions: forcedDimensions, viewport: forcedViewport, impact: forcedImpact, scrollJumpRequest } = _ref;\n    const viewport = forcedViewport || state.viewport;\n    const dimensions = forcedDimensions || state.dimensions;\n    const clientSelection = forcedClientSelection || state.current.client.selection;\n    const offset = subtract(clientSelection, state.initial.client.selection);\n    const client = {\n        offset,\n        selection: clientSelection,\n        borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n    };\n    const page = {\n        selection: add(client.selection, viewport.scroll.current),\n        borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),\n        offset: add(client.offset, viewport.scroll.diff.value)\n    };\n    const current = {\n        client,\n        page\n    };\n    if (state.phase === \"COLLECTING\") {\n        return {\n            ...state,\n            dimensions,\n            viewport,\n            current\n        };\n    }\n    const draggable = dimensions.draggables[state.critical.draggable.id];\n    const newImpact = forcedImpact || getDragImpact({\n        pageOffset: page.offset,\n        draggable,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact: state.impact,\n        viewport,\n        afterCritical: state.afterCritical\n    });\n    const withUpdatedPlaceholders = recomputePlaceholders({\n        draggable,\n        impact: newImpact,\n        previousImpact: state.impact,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables\n    });\n    const result = {\n        ...state,\n        current,\n        dimensions: {\n            draggables: dimensions.draggables,\n            droppables: withUpdatedPlaceholders\n        },\n        impact: newImpact,\n        viewport,\n        scrollJumpRequest: scrollJumpRequest || null,\n        forceShouldAnimate: scrollJumpRequest ? false : null\n    };\n    return result;\n};\nfunction getDraggables(ids, draggables) {\n    return ids.map((id)=>draggables[id]);\n}\nvar recompute = (_ref)=>{\n    let { impact, viewport, draggables, destination, forceShouldAnimate } = _ref;\n    const last = impact.displaced;\n    const afterDragging = getDraggables(last.all, draggables);\n    const displaced = getDisplacementGroups({\n        afterDragging,\n        destination,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        forceShouldAnimate,\n        last\n    });\n    return {\n        ...impact,\n        displaced\n    };\n};\nvar getClientBorderBoxCenter = (_ref)=>{\n    let { impact, draggable, droppable, draggables, viewport, afterCritical } = _ref;\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        draggables,\n        droppable,\n        afterCritical\n    });\n    return getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter,\n        draggable,\n        viewport\n    });\n};\nvar refreshSnap = (_ref)=>{\n    let { state, dimensions: forcedDimensions, viewport: forcedViewport } = _ref;\n    !(state.movementMode === \"SNAP\") ?  true ? invariant(false) : 0 : void 0;\n    const needsVisibilityCheck = state.impact;\n    const viewport = forcedViewport || state.viewport;\n    const dimensions = forcedDimensions || state.dimensions;\n    const { draggables, droppables } = dimensions;\n    const draggable = draggables[state.critical.draggable.id];\n    const isOver = whatIsDraggedOver(needsVisibilityCheck);\n    !isOver ?  true ? invariant(false, \"Must be over a destination in SNAP movement mode\") : 0 : void 0;\n    const destination = droppables[isOver];\n    const impact = recompute({\n        impact: needsVisibilityCheck,\n        viewport,\n        destination,\n        draggables\n    });\n    const clientSelection = getClientBorderBoxCenter({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        viewport,\n        afterCritical: state.afterCritical\n    });\n    return update({\n        impact,\n        clientSelection,\n        state,\n        dimensions,\n        viewport\n    });\n};\nvar getHomeLocation = (descriptor)=>({\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n    });\nvar getLiftEffect = (_ref)=>{\n    let { draggable, home, draggables, viewport } = _ref;\n    const displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n    const insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n    const rawIndex = insideHome.indexOf(draggable);\n    !(rawIndex !== -1) ?  true ? invariant(false, \"Expected draggable to be inside home list\") : 0 : void 0;\n    const afterDragging = insideHome.slice(rawIndex + 1);\n    const effected = afterDragging.reduce((previous, item)=>{\n        previous[item.descriptor.id] = true;\n        return previous;\n    }, {});\n    const afterCritical = {\n        inVirtualList: home.descriptor.mode === \"virtual\",\n        displacedBy,\n        effected\n    };\n    const displaced = getDisplacementGroups({\n        afterDragging,\n        destination: home,\n        displacedBy,\n        last: null,\n        viewport: viewport.frame,\n        forceShouldAnimate: false\n    });\n    const impact = {\n        displaced,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: getHomeLocation(draggable.descriptor)\n        }\n    };\n    return {\n        impact,\n        afterCritical\n    };\n};\nvar patchDimensionMap = (dimensions, updated)=>({\n        draggables: dimensions.draggables,\n        droppables: patchDroppableMap(dimensions.droppables, updated)\n    });\nconst start = (key)=>{\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nconst finish = (key)=>{\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nvar offsetDraggable = (_ref)=>{\n    let { draggable, offset: offset$1, initialWindowScroll } = _ref;\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.offset)(draggable.client, offset$1);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.withScroll)(client, initialWindowScroll);\n    const moved = {\n        ...draggable,\n        placeholder: {\n            ...draggable.placeholder,\n            client\n        },\n        client,\n        page\n    };\n    return moved;\n};\nvar getFrame = (droppable)=>{\n    const frame = droppable.frame;\n    !frame ?  true ? invariant(false, \"Expected Droppable to have a frame\") : 0 : void 0;\n    return frame;\n};\nvar adjustAdditionsForScrollChanges = (_ref)=>{\n    let { additions, updatedDroppables, viewport } = _ref;\n    const windowScrollChange = viewport.scroll.diff.value;\n    return additions.map((draggable)=>{\n        const droppableId = draggable.descriptor.droppableId;\n        const modified = updatedDroppables[droppableId];\n        const frame = getFrame(modified);\n        const droppableScrollChange = frame.scroll.diff.value;\n        const totalChange = add(windowScrollChange, droppableScrollChange);\n        const moved = offsetDraggable({\n            draggable,\n            offset: totalChange,\n            initialWindowScroll: viewport.scroll.initial\n        });\n        return moved;\n    });\n};\nconst timingsKey = \"Processing dynamic changes\";\nvar publishWhileDraggingInVirtual = (_ref)=>{\n    let { state, published } = _ref;\n    start(timingsKey);\n    const withScrollChange = published.modified.map((update)=>{\n        const existing = state.dimensions.droppables[update.droppableId];\n        const scrolled = scrollDroppable(existing, update.scroll);\n        return scrolled;\n    });\n    const droppables = {\n        ...state.dimensions.droppables,\n        ...toDroppableMap(withScrollChange)\n    };\n    const updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n        additions: published.additions,\n        updatedDroppables: droppables,\n        viewport: state.viewport\n    }));\n    const draggables = {\n        ...state.dimensions.draggables,\n        ...updatedAdditions\n    };\n    published.removals.forEach((id)=>{\n        delete draggables[id];\n    });\n    const dimensions = {\n        droppables,\n        draggables\n    };\n    const wasOverId = whatIsDraggedOver(state.impact);\n    const wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n    const draggable = dimensions.draggables[state.critical.draggable.id];\n    const home = dimensions.droppables[state.critical.droppable.id];\n    const { impact: onLiftImpact, afterCritical } = getLiftEffect({\n        draggable,\n        home,\n        draggables,\n        viewport: state.viewport\n    });\n    const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n    const impact = getDragImpact({\n        pageOffset: state.current.page.offset,\n        draggable: dimensions.draggables[state.critical.draggable.id],\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact,\n        viewport: state.viewport,\n        afterCritical\n    });\n    finish(timingsKey);\n    const draggingState = {\n        ...state,\n        phase: \"DRAGGING\",\n        impact,\n        onLiftImpact,\n        dimensions,\n        afterCritical,\n        forceShouldAnimate: false\n    };\n    if (state.phase === \"COLLECTING\") {\n        return draggingState;\n    }\n    const dropPending = {\n        ...draggingState,\n        phase: \"DROP_PENDING\",\n        reason: state.reason,\n        isWaiting: false\n    };\n    return dropPending;\n};\nconst isSnapping = (state)=>state.movementMode === \"SNAP\";\nconst postDroppableChange = (state, updated, isEnabledChanging)=>{\n    const dimensions = patchDimensionMap(state.dimensions, updated);\n    if (!isSnapping(state) || isEnabledChanging) {\n        return update({\n            state,\n            dimensions\n        });\n    }\n    return refreshSnap({\n        state,\n        dimensions\n    });\n};\nfunction removeScrollJumpRequest(state) {\n    if (state.isDragging && state.movementMode === \"SNAP\") {\n        return {\n            ...state,\n            scrollJumpRequest: null\n        };\n    }\n    return state;\n}\nconst idle$2 = {\n    phase: \"IDLE\",\n    completed: null,\n    shouldFlush: false\n};\nvar reducer = function(state, action) {\n    if (state === void 0) {\n        state = idle$2;\n    }\n    if (action.type === \"FLUSH\") {\n        return {\n            ...idle$2,\n            shouldFlush: true\n        };\n    }\n    if (action.type === \"INITIAL_PUBLISH\") {\n        !(state.phase === \"IDLE\") ?  true ? invariant(false, \"INITIAL_PUBLISH must come after a IDLE phase\") : 0 : void 0;\n        const { critical, clientSelection, viewport, dimensions, movementMode } = action.payload;\n        const draggable = dimensions.draggables[critical.draggable.id];\n        const home = dimensions.droppables[critical.droppable.id];\n        const client = {\n            selection: clientSelection,\n            borderBoxCenter: draggable.client.borderBox.center,\n            offset: origin\n        };\n        const initial = {\n            client,\n            page: {\n                selection: add(client.selection, viewport.scroll.initial),\n                borderBoxCenter: add(client.selection, viewport.scroll.initial),\n                offset: add(client.selection, viewport.scroll.diff.value)\n            }\n        };\n        const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every((item)=>!item.isFixedOnPage);\n        const { impact, afterCritical } = getLiftEffect({\n            draggable,\n            home,\n            draggables: dimensions.draggables,\n            viewport\n        });\n        const result = {\n            phase: \"DRAGGING\",\n            isDragging: true,\n            critical,\n            movementMode,\n            dimensions,\n            initial,\n            current: initial,\n            isWindowScrollAllowed,\n            impact,\n            afterCritical,\n            onLiftImpact: impact,\n            viewport,\n            scrollJumpRequest: null,\n            forceShouldAnimate: null\n        };\n        return result;\n    }\n    if (action.type === \"COLLECTION_STARTING\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, `Collection cannot start from phase ${state.phase}`) : 0 : void 0;\n        const result = {\n            ...state,\n            phase: \"COLLECTING\"\n        };\n        return result;\n    }\n    if (action.type === \"PUBLISH_WHILE_DRAGGING\") {\n        !(state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Unexpected ${action.type} received in phase ${state.phase}`) : 0 : void 0;\n        return publishWhileDraggingInVirtual({\n            state,\n            published: action.payload\n        });\n    }\n    if (action.type === \"MOVE\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n        const { client: clientSelection } = action.payload;\n        if (isEqual$1(clientSelection, state.current.client.selection)) {\n            return state;\n        }\n        return update({\n            state,\n            clientSelection,\n            impact: isSnapping(state) ? state.impact : null\n        });\n    }\n    if (action.type === \"UPDATE_DROPPABLE_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return removeScrollJumpRequest(state);\n        }\n        if (state.phase === \"COLLECTING\") {\n            return removeScrollJumpRequest(state);\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n        const { id, newScroll } = action.payload;\n        const target = state.dimensions.droppables[id];\n        if (!target) {\n            return state;\n        }\n        const scrolled = scrollDroppable(target, newScroll);\n        return postDroppableChange(state, scrolled, false);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n        const { id, isEnabled } = action.payload;\n        const target = state.dimensions.droppables[id];\n        !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its enabled state`) : 0 : void 0;\n        !(target.isEnabled !== isEnabled) ?  true ? invariant(false, `Trying to set droppable isEnabled to ${String(isEnabled)}\n      but it is already ${String(target.isEnabled)}`) : 0 : void 0;\n        const updated = {\n            ...target,\n            isEnabled\n        };\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n        const { id, isCombineEnabled } = action.payload;\n        const target = state.dimensions.droppables[id];\n        !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its isCombineEnabled state`) : 0 : void 0;\n        !(target.isCombineEnabled !== isCombineEnabled) ?  true ? invariant(false, `Trying to set droppable isCombineEnabled to ${String(isCombineEnabled)}\n      but it is already ${String(target.isCombineEnabled)}`) : 0 : void 0;\n        const updated = {\n            ...target,\n            isCombineEnabled\n        };\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"MOVE_BY_WINDOW_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\" || state.phase === \"DROP_ANIMATING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Cannot move by window in phase ${state.phase}`) : 0 : void 0;\n        !state.isWindowScrollAllowed ?  true ? invariant(false, \"Window scrolling is currently not supported for fixed lists\") : 0 : void 0;\n        const newScroll = action.payload.newScroll;\n        if (isEqual$1(state.viewport.scroll.current, newScroll)) {\n            return removeScrollJumpRequest(state);\n        }\n        const viewport = scrollViewport(state.viewport, newScroll);\n        if (isSnapping(state)) {\n            return refreshSnap({\n                state,\n                viewport\n            });\n        }\n        return update({\n            state,\n            viewport\n        });\n    }\n    if (action.type === \"UPDATE_VIEWPORT_MAX_SCROLL\") {\n        if (!isMovementAllowed(state)) {\n            return state;\n        }\n        const maxScroll = action.payload.maxScroll;\n        if (isEqual$1(maxScroll, state.viewport.scroll.max)) {\n            return state;\n        }\n        const withMaxScroll = {\n            ...state.viewport,\n            scroll: {\n                ...state.viewport.scroll,\n                max: maxScroll\n            }\n        };\n        return {\n            ...state,\n            viewport: withMaxScroll\n        };\n    }\n    if (action.type === \"MOVE_UP\" || action.type === \"MOVE_DOWN\" || action.type === \"MOVE_LEFT\" || action.type === \"MOVE_RIGHT\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, `${action.type} received while not in DRAGGING phase`) : 0 : void 0;\n        const result = moveInDirection({\n            state,\n            type: action.type\n        });\n        if (!result) {\n            return state;\n        }\n        return update({\n            state,\n            impact: result.impact,\n            clientSelection: result.clientSelection,\n            scrollJumpRequest: result.scrollJumpRequest\n        });\n    }\n    if (action.type === \"DROP_PENDING\") {\n        const reason = action.payload.reason;\n        !(state.phase === \"COLLECTING\") ?  true ? invariant(false, \"Can only move into the DROP_PENDING phase from the COLLECTING phase\") : 0 : void 0;\n        const newState = {\n            ...state,\n            phase: \"DROP_PENDING\",\n            isWaiting: true,\n            reason\n        };\n        return newState;\n    }\n    if (action.type === \"DROP_ANIMATE\") {\n        const { completed, dropDuration, newHomeClientOffset } = action.payload;\n        !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Cannot animate drop from phase ${state.phase}`) : 0 : void 0;\n        const result = {\n            phase: \"DROP_ANIMATING\",\n            completed,\n            dropDuration,\n            newHomeClientOffset,\n            dimensions: state.dimensions\n        };\n        return result;\n    }\n    if (action.type === \"DROP_COMPLETE\") {\n        const { completed } = action.payload;\n        return {\n            phase: \"IDLE\",\n            completed,\n            shouldFlush: false\n        };\n    }\n    return state;\n};\nconst beforeInitialCapture = (args)=>({\n        type: \"BEFORE_INITIAL_CAPTURE\",\n        payload: args\n    });\nconst lift$1 = (args)=>({\n        type: \"LIFT\",\n        payload: args\n    });\nconst initialPublish = (args)=>({\n        type: \"INITIAL_PUBLISH\",\n        payload: args\n    });\nconst publishWhileDragging = (args)=>({\n        type: \"PUBLISH_WHILE_DRAGGING\",\n        payload: args\n    });\nconst collectionStarting = ()=>({\n        type: \"COLLECTION_STARTING\",\n        payload: null\n    });\nconst updateDroppableScroll = (args)=>({\n        type: \"UPDATE_DROPPABLE_SCROLL\",\n        payload: args\n    });\nconst updateDroppableIsEnabled = (args)=>({\n        type: \"UPDATE_DROPPABLE_IS_ENABLED\",\n        payload: args\n    });\nconst updateDroppableIsCombineEnabled = (args)=>({\n        type: \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\",\n        payload: args\n    });\nconst move = (args)=>({\n        type: \"MOVE\",\n        payload: args\n    });\nconst moveByWindowScroll = (args)=>({\n        type: \"MOVE_BY_WINDOW_SCROLL\",\n        payload: args\n    });\nconst updateViewportMaxScroll = (args)=>({\n        type: \"UPDATE_VIEWPORT_MAX_SCROLL\",\n        payload: args\n    });\nconst moveUp = ()=>({\n        type: \"MOVE_UP\",\n        payload: null\n    });\nconst moveDown = ()=>({\n        type: \"MOVE_DOWN\",\n        payload: null\n    });\nconst moveRight = ()=>({\n        type: \"MOVE_RIGHT\",\n        payload: null\n    });\nconst moveLeft = ()=>({\n        type: \"MOVE_LEFT\",\n        payload: null\n    });\nconst flush = ()=>({\n        type: \"FLUSH\",\n        payload: null\n    });\nconst animateDrop = (args)=>({\n        type: \"DROP_ANIMATE\",\n        payload: args\n    });\nconst completeDrop = (args)=>({\n        type: \"DROP_COMPLETE\",\n        payload: args\n    });\nconst drop$1 = (args)=>({\n        type: \"DROP\",\n        payload: args\n    });\nconst dropPending = (args)=>({\n        type: \"DROP_PENDING\",\n        payload: args\n    });\nconst dropAnimationFinished = ()=>({\n        type: \"DROP_ANIMATION_FINISHED\",\n        payload: null\n    });\nfunction checkIndexes(insideDestination) {\n    if (insideDestination.length <= 1) {\n        return;\n    }\n    const indexes = insideDestination.map((d)=>d.descriptor.index);\n    const errors = {};\n    for(let i = 1; i < indexes.length; i++){\n        const current = indexes[i];\n        const previous = indexes[i - 1];\n        if (current !== previous + 1) {\n            errors[current] = true;\n        }\n    }\n    if (!Object.keys(errors).length) {\n        return;\n    }\n    const formatted = indexes.map((index)=>{\n        const hasError = Boolean(errors[index]);\n        return hasError ? `[🔥${index}]` : `${index}`;\n    }).join(\", \");\n     true ? warning(`\n    Detected non-consecutive <Draggable /> indexes.\n\n    (This can cause unexpected bugs)\n\n    ${formatted}\n  `) : 0;\n}\nfunction validateDimensions(critical, dimensions) {\n    if (true) {\n        const insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n        checkIndexes(insideDestination);\n    }\n}\nvar lift = (marshal)=>(_ref)=>{\n        let { getState, dispatch } = _ref;\n        return (next)=>(action)=>{\n                if (action.type !== \"LIFT\") {\n                    next(action);\n                    return;\n                }\n                const { id, clientSelection, movementMode } = action.payload;\n                const initial = getState();\n                if (initial.phase === \"DROP_ANIMATING\") {\n                    dispatch(completeDrop({\n                        completed: initial.completed\n                    }));\n                }\n                !(getState().phase === \"IDLE\") ?  true ? invariant(false, \"Unexpected phase to start a drag\") : 0 : void 0;\n                dispatch(flush());\n                dispatch(beforeInitialCapture({\n                    draggableId: id,\n                    movementMode\n                }));\n                const scrollOptions = {\n                    shouldPublishImmediately: movementMode === \"SNAP\"\n                };\n                const request = {\n                    draggableId: id,\n                    scrollOptions\n                };\n                const { critical, dimensions, viewport } = marshal.startPublishing(request);\n                validateDimensions(critical, dimensions);\n                dispatch(initialPublish({\n                    critical,\n                    dimensions,\n                    clientSelection,\n                    movementMode,\n                    viewport\n                }));\n            };\n    };\nvar style = (marshal)=>()=>(next)=>(action)=>{\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    marshal.dragging();\n                }\n                if (action.type === \"DROP_ANIMATE\") {\n                    marshal.dropping(action.payload.completed.result.reason);\n                }\n                if (action.type === \"FLUSH\" || action.type === \"DROP_COMPLETE\") {\n                    marshal.resting();\n                }\n                next(action);\n            };\nconst curves = {\n    outOfTheWay: \"cubic-bezier(0.2, 0, 0, 1)\",\n    drop: \"cubic-bezier(.2,1,.1,1)\"\n};\nconst combine = {\n    opacity: {\n        drop: 0,\n        combining: 0.7\n    },\n    scale: {\n        drop: 0.75\n    }\n};\nconst timings = {\n    outOfTheWay: 0.2,\n    minDropTime: 0.33,\n    maxDropTime: 0.55\n};\nconst outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;\nconst transitions = {\n    fluid: `opacity ${outOfTheWayTiming}`,\n    snap: `transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,\n    drop: (duration)=>{\n        const timing = `${duration}s ${curves.drop}`;\n        return `transform ${timing}, opacity ${timing}`;\n    },\n    outOfTheWay: `transform ${outOfTheWayTiming}`,\n    placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`\n};\nconst moveTo = (offset)=>isEqual$1(offset, origin) ? undefined : `translate(${offset.x}px, ${offset.y}px)`;\nconst transforms = {\n    moveTo,\n    drop: (offset, isCombining)=>{\n        const translate = moveTo(offset);\n        if (!translate) {\n            return undefined;\n        }\n        if (!isCombining) {\n            return translate;\n        }\n        return `${translate} scale(${combine.scale.drop})`;\n    }\n};\nconst { minDropTime, maxDropTime } = timings;\nconst dropTimeRange = maxDropTime - minDropTime;\nconst maxDropTimeAtDistance = 1500;\nconst cancelDropModifier = 0.6;\nvar getDropDuration = (_ref)=>{\n    let { current, destination, reason } = _ref;\n    const distance$1 = distance(current, destination);\n    if (distance$1 <= 0) {\n        return minDropTime;\n    }\n    if (distance$1 >= maxDropTimeAtDistance) {\n        return maxDropTime;\n    }\n    const percentage = distance$1 / maxDropTimeAtDistance;\n    const duration = minDropTime + dropTimeRange * percentage;\n    const withDuration = reason === \"CANCEL\" ? duration * cancelDropModifier : duration;\n    return Number(withDuration.toFixed(2));\n};\nvar getNewHomeClientOffset = (_ref)=>{\n    let { impact, draggable, dimensions, viewport, afterCritical } = _ref;\n    const { draggables, droppables } = dimensions;\n    const droppableId = whatIsDraggedOver(impact);\n    const destination = droppableId ? droppables[droppableId] : null;\n    const home = droppables[draggable.descriptor.droppableId];\n    const newClientCenter = getClientBorderBoxCenter({\n        impact,\n        draggable,\n        draggables,\n        afterCritical,\n        droppable: destination || home,\n        viewport\n    });\n    const offset = subtract(newClientCenter, draggable.client.borderBox.center);\n    return offset;\n};\nvar getDropImpact = (_ref)=>{\n    let { draggables, reason, lastImpact, home, viewport, onLiftImpact } = _ref;\n    if (!lastImpact.at || reason !== \"DROP\") {\n        const recomputedHomeImpact = recompute({\n            draggables,\n            impact: onLiftImpact,\n            destination: home,\n            viewport,\n            forceShouldAnimate: true\n        });\n        return {\n            impact: recomputedHomeImpact,\n            didDropInsideDroppable: false\n        };\n    }\n    if (lastImpact.at.type === \"REORDER\") {\n        return {\n            impact: lastImpact,\n            didDropInsideDroppable: true\n        };\n    }\n    const withoutMovement = {\n        ...lastImpact,\n        displaced: emptyGroups\n    };\n    return {\n        impact: withoutMovement,\n        didDropInsideDroppable: true\n    };\n};\nconst dropMiddleware = (_ref)=>{\n    let { getState, dispatch } = _ref;\n    return (next)=>(action)=>{\n            if (action.type !== \"DROP\") {\n                next(action);\n                return;\n            }\n            const state = getState();\n            const reason = action.payload.reason;\n            if (state.phase === \"COLLECTING\") {\n                dispatch(dropPending({\n                    reason\n                }));\n                return;\n            }\n            if (state.phase === \"IDLE\") {\n                return;\n            }\n            const isWaitingForDrop = state.phase === \"DROP_PENDING\" && state.isWaiting;\n            !!isWaitingForDrop ?  true ? invariant(false, \"A DROP action occurred while DROP_PENDING and still waiting\") : 0 : void 0;\n            !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Cannot drop in phase: ${state.phase}`) : 0 : void 0;\n            const critical = state.critical;\n            const dimensions = state.dimensions;\n            const draggable = dimensions.draggables[state.critical.draggable.id];\n            const { impact, didDropInsideDroppable } = getDropImpact({\n                reason,\n                lastImpact: state.impact,\n                afterCritical: state.afterCritical,\n                onLiftImpact: state.onLiftImpact,\n                home: state.dimensions.droppables[state.critical.droppable.id],\n                viewport: state.viewport,\n                draggables: state.dimensions.draggables\n            });\n            const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n            const combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n            const source = {\n                index: critical.draggable.index,\n                droppableId: critical.droppable.id\n            };\n            const result = {\n                draggableId: draggable.descriptor.id,\n                type: draggable.descriptor.type,\n                source,\n                reason,\n                mode: state.movementMode,\n                destination,\n                combine\n            };\n            const newHomeClientOffset = getNewHomeClientOffset({\n                impact,\n                draggable,\n                dimensions,\n                viewport: state.viewport,\n                afterCritical: state.afterCritical\n            });\n            const completed = {\n                critical: state.critical,\n                afterCritical: state.afterCritical,\n                result,\n                impact\n            };\n            const isAnimationRequired = !isEqual$1(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n            if (!isAnimationRequired) {\n                dispatch(completeDrop({\n                    completed\n                }));\n                return;\n            }\n            const dropDuration = getDropDuration({\n                current: state.current.client.offset,\n                destination: newHomeClientOffset,\n                reason\n            });\n            const args = {\n                newHomeClientOffset,\n                dropDuration,\n                completed\n            };\n            dispatch(animateDrop(args));\n        };\n};\nvar drop = dropMiddleware;\nvar getWindowScroll = ()=>({\n        x: window.pageXOffset,\n        y: window.pageYOffset\n    });\nfunction getWindowScrollBinding(update) {\n    return {\n        eventName: \"scroll\",\n        options: {\n            passive: true,\n            capture: false\n        },\n        fn: (event)=>{\n            if (event.target !== window && event.target !== window.document) {\n                return;\n            }\n            update();\n        }\n    };\n}\nfunction getScrollListener(_ref) {\n    let { onWindowScroll } = _ref;\n    function updateScroll() {\n        onWindowScroll(getWindowScroll());\n    }\n    const scheduled = (0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(updateScroll);\n    const binding = getWindowScrollBinding(scheduled);\n    let unbind = noop$2;\n    function isActive() {\n        return unbind !== noop$2;\n    }\n    function start() {\n        !!isActive() ?  true ? invariant(false, \"Cannot start scroll listener when already active\") : 0 : void 0;\n        unbind = bindEvents(window, [\n            binding\n        ]);\n    }\n    function stop() {\n        !isActive() ?  true ? invariant(false, \"Cannot stop scroll listener when not active\") : 0 : void 0;\n        scheduled.cancel();\n        unbind();\n        unbind = noop$2;\n    }\n    return {\n        start,\n        stop,\n        isActive\n    };\n}\nconst shouldEnd = (action)=>action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATE\" || action.type === \"FLUSH\";\nconst scrollListener = (store)=>{\n    const listener = getScrollListener({\n        onWindowScroll: (newScroll)=>{\n            store.dispatch(moveByWindowScroll({\n                newScroll\n            }));\n        }\n    });\n    return (next)=>(action)=>{\n            if (!listener.isActive() && action.type === \"INITIAL_PUBLISH\") {\n                listener.start();\n            }\n            if (listener.isActive() && shouldEnd(action)) {\n                listener.stop();\n            }\n            next(action);\n        };\n};\nvar scrollListener$1 = scrollListener;\nvar getExpiringAnnounce = (announce)=>{\n    let wasCalled = false;\n    let isExpired = false;\n    const timeoutId = setTimeout(()=>{\n        isExpired = true;\n    });\n    const result = (message)=>{\n        if (wasCalled) {\n             true ? warning(\"Announcement already made. Not making a second announcement\") : 0;\n            return;\n        }\n        if (isExpired) {\n             true ? warning(`\n        Announcements cannot be made asynchronously.\n        Default message has already been announced.\n      `) : 0;\n            return;\n        }\n        wasCalled = true;\n        announce(message);\n        clearTimeout(timeoutId);\n    };\n    result.wasCalled = ()=>wasCalled;\n    return result;\n};\nvar getAsyncMarshal = ()=>{\n    const entries = [];\n    const execute = (timerId)=>{\n        const index = entries.findIndex((item)=>item.timerId === timerId);\n        !(index !== -1) ?  true ? invariant(false, \"Could not find timer\") : 0 : void 0;\n        const [entry] = entries.splice(index, 1);\n        entry.callback();\n    };\n    const add = (fn)=>{\n        const timerId = setTimeout(()=>execute(timerId));\n        const entry = {\n            timerId,\n            callback: fn\n        };\n        entries.push(entry);\n    };\n    const flush = ()=>{\n        if (!entries.length) {\n            return;\n        }\n        const shallow = [\n            ...entries\n        ];\n        entries.length = 0;\n        shallow.forEach((entry)=>{\n            clearTimeout(entry.timerId);\n            entry.callback();\n        });\n    };\n    return {\n        add,\n        flush\n    };\n};\nconst areLocationsEqual = (first, second)=>{\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.droppableId === second.droppableId && first.index === second.index;\n};\nconst isCombineEqual = (first, second)=>{\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nconst isCriticalEqual = (first, second)=>{\n    if (first === second) {\n        return true;\n    }\n    const isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n    const isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n    return isDraggableEqual && isDroppableEqual;\n};\nconst withTimings = (key, fn)=>{\n    start();\n    fn();\n    finish();\n};\nconst getDragStart = (critical, mode)=>({\n        draggableId: critical.draggable.id,\n        type: critical.droppable.type,\n        source: {\n            droppableId: critical.droppable.id,\n            index: critical.draggable.index\n        },\n        mode\n    });\nfunction execute(responder, data, announce, getDefaultMessage) {\n    if (!responder) {\n        announce(getDefaultMessage(data));\n        return;\n    }\n    const willExpire = getExpiringAnnounce(announce);\n    const provided = {\n        announce: willExpire\n    };\n    responder(data, provided);\n    if (!willExpire.wasCalled()) {\n        announce(getDefaultMessage(data));\n    }\n}\nvar getPublisher = (getResponders, announce)=>{\n    const asyncMarshal = getAsyncMarshal();\n    let dragging = null;\n    const beforeCapture = (draggableId, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeCapture as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeCapture\", ()=>{\n            const fn = getResponders().onBeforeCapture;\n            if (fn) {\n                const before = {\n                    draggableId,\n                    mode\n                };\n                fn(before);\n            }\n        });\n    };\n    const beforeStart = (critical, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeDragStart\", ()=>{\n            const fn = getResponders().onBeforeDragStart;\n            if (fn) {\n                fn(getDragStart(critical, mode));\n            }\n        });\n    };\n    const start = (critical, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        const data = getDragStart(critical, mode);\n        dragging = {\n            mode,\n            lastCritical: critical,\n            lastLocation: data.source,\n            lastCombine: null\n        };\n        asyncMarshal.add(()=>{\n            withTimings(\"onDragStart\", ()=>execute(getResponders().onDragStart, data, announce, preset$1.onDragStart));\n        });\n    };\n    const update = (critical, impact)=>{\n        const location = tryGetDestination(impact);\n        const combine = tryGetCombine(impact);\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragMove when onDragStart has not been called\") : 0 : void 0;\n        const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n        if (hasCriticalChanged) {\n            dragging.lastCritical = critical;\n        }\n        const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n        if (hasLocationChanged) {\n            dragging.lastLocation = location;\n        }\n        const hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n        if (hasGroupingChanged) {\n            dragging.lastCombine = combine;\n        }\n        if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n            return;\n        }\n        const data = {\n            ...getDragStart(critical, dragging.mode),\n            combine,\n            destination: location\n        };\n        asyncMarshal.add(()=>{\n            withTimings(\"onDragUpdate\", ()=>execute(getResponders().onDragUpdate, data, announce, preset$1.onDragUpdate));\n        });\n    };\n    const flush = ()=>{\n        !dragging ?  true ? invariant(false, \"Can only flush responders while dragging\") : 0 : void 0;\n        asyncMarshal.flush();\n    };\n    const drop = (result)=>{\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragEnd when there is no matching onDragStart\") : 0 : void 0;\n        dragging = null;\n        withTimings(\"onDragEnd\", ()=>execute(getResponders().onDragEnd, result, announce, preset$1.onDragEnd));\n    };\n    const abort = ()=>{\n        if (!dragging) {\n            return;\n        }\n        const result = {\n            ...getDragStart(dragging.lastCritical, dragging.mode),\n            combine: null,\n            destination: null,\n            reason: \"CANCEL\"\n        };\n        drop(result);\n    };\n    return {\n        beforeCapture,\n        beforeStart,\n        start,\n        update,\n        flush,\n        drop,\n        abort\n    };\n};\nvar responders = (getResponders, announce)=>{\n    const publisher = getPublisher(getResponders, announce);\n    return (store)=>(next)=>(action)=>{\n                if (action.type === \"BEFORE_INITIAL_CAPTURE\") {\n                    publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);\n                    return;\n                }\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    const critical = action.payload.critical;\n                    publisher.beforeStart(critical, action.payload.movementMode);\n                    next(action);\n                    publisher.start(critical, action.payload.movementMode);\n                    return;\n                }\n                if (action.type === \"DROP_COMPLETE\") {\n                    const result = action.payload.completed.result;\n                    publisher.flush();\n                    next(action);\n                    publisher.drop(result);\n                    return;\n                }\n                next(action);\n                if (action.type === \"FLUSH\") {\n                    publisher.abort();\n                    return;\n                }\n                const state = store.getState();\n                if (state.phase === \"DRAGGING\") {\n                    publisher.update(state.critical, state.impact);\n                }\n            };\n};\nconst dropAnimationFinishMiddleware = (store)=>(next)=>(action)=>{\n            if (action.type !== \"DROP_ANIMATION_FINISHED\") {\n                next(action);\n                return;\n            }\n            const state = store.getState();\n            !(state.phase === \"DROP_ANIMATING\") ?  true ? invariant(false, \"Cannot finish a drop animating when no drop is occurring\") : 0 : void 0;\n            store.dispatch(completeDrop({\n                completed: state.completed\n            }));\n        };\nvar dropAnimationFinish = dropAnimationFinishMiddleware;\nconst dropAnimationFlushOnScrollMiddleware = (store)=>{\n    let unbind = null;\n    let frameId = null;\n    function clear() {\n        if (frameId) {\n            cancelAnimationFrame(frameId);\n            frameId = null;\n        }\n        if (unbind) {\n            unbind();\n            unbind = null;\n        }\n    }\n    return (next)=>(action)=>{\n            if (action.type === \"FLUSH\" || action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATION_FINISHED\") {\n                clear();\n            }\n            next(action);\n            if (action.type !== \"DROP_ANIMATE\") {\n                return;\n            }\n            const binding = {\n                eventName: \"scroll\",\n                options: {\n                    capture: true,\n                    passive: false,\n                    once: true\n                },\n                fn: function flushDropAnimation() {\n                    const state = store.getState();\n                    if (state.phase === \"DROP_ANIMATING\") {\n                        store.dispatch(dropAnimationFinished());\n                    }\n                }\n            };\n            frameId = requestAnimationFrame(()=>{\n                frameId = null;\n                unbind = bindEvents(window, [\n                    binding\n                ]);\n            });\n        };\n};\nvar dropAnimationFlushOnScroll = dropAnimationFlushOnScrollMiddleware;\nvar dimensionMarshalStopper = (marshal)=>()=>(next)=>(action)=>{\n                if (action.type === \"DROP_COMPLETE\" || action.type === \"FLUSH\" || action.type === \"DROP_ANIMATE\") {\n                    marshal.stopPublishing();\n                }\n                next(action);\n            };\nvar focus = (marshal)=>{\n    let isWatching = false;\n    return ()=>(next)=>(action)=>{\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    isWatching = true;\n                    marshal.tryRecordFocus(action.payload.critical.draggable.id);\n                    next(action);\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                next(action);\n                if (!isWatching) {\n                    return;\n                }\n                if (action.type === \"FLUSH\") {\n                    isWatching = false;\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                if (action.type === \"DROP_COMPLETE\") {\n                    isWatching = false;\n                    const result = action.payload.completed.result;\n                    if (result.combine) {\n                        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n                    }\n                    marshal.tryRestoreFocusRecorded();\n                }\n            };\n};\nconst shouldStop = (action)=>action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATE\" || action.type === \"FLUSH\";\nvar autoScroll = (autoScroller)=>(store)=>(next)=>(action)=>{\n                if (shouldStop(action)) {\n                    autoScroller.stop();\n                    next(action);\n                    return;\n                }\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    next(action);\n                    const state = store.getState();\n                    !(state.phase === \"DRAGGING\") ?  true ? invariant(false, \"Expected phase to be DRAGGING after INITIAL_PUBLISH\") : 0 : void 0;\n                    autoScroller.start(state);\n                    return;\n                }\n                next(action);\n                autoScroller.scroll(store.getState());\n            };\nconst pendingDrop = (store)=>(next)=>(action)=>{\n            next(action);\n            if (action.type !== \"PUBLISH_WHILE_DRAGGING\") {\n                return;\n            }\n            const postActionState = store.getState();\n            if (postActionState.phase !== \"DROP_PENDING\") {\n                return;\n            }\n            if (postActionState.isWaiting) {\n                return;\n            }\n            store.dispatch(drop$1({\n                reason: postActionState.reason\n            }));\n        };\nvar pendingDrop$1 = pendingDrop;\nconst composeEnhancers =  false ? 0 : redux__WEBPACK_IMPORTED_MODULE_7__.compose;\nvar createStore = (_ref)=>{\n    let { dimensionMarshal, focusMarshal, styleMarshal, getResponders, announce, autoScroller } = _ref;\n    return (0,redux__WEBPACK_IMPORTED_MODULE_7__.createStore)(reducer, composeEnhancers((0,redux__WEBPACK_IMPORTED_MODULE_7__.applyMiddleware)(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift(dimensionMarshal), drop, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop$1, autoScroll(autoScroller), scrollListener$1, focus(focusMarshal), responders(getResponders, announce))));\n};\nconst clean$1 = ()=>({\n        additions: {},\n        removals: {},\n        modified: {}\n    });\nfunction createPublisher(_ref) {\n    let { registry, callbacks } = _ref;\n    let staging = clean$1();\n    let frameId = null;\n    const collect = ()=>{\n        if (frameId) {\n            return;\n        }\n        callbacks.collectionStarting();\n        frameId = requestAnimationFrame(()=>{\n            frameId = null;\n            start();\n            const { additions, removals, modified } = staging;\n            const added = Object.keys(additions).map((id)=>registry.draggable.getById(id).getDimension(origin)).sort((a, b)=>a.descriptor.index - b.descriptor.index);\n            const updated = Object.keys(modified).map((id)=>{\n                const entry = registry.droppable.getById(id);\n                const scroll = entry.callbacks.getScrollWhileDragging();\n                return {\n                    droppableId: id,\n                    scroll\n                };\n            });\n            const result = {\n                additions: added,\n                removals: Object.keys(removals),\n                modified: updated\n            };\n            staging = clean$1();\n            finish();\n            callbacks.publish(result);\n        });\n    };\n    const add = (entry)=>{\n        const id = entry.descriptor.id;\n        staging.additions[id] = entry;\n        staging.modified[entry.descriptor.droppableId] = true;\n        if (staging.removals[id]) {\n            delete staging.removals[id];\n        }\n        collect();\n    };\n    const remove = (entry)=>{\n        const descriptor = entry.descriptor;\n        staging.removals[descriptor.id] = true;\n        staging.modified[descriptor.droppableId] = true;\n        if (staging.additions[descriptor.id]) {\n            delete staging.additions[descriptor.id];\n        }\n        collect();\n    };\n    const stop = ()=>{\n        if (!frameId) {\n            return;\n        }\n        cancelAnimationFrame(frameId);\n        frameId = null;\n        staging = clean$1();\n    };\n    return {\n        add,\n        remove,\n        stop\n    };\n}\nvar getMaxScroll = (_ref)=>{\n    let { scrollHeight, scrollWidth, height, width } = _ref;\n    const maxScroll = subtract({\n        x: scrollWidth,\n        y: scrollHeight\n    }, {\n        x: width,\n        y: height\n    });\n    const adjustedMaxScroll = {\n        x: Math.max(0, maxScroll.x),\n        y: Math.max(0, maxScroll.y)\n    };\n    return adjustedMaxScroll;\n};\nvar getDocumentElement = ()=>{\n    const doc = document.documentElement;\n    !doc ?  true ? invariant(false, \"Cannot find document.documentElement\") : 0 : void 0;\n    return doc;\n};\nvar getMaxWindowScroll = ()=>{\n    const doc = getDocumentElement();\n    const maxScroll = getMaxScroll({\n        scrollHeight: doc.scrollHeight,\n        scrollWidth: doc.scrollWidth,\n        width: doc.clientWidth,\n        height: doc.clientHeight\n    });\n    return maxScroll;\n};\nvar getViewport = ()=>{\n    const scroll = getWindowScroll();\n    const maxScroll = getMaxWindowScroll();\n    const top = scroll.y;\n    const left = scroll.x;\n    const doc = getDocumentElement();\n    const width = doc.clientWidth;\n    const height = doc.clientHeight;\n    const right = left + width;\n    const bottom = top + height;\n    const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)({\n        top,\n        left,\n        right,\n        bottom\n    });\n    const viewport = {\n        frame,\n        scroll: {\n            initial: scroll,\n            current: scroll,\n            max: maxScroll,\n            diff: {\n                value: origin,\n                displacement: origin\n            }\n        }\n    };\n    return viewport;\n};\nvar getInitialPublish = (_ref)=>{\n    let { critical, scrollOptions, registry } = _ref;\n    start();\n    const viewport = getViewport();\n    const windowScroll = viewport.scroll.current;\n    const home = critical.droppable;\n    const droppables = registry.droppable.getAllByType(home.type).map((entry)=>entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions));\n    const draggables = registry.draggable.getAllByType(critical.draggable.type).map((entry)=>entry.getDimension(windowScroll));\n    const dimensions = {\n        draggables: toDraggableMap(draggables),\n        droppables: toDroppableMap(droppables)\n    };\n    finish();\n    const result = {\n        dimensions,\n        critical,\n        viewport\n    };\n    return result;\n};\nfunction shouldPublishUpdate(registry, dragging, entry) {\n    if (entry.descriptor.id === dragging.id) {\n        return false;\n    }\n    if (entry.descriptor.type !== dragging.type) {\n        return false;\n    }\n    const home = registry.droppable.getById(entry.descriptor.droppableId);\n    if (home.descriptor.mode !== \"virtual\") {\n         true ? warning(`\n      You are attempting to add or remove a Draggable [id: ${entry.descriptor.id}]\n      while a drag is occurring. This is only supported for virtual lists.\n\n      See https://github.com/hello-pangea/dnd/blob/main/docs/patterns/virtual-lists.md\n    `) : 0;\n        return false;\n    }\n    return true;\n}\nvar createDimensionMarshal = (registry, callbacks)=>{\n    let collection = null;\n    const publisher = createPublisher({\n        callbacks: {\n            publish: callbacks.publishWhileDragging,\n            collectionStarting: callbacks.collectionStarting\n        },\n        registry\n    });\n    const updateDroppableIsEnabled = (id, isEnabled)=>{\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update is enabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n        if (!collection) {\n            return;\n        }\n        callbacks.updateDroppableIsEnabled({\n            id,\n            isEnabled\n        });\n    };\n    const updateDroppableIsCombineEnabled = (id, isCombineEnabled)=>{\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update isCombineEnabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n        callbacks.updateDroppableIsCombineEnabled({\n            id,\n            isCombineEnabled\n        });\n    };\n    const updateDroppableScroll = (id, newScroll)=>{\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update the scroll on Droppable ${id} as it is not registered`) : 0 : void 0;\n        callbacks.updateDroppableScroll({\n            id,\n            newScroll\n        });\n    };\n    const scrollDroppable = (id, change)=>{\n        if (!collection) {\n            return;\n        }\n        registry.droppable.getById(id).callbacks.scroll(change);\n    };\n    const stopPublishing = ()=>{\n        if (!collection) {\n            return;\n        }\n        publisher.stop();\n        const home = collection.critical.droppable;\n        registry.droppable.getAllByType(home.type).forEach((entry)=>entry.callbacks.dragStopped());\n        collection.unsubscribe();\n        collection = null;\n    };\n    const subscriber = (event)=>{\n        !collection ?  true ? invariant(false, \"Should only be subscribed when a collection is occurring\") : 0 : void 0;\n        const dragging = collection.critical.draggable;\n        if (event.type === \"ADDITION\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.add(event.value);\n            }\n        }\n        if (event.type === \"REMOVAL\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.remove(event.value);\n            }\n        }\n    };\n    const startPublishing = (request)=>{\n        !!collection ?  true ? invariant(false, \"Cannot start capturing critical dimensions as there is already a collection\") : 0 : void 0;\n        const entry = registry.draggable.getById(request.draggableId);\n        const home = registry.droppable.getById(entry.descriptor.droppableId);\n        const critical = {\n            draggable: entry.descriptor,\n            droppable: home.descriptor\n        };\n        const unsubscribe = registry.subscribe(subscriber);\n        collection = {\n            critical,\n            unsubscribe\n        };\n        return getInitialPublish({\n            critical,\n            registry,\n            scrollOptions: request.scrollOptions\n        });\n    };\n    const marshal = {\n        updateDroppableIsEnabled,\n        updateDroppableIsCombineEnabled,\n        scrollDroppable,\n        updateDroppableScroll,\n        startPublishing,\n        stopPublishing\n    };\n    return marshal;\n};\nvar canStartDrag = (state, id)=>{\n    if (state.phase === \"IDLE\") {\n        return true;\n    }\n    if (state.phase !== \"DROP_ANIMATING\") {\n        return false;\n    }\n    if (state.completed.result.draggableId === id) {\n        return false;\n    }\n    return state.completed.result.reason === \"DROP\";\n};\nvar scrollWindow = (change)=>{\n    window.scrollBy(change.x, change.y);\n};\nconst getScrollableDroppables = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((droppables)=>toDroppableList(droppables).filter((droppable)=>{\n        if (!droppable.isEnabled) {\n            return false;\n        }\n        if (!droppable.frame) {\n            return false;\n        }\n        return true;\n    }));\nconst getScrollableDroppableOver = (target, droppables)=>{\n    const maybe = getScrollableDroppables(droppables).find((droppable)=>{\n        !droppable.frame ?  true ? invariant(false, \"Invalid result\") : 0 : void 0;\n        return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n    }) || null;\n    return maybe;\n};\nvar getBestScrollableDroppable = (_ref)=>{\n    let { center, destination, droppables } = _ref;\n    if (destination) {\n        const dimension = droppables[destination];\n        if (!dimension.frame) {\n            return null;\n        }\n        return dimension;\n    }\n    const dimension = getScrollableDroppableOver(center, droppables);\n    return dimension;\n};\nconst defaultAutoScrollerOptions = {\n    startFromPercentage: 0.25,\n    maxScrollAtPercentage: 0.05,\n    maxPixelScroll: 28,\n    ease: (percentage)=>percentage ** 2,\n    durationDampening: {\n        stopDampeningAt: 1200,\n        accelerateAt: 360\n    },\n    disabled: false\n};\nvar getDistanceThresholds = function(container, axis, getAutoScrollerOptions) {\n    if (getAutoScrollerOptions === void 0) {\n        getAutoScrollerOptions = ()=>defaultAutoScrollerOptions;\n    }\n    const autoScrollerOptions = getAutoScrollerOptions();\n    const startScrollingFrom = container[axis.size] * autoScrollerOptions.startFromPercentage;\n    const maxScrollValueAt = container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;\n    const thresholds = {\n        startScrollingFrom,\n        maxScrollValueAt\n    };\n    return thresholds;\n};\nvar getPercentage = (_ref)=>{\n    let { startOfRange, endOfRange, current } = _ref;\n    const range = endOfRange - startOfRange;\n    if (range === 0) {\n         true ? warning(`\n      Detected distance range of 0 in the fluid auto scroller\n      This is unexpected and would cause a divide by 0 issue.\n      Not allowing an auto scroll\n    `) : 0;\n        return 0;\n    }\n    const currentInRange = current - startOfRange;\n    const percentage = currentInRange / range;\n    return percentage;\n};\nvar minScroll = 1;\nvar getValueFromDistance = function(distanceToEdge, thresholds, getAutoScrollerOptions) {\n    if (getAutoScrollerOptions === void 0) {\n        getAutoScrollerOptions = ()=>defaultAutoScrollerOptions;\n    }\n    const autoScrollerOptions = getAutoScrollerOptions();\n    if (distanceToEdge > thresholds.startScrollingFrom) {\n        return 0;\n    }\n    if (distanceToEdge <= thresholds.maxScrollValueAt) {\n        return autoScrollerOptions.maxPixelScroll;\n    }\n    if (distanceToEdge === thresholds.startScrollingFrom) {\n        return minScroll;\n    }\n    const percentageFromMaxScrollValueAt = getPercentage({\n        startOfRange: thresholds.maxScrollValueAt,\n        endOfRange: thresholds.startScrollingFrom,\n        current: distanceToEdge\n    });\n    const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n    const scroll = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);\n    return Math.ceil(scroll);\n};\nvar dampenValueByTime = (proposedScroll, dragStartTime, getAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    const accelerateAt = autoScrollerOptions.durationDampening.accelerateAt;\n    const stopAt = autoScrollerOptions.durationDampening.stopDampeningAt;\n    const startOfRange = dragStartTime;\n    const endOfRange = stopAt;\n    const now = Date.now();\n    const runTime = now - startOfRange;\n    if (runTime >= stopAt) {\n        return proposedScroll;\n    }\n    if (runTime < accelerateAt) {\n        return minScroll;\n    }\n    const betweenAccelerateAtAndStopAtPercentage = getPercentage({\n        startOfRange: accelerateAt,\n        endOfRange,\n        current: runTime\n    });\n    const scroll = proposedScroll * autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);\n    return Math.ceil(scroll);\n};\nvar getValue = (_ref)=>{\n    let { distanceToEdge, thresholds, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions } = _ref;\n    const scroll = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);\n    if (scroll === 0) {\n        return 0;\n    }\n    if (!shouldUseTimeDampening) {\n        return scroll;\n    }\n    return Math.max(dampenValueByTime(scroll, dragStartTime, getAutoScrollerOptions), minScroll);\n};\nvar getScrollOnAxis = (_ref)=>{\n    let { container, distanceToEdges, dragStartTime, axis, shouldUseTimeDampening, getAutoScrollerOptions } = _ref;\n    const thresholds = getDistanceThresholds(container, axis, getAutoScrollerOptions);\n    const isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n    if (isCloserToEnd) {\n        return getValue({\n            distanceToEdge: distanceToEdges[axis.end],\n            thresholds,\n            dragStartTime,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n    }\n    return -1 * getValue({\n        distanceToEdge: distanceToEdges[axis.start],\n        thresholds,\n        dragStartTime,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n};\nvar adjustForSizeLimits = (_ref)=>{\n    let { container, subject, proposedScroll } = _ref;\n    const isTooBigVertically = subject.height > container.height;\n    const isTooBigHorizontally = subject.width > container.width;\n    if (!isTooBigHorizontally && !isTooBigVertically) {\n        return proposedScroll;\n    }\n    if (isTooBigHorizontally && isTooBigVertically) {\n        return null;\n    }\n    return {\n        x: isTooBigHorizontally ? 0 : proposedScroll.x,\n        y: isTooBigVertically ? 0 : proposedScroll.y\n    };\n};\nconst clean = apply((value)=>value === 0 ? 0 : value);\nvar getScroll$1 = (_ref)=>{\n    let { dragStartTime, container, subject, center, shouldUseTimeDampening, getAutoScrollerOptions } = _ref;\n    const distanceToEdges = {\n        top: center.y - container.top,\n        right: container.right - center.x,\n        bottom: container.bottom - center.y,\n        left: center.x - container.left\n    };\n    const y = getScrollOnAxis({\n        container,\n        distanceToEdges,\n        dragStartTime,\n        axis: vertical,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    const x = getScrollOnAxis({\n        container,\n        distanceToEdges,\n        dragStartTime,\n        axis: horizontal,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    const required = clean({\n        x,\n        y\n    });\n    if (isEqual$1(required, origin)) {\n        return null;\n    }\n    const limited = adjustForSizeLimits({\n        container,\n        subject,\n        proposedScroll: required\n    });\n    if (!limited) {\n        return null;\n    }\n    return isEqual$1(limited, origin) ? null : limited;\n};\nconst smallestSigned = apply((value)=>{\n    if (value === 0) {\n        return 0;\n    }\n    return value > 0 ? 1 : -1;\n});\nconst getOverlap = (()=>{\n    const getRemainder = (target, max)=>{\n        if (target < 0) {\n            return target;\n        }\n        if (target > max) {\n            return target - max;\n        }\n        return 0;\n    };\n    return (_ref)=>{\n        let { current, max, change } = _ref;\n        const targetScroll = add(current, change);\n        const overlap = {\n            x: getRemainder(targetScroll.x, max.x),\n            y: getRemainder(targetScroll.y, max.y)\n        };\n        if (isEqual$1(overlap, origin)) {\n            return null;\n        }\n        return overlap;\n    };\n})();\nconst canPartiallyScroll = (_ref2)=>{\n    let { max: rawMax, current, change } = _ref2;\n    const max = {\n        x: Math.max(current.x, rawMax.x),\n        y: Math.max(current.y, rawMax.y)\n    };\n    const smallestChange = smallestSigned(change);\n    const overlap = getOverlap({\n        max,\n        current,\n        change: smallestChange\n    });\n    if (!overlap) {\n        return true;\n    }\n    if (smallestChange.x !== 0 && overlap.x === 0) {\n        return true;\n    }\n    if (smallestChange.y !== 0 && overlap.y === 0) {\n        return true;\n    }\n    return false;\n};\nconst canScrollWindow = (viewport, change)=>canPartiallyScroll({\n        current: viewport.scroll.current,\n        max: viewport.scroll.max,\n        change\n    });\nconst getWindowOverlap = (viewport, change)=>{\n    if (!canScrollWindow(viewport, change)) {\n        return null;\n    }\n    const max = viewport.scroll.max;\n    const current = viewport.scroll.current;\n    return getOverlap({\n        current,\n        max,\n        change\n    });\n};\nconst canScrollDroppable = (droppable, change)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return false;\n    }\n    return canPartiallyScroll({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change\n    });\n};\nconst getDroppableOverlap = (droppable, change)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    if (!canScrollDroppable(droppable, change)) {\n        return null;\n    }\n    return getOverlap({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change\n    });\n};\nvar getWindowScrollChange = (_ref)=>{\n    let { viewport, subject, center, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions } = _ref;\n    const scroll = getScroll$1({\n        dragStartTime,\n        container: viewport.frame,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n};\nvar getDroppableScrollChange = (_ref)=>{\n    let { droppable, subject, center, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions } = _ref;\n    const frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    const scroll = getScroll$1({\n        dragStartTime,\n        container: frame.pageMarginBox,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n};\nvar scroll = (_ref)=>{\n    let { state, dragStartTime, shouldUseTimeDampening, scrollWindow, scrollDroppable, getAutoScrollerOptions } = _ref;\n    const center = state.current.page.borderBoxCenter;\n    const draggable = state.dimensions.draggables[state.critical.draggable.id];\n    const subject = draggable.page.marginBox;\n    if (state.isWindowScrollAllowed) {\n        const viewport = state.viewport;\n        const change = getWindowScrollChange({\n            dragStartTime,\n            viewport,\n            subject,\n            center,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n        if (change) {\n            scrollWindow(change);\n            return;\n        }\n    }\n    const droppable = getBestScrollableDroppable({\n        center,\n        destination: whatIsDraggedOver(state.impact),\n        droppables: state.dimensions.droppables\n    });\n    if (!droppable) {\n        return;\n    }\n    const change = getDroppableScrollChange({\n        dragStartTime,\n        droppable,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    if (change) {\n        scrollDroppable(droppable.descriptor.id, change);\n    }\n};\nvar createFluidScroller = (_ref)=>{\n    let { scrollWindow, scrollDroppable, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions } = _ref;\n    const scheduleWindowScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(scrollWindow);\n    const scheduleDroppableScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(scrollDroppable);\n    let dragging = null;\n    const tryScroll = (state)=>{\n        !dragging ?  true ? invariant(false, \"Cannot fluid scroll if not dragging\") : 0 : void 0;\n        const { shouldUseTimeDampening, dragStartTime } = dragging;\n        scroll({\n            state,\n            scrollWindow: scheduleWindowScroll,\n            scrollDroppable: scheduleDroppableScroll,\n            dragStartTime,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n    };\n    const start$1 = (state)=>{\n        start();\n        !!dragging ?  true ? invariant(false, \"Cannot start auto scrolling when already started\") : 0 : void 0;\n        const dragStartTime = Date.now();\n        let wasScrollNeeded = false;\n        const fakeScrollCallback = ()=>{\n            wasScrollNeeded = true;\n        };\n        scroll({\n            state,\n            dragStartTime: 0,\n            shouldUseTimeDampening: false,\n            scrollWindow: fakeScrollCallback,\n            scrollDroppable: fakeScrollCallback,\n            getAutoScrollerOptions\n        });\n        dragging = {\n            dragStartTime,\n            shouldUseTimeDampening: wasScrollNeeded\n        };\n        finish();\n        if (wasScrollNeeded) {\n            tryScroll(state);\n        }\n    };\n    const stop = ()=>{\n        if (!dragging) {\n            return;\n        }\n        scheduleWindowScroll.cancel();\n        scheduleDroppableScroll.cancel();\n        dragging = null;\n    };\n    return {\n        start: start$1,\n        stop,\n        scroll: tryScroll\n    };\n};\nvar createJumpScroller = (_ref)=>{\n    let { move, scrollDroppable, scrollWindow } = _ref;\n    const moveByOffset = (state, offset)=>{\n        const client = add(state.current.client.selection, offset);\n        move({\n            client\n        });\n    };\n    const scrollDroppableAsMuchAsItCan = (droppable, change)=>{\n        if (!canScrollDroppable(droppable, change)) {\n            return change;\n        }\n        const overlap = getDroppableOverlap(droppable, change);\n        if (!overlap) {\n            scrollDroppable(droppable.descriptor.id, change);\n            return null;\n        }\n        const whatTheDroppableCanScroll = subtract(change, overlap);\n        scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n        const remainder = subtract(change, whatTheDroppableCanScroll);\n        return remainder;\n    };\n    const scrollWindowAsMuchAsItCan = (isWindowScrollAllowed, viewport, change)=>{\n        if (!isWindowScrollAllowed) {\n            return change;\n        }\n        if (!canScrollWindow(viewport, change)) {\n            return change;\n        }\n        const overlap = getWindowOverlap(viewport, change);\n        if (!overlap) {\n            scrollWindow(change);\n            return null;\n        }\n        const whatTheWindowCanScroll = subtract(change, overlap);\n        scrollWindow(whatTheWindowCanScroll);\n        const remainder = subtract(change, whatTheWindowCanScroll);\n        return remainder;\n    };\n    const jumpScroller = (state)=>{\n        const request = state.scrollJumpRequest;\n        if (!request) {\n            return;\n        }\n        const destination = whatIsDraggedOver(state.impact);\n        !destination ?  true ? invariant(false, \"Cannot perform a jump scroll when there is no destination\") : 0 : void 0;\n        const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n        if (!droppableRemainder) {\n            return;\n        }\n        const viewport = state.viewport;\n        const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n        if (!windowRemainder) {\n            return;\n        }\n        moveByOffset(state, windowRemainder);\n    };\n    return jumpScroller;\n};\nvar createAutoScroller = (_ref)=>{\n    let { scrollDroppable, scrollWindow, move, getAutoScrollerOptions } = _ref;\n    const fluidScroller = createFluidScroller({\n        scrollWindow,\n        scrollDroppable,\n        getAutoScrollerOptions\n    });\n    const jumpScroll = createJumpScroller({\n        move,\n        scrollWindow,\n        scrollDroppable\n    });\n    const scroll = (state)=>{\n        const autoScrollerOptions = getAutoScrollerOptions();\n        if (autoScrollerOptions.disabled || state.phase !== \"DRAGGING\") {\n            return;\n        }\n        if (state.movementMode === \"FLUID\") {\n            fluidScroller.scroll(state);\n            return;\n        }\n        if (!state.scrollJumpRequest) {\n            return;\n        }\n        jumpScroll(state);\n    };\n    const scroller = {\n        scroll,\n        start: fluidScroller.start,\n        stop: fluidScroller.stop\n    };\n    return scroller;\n};\nconst prefix = \"data-rfd\";\nconst dragHandle = (()=>{\n    const base = `${prefix}-drag-handle`;\n    return {\n        base,\n        draggableId: `${base}-draggable-id`,\n        contextId: `${base}-context-id`\n    };\n})();\nconst draggable = (()=>{\n    const base = `${prefix}-draggable`;\n    return {\n        base,\n        contextId: `${base}-context-id`,\n        id: `${base}-id`\n    };\n})();\nconst droppable = (()=>{\n    const base = `${prefix}-droppable`;\n    return {\n        base,\n        contextId: `${base}-context-id`,\n        id: `${base}-id`\n    };\n})();\nconst scrollContainer = {\n    contextId: `${prefix}-scroll-container-context-id`\n};\nconst makeGetSelector = (context)=>(attribute)=>`[${attribute}=\"${context}\"]`;\nconst getStyles = (rules, property)=>rules.map((rule)=>{\n        const value = rule.styles[property];\n        if (!value) {\n            return \"\";\n        }\n        return `${rule.selector} { ${value} }`;\n    }).join(\" \");\nconst noPointerEvents = \"pointer-events: none;\";\nvar getStyles$1 = (contextId)=>{\n    const getSelector = makeGetSelector(contextId);\n    const dragHandle$1 = (()=>{\n        const grabCursor = `\n      cursor: -webkit-grab;\n      cursor: grab;\n    `;\n        return {\n            selector: getSelector(dragHandle.contextId),\n            styles: {\n                always: `\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        `,\n                resting: grabCursor,\n                dragging: noPointerEvents,\n                dropAnimating: grabCursor\n            }\n        };\n    })();\n    const draggable$1 = (()=>{\n        const transition = `\n      transition: ${transitions.outOfTheWay};\n    `;\n        return {\n            selector: getSelector(draggable.contextId),\n            styles: {\n                dragging: transition,\n                dropAnimating: transition,\n                userCancel: transition\n            }\n        };\n    })();\n    const droppable$1 = {\n        selector: getSelector(droppable.contextId),\n        styles: {\n            always: `overflow-anchor: none;`\n        }\n    };\n    const body = {\n        selector: \"body\",\n        styles: {\n            dragging: `\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      `\n        }\n    };\n    const rules = [\n        draggable$1,\n        dragHandle$1,\n        droppable$1,\n        body\n    ];\n    return {\n        always: getStyles(rules, \"always\"),\n        resting: getStyles(rules, \"resting\"),\n        dragging: getStyles(rules, \"dragging\"),\n        dropAnimating: getStyles(rules, \"dropAnimating\"),\n        userCancel: getStyles(rules, \"userCancel\")\n    };\n};\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useLayoutEffect = useIsomorphicLayoutEffect;\nconst getHead = ()=>{\n    const head = document.querySelector(\"head\");\n    !head ?  true ? invariant(false, \"Cannot find the head to append a style to\") : 0 : void 0;\n    return head;\n};\nconst createStyleEl = (nonce)=>{\n    const el = document.createElement(\"style\");\n    if (nonce) {\n        el.setAttribute(\"nonce\", nonce);\n    }\n    el.type = \"text/css\";\n    return el;\n};\nfunction useStyleMarshal(contextId, nonce) {\n    const styles = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>getStyles$1(contextId), [\n        contextId\n    ]);\n    const alwaysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const dynamicRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setDynamicStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((proposed)=>{\n        const el = dynamicRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }), []);\n    const setAlwaysStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((proposed)=>{\n        const el = alwaysRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }, []);\n    useLayoutEffect(()=>{\n        !(!alwaysRef.current && !dynamicRef.current) ?  true ? invariant(false, \"style elements already mounted\") : 0 : void 0;\n        const always = createStyleEl(nonce);\n        const dynamic = createStyleEl(nonce);\n        alwaysRef.current = always;\n        dynamicRef.current = dynamic;\n        always.setAttribute(`${prefix}-always`, contextId);\n        dynamic.setAttribute(`${prefix}-dynamic`, contextId);\n        getHead().appendChild(always);\n        getHead().appendChild(dynamic);\n        setAlwaysStyle(styles.always);\n        setDynamicStyle(styles.resting);\n        return ()=>{\n            const remove = (ref)=>{\n                const current = ref.current;\n                !current ?  true ? invariant(false, \"Cannot unmount ref as it is not set\") : 0 : void 0;\n                getHead().removeChild(current);\n                ref.current = null;\n            };\n            remove(alwaysRef);\n            remove(dynamicRef);\n        };\n    }, [\n        nonce,\n        setAlwaysStyle,\n        setDynamicStyle,\n        styles.always,\n        styles.resting,\n        contextId\n    ]);\n    const dragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>setDynamicStyle(styles.dragging), [\n        setDynamicStyle,\n        styles.dragging\n    ]);\n    const dropping = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((reason)=>{\n        if (reason === \"DROP\") {\n            setDynamicStyle(styles.dropAnimating);\n            return;\n        }\n        setDynamicStyle(styles.userCancel);\n    }, [\n        setDynamicStyle,\n        styles.dropAnimating,\n        styles.userCancel\n    ]);\n    const resting = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        if (!dynamicRef.current) {\n            return;\n        }\n        setDynamicStyle(styles.resting);\n    }, [\n        setDynamicStyle,\n        styles.resting\n    ]);\n    const marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            dragging,\n            dropping,\n            resting\n        }), [\n        dragging,\n        dropping,\n        resting\n    ]);\n    return marshal;\n}\nfunction querySelectorAll(parentNode, selector) {\n    return Array.from(parentNode.querySelectorAll(selector));\n}\nvar getWindowFromEl = (el)=>el?.ownerDocument?.defaultView || window;\nfunction isHtmlElement(el) {\n    return el instanceof getWindowFromEl(el).HTMLElement;\n}\nfunction findDragHandle(contextId, draggableId) {\n    const selector = `[${dragHandle.contextId}=\"${contextId}\"]`;\n    const possible = querySelectorAll(document, selector);\n    if (!possible.length) {\n         true ? warning(`Unable to find any drag handles in the context \"${contextId}\"`) : 0;\n        return null;\n    }\n    const handle = possible.find((el)=>{\n        return el.getAttribute(dragHandle.draggableId) === draggableId;\n    });\n    if (!handle) {\n         true ? warning(`Unable to find drag handle with id \"${draggableId}\" as no handle with a matching id was found`) : 0;\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle needs to be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction useFocusMarshal(contextId) {\n    const entriesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const recordRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const restoreFocusFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const register = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function register(id, focus) {\n        const entry = {\n            id,\n            focus\n        };\n        entriesRef.current[id] = entry;\n        return function unregister() {\n            const entries = entriesRef.current;\n            const current = entries[id];\n            if (current !== entry) {\n                delete entries[id];\n            }\n        };\n    }, []);\n    const tryGiveFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryGiveFocus(tryGiveFocusTo) {\n        const handle = findDragHandle(contextId, tryGiveFocusTo);\n        if (handle && handle !== document.activeElement) {\n            handle.focus();\n        }\n    }, [\n        contextId\n    ]);\n    const tryShiftRecord = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryShiftRecord(previous, redirectTo) {\n        if (recordRef.current === previous) {\n            recordRef.current = redirectTo;\n        }\n    }, []);\n    const tryRestoreFocusRecorded = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryRestoreFocusRecorded() {\n        if (restoreFocusFrameRef.current) {\n            return;\n        }\n        if (!isMountedRef.current) {\n            return;\n        }\n        restoreFocusFrameRef.current = requestAnimationFrame(()=>{\n            restoreFocusFrameRef.current = null;\n            const record = recordRef.current;\n            if (record) {\n                tryGiveFocus(record);\n            }\n        });\n    }, [\n        tryGiveFocus\n    ]);\n    const tryRecordFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryRecordFocus(id) {\n        recordRef.current = null;\n        const focused = document.activeElement;\n        if (!focused) {\n            return;\n        }\n        if (focused.getAttribute(dragHandle.draggableId) !== id) {\n            return;\n        }\n        recordRef.current = id;\n    }, []);\n    useLayoutEffect(()=>{\n        isMountedRef.current = true;\n        return function clearFrameOnUnmount() {\n            isMountedRef.current = false;\n            const frameId = restoreFocusFrameRef.current;\n            if (frameId) {\n                cancelAnimationFrame(frameId);\n            }\n        };\n    }, []);\n    const marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            register,\n            tryRecordFocus,\n            tryRestoreFocusRecorded,\n            tryShiftRecord\n        }), [\n        register,\n        tryRecordFocus,\n        tryRestoreFocusRecorded,\n        tryShiftRecord\n    ]);\n    return marshal;\n}\nfunction createRegistry() {\n    const entries = {\n        draggables: {},\n        droppables: {}\n    };\n    const subscribers = [];\n    function subscribe(cb) {\n        subscribers.push(cb);\n        return function unsubscribe() {\n            const index = subscribers.indexOf(cb);\n            if (index === -1) {\n                return;\n            }\n            subscribers.splice(index, 1);\n        };\n    }\n    function notify(event) {\n        if (subscribers.length) {\n            subscribers.forEach((cb)=>cb(event));\n        }\n    }\n    function findDraggableById(id) {\n        return entries.draggables[id] || null;\n    }\n    function getDraggableById(id) {\n        const entry = findDraggableById(id);\n        !entry ?  true ? invariant(false, `Cannot find draggable entry with id [${id}]`) : 0 : void 0;\n        return entry;\n    }\n    const draggableAPI = {\n        register: (entry)=>{\n            entries.draggables[entry.descriptor.id] = entry;\n            notify({\n                type: \"ADDITION\",\n                value: entry\n            });\n        },\n        update: (entry, last)=>{\n            const current = entries.draggables[last.descriptor.id];\n            if (!current) {\n                return;\n            }\n            if (current.uniqueId !== entry.uniqueId) {\n                return;\n            }\n            delete entries.draggables[last.descriptor.id];\n            entries.draggables[entry.descriptor.id] = entry;\n        },\n        unregister: (entry)=>{\n            const draggableId = entry.descriptor.id;\n            const current = findDraggableById(draggableId);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.draggables[draggableId];\n            if (entries.droppables[entry.descriptor.droppableId]) {\n                notify({\n                    type: \"REMOVAL\",\n                    value: entry\n                });\n            }\n        },\n        getById: getDraggableById,\n        findById: findDraggableById,\n        exists: (id)=>Boolean(findDraggableById(id)),\n        getAllByType: (type)=>Object.values(entries.draggables).filter((entry)=>entry.descriptor.type === type)\n    };\n    function findDroppableById(id) {\n        return entries.droppables[id] || null;\n    }\n    function getDroppableById(id) {\n        const entry = findDroppableById(id);\n        !entry ?  true ? invariant(false, `Cannot find droppable entry with id [${id}]`) : 0 : void 0;\n        return entry;\n    }\n    const droppableAPI = {\n        register: (entry)=>{\n            entries.droppables[entry.descriptor.id] = entry;\n        },\n        unregister: (entry)=>{\n            const current = findDroppableById(entry.descriptor.id);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.droppables[entry.descriptor.id];\n        },\n        getById: getDroppableById,\n        findById: findDroppableById,\n        exists: (id)=>Boolean(findDroppableById(id)),\n        getAllByType: (type)=>Object.values(entries.droppables).filter((entry)=>entry.descriptor.type === type)\n    };\n    function clean() {\n        entries.draggables = {};\n        entries.droppables = {};\n        subscribers.length = 0;\n    }\n    return {\n        draggable: draggableAPI,\n        droppable: droppableAPI,\n        subscribe,\n        clean\n    };\n}\nfunction useRegistry() {\n    const registry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(createRegistry, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return function unmount() {\n            if (react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"16\") || react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"17\")) {\n                requestAnimationFrame(registry.clean);\n            } else {\n                registry.clean();\n            }\n        };\n    }, [\n        registry\n    ]);\n    return registry;\n}\nvar StoreContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar getBodyElement = ()=>{\n    const body = document.body;\n    !body ?  true ? invariant(false, \"Cannot find document.body\") : 0 : void 0;\n    return body;\n};\nconst visuallyHidden = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    margin: \"-1px\",\n    border: \"0\",\n    padding: \"0\",\n    overflow: \"hidden\",\n    clip: \"rect(0 0 0 0)\",\n    \"clip-path\": \"inset(100%)\"\n};\nvar visuallyHidden$1 = visuallyHidden;\nconst getId = (contextId)=>`rfd-announcement-${contextId}`;\nfunction useAnnouncer(contextId) {\n    const id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>getId(contextId), [\n        contextId\n    ]);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function setup() {\n        const el = document.createElement(\"div\");\n        ref.current = el;\n        el.id = id;\n        el.setAttribute(\"aria-live\", \"assertive\");\n        el.setAttribute(\"aria-atomic\", \"true\");\n        (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(el.style, visuallyHidden$1);\n        getBodyElement().appendChild(el);\n        return function cleanup() {\n            setTimeout(function remove() {\n                const body = getBodyElement();\n                if (body.contains(el)) {\n                    body.removeChild(el);\n                }\n                if (el === ref.current) {\n                    ref.current = null;\n                }\n            });\n        };\n    }, [\n        id\n    ]);\n    const announce = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((message)=>{\n        const el = ref.current;\n        if (el) {\n            el.textContent = message;\n            return;\n        }\n         true ? warning(`\n      A screen reader message was trying to be announced but it was unable to do so.\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\n      Consider calling provided.announce() before the unmount so that the instruction will\n      not be lost for users relying on a screen reader.\n\n      Message not passed to screen reader:\n\n      \"${message}\"\n    `) : 0;\n    }, []);\n    return announce;\n}\nlet count$1 = 0;\nconst defaults = {\n    separator: \"::\"\n};\nfunction resetDeprecatedUniqueId() {\n    count$1 = 0;\n}\nfunction useDeprecatedUniqueId(prefix, options) {\n    if (options === void 0) {\n        options = defaults;\n    }\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>`${prefix}${options.separator}${count$1++}`, [\n        options.separator,\n        prefix\n    ]);\n}\nfunction useUniqueId(prefix, options) {\n    if (options === void 0) {\n        options = defaults;\n    }\n    const id = react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>`${prefix}${options.separator}${id}`, [\n        options.separator,\n        prefix,\n        id\n    ]);\n}\nvar useUniqueId$1 = \"useId\" in (react__WEBPACK_IMPORTED_MODULE_0___default()) ? useUniqueId : useDeprecatedUniqueId;\nfunction getElementId(_ref) {\n    let { contextId, uniqueId } = _ref;\n    return `rfd-hidden-text-${contextId}-${uniqueId}`;\n}\nfunction useHiddenTextElement(_ref2) {\n    let { contextId, text } = _ref2;\n    const uniqueId = useUniqueId$1(\"hidden-text\", {\n        separator: \"-\"\n    });\n    const id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>getElementId({\n            contextId,\n            uniqueId\n        }), [\n        uniqueId,\n        contextId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function mount() {\n        const el = document.createElement(\"div\");\n        el.id = id;\n        el.textContent = text;\n        el.style.display = \"none\";\n        getBodyElement().appendChild(el);\n        return function unmount() {\n            const body = getBodyElement();\n            if (body.contains(el)) {\n                body.removeChild(el);\n            }\n        };\n    }, [\n        id,\n        text\n    ]);\n    return id;\n}\nvar AppContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar peerDependencies = {\n    react: \"^16.8.5 || ^17.0.0 || ^18.0.0\",\n    \"react-dom\": \"^16.8.5 || ^17.0.0 || ^18.0.0\"\n};\nconst semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\nconst getVersion = (value)=>{\n    const result = semver.exec(value);\n    !(result != null) ?  true ? invariant(false, `Unable to parse React version ${value}`) : 0 : void 0;\n    const major = Number(result[1]);\n    const minor = Number(result[2]);\n    const patch = Number(result[3]);\n    return {\n        major,\n        minor,\n        patch,\n        raw: value\n    };\n};\nconst isSatisfied = (expected, actual)=>{\n    if (actual.major > expected.major) {\n        return true;\n    }\n    if (actual.major < expected.major) {\n        return false;\n    }\n    if (actual.minor > expected.minor) {\n        return true;\n    }\n    if (actual.minor < expected.minor) {\n        return false;\n    }\n    return actual.patch >= expected.patch;\n};\nvar checkReactVersion = (peerDepValue, actualValue)=>{\n    const peerDep = getVersion(peerDepValue);\n    const actual = getVersion(actualValue);\n    if (isSatisfied(peerDep, actual)) {\n        return;\n    }\n     true ? warning(`\n    React version: [${actual.raw}]\n    does not satisfy expected peer dependency version: [${peerDep.raw}]\n\n    This can result in run time bugs, and even fatal crashes\n  `) : 0;\n};\nconst suffix = `\n  We expect a html5 doctype: <!doctype html>\n  This is to ensure consistent browser layout and measurement\n\n  More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/doctype.md\n`;\nvar checkDoctype = (doc)=>{\n    const doctype = doc.doctype;\n    if (!doctype) {\n         true ? warning(`\n      No <!doctype html> found.\n\n      ${suffix}\n    `) : 0;\n        return;\n    }\n    if (doctype.name.toLowerCase() !== \"html\") {\n         true ? warning(`\n      Unexpected <!doctype> found: (${doctype.name})\n\n      ${suffix}\n    `) : 0;\n    }\n    if (doctype.publicId !== \"\") {\n         true ? warning(`\n      Unexpected <!doctype> publicId found: (${doctype.publicId})\n      A html5 doctype does not have a publicId\n\n      ${suffix}\n    `) : 0;\n    }\n};\nfunction useDev(useHook) {\n    if (true) {\n        useHook();\n    }\n}\nfunction useDevSetupWarning(fn, inputs) {\n    useDev(()=>{\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            try {\n                fn();\n            } catch (e) {\n                error(`\n          A setup problem was encountered.\n\n          > ${e.message}\n        `);\n            }\n        }, inputs);\n    });\n}\nfunction useStartupValidation() {\n    useDevSetupWarning(()=>{\n        checkReactVersion(peerDependencies.react, (react__WEBPACK_IMPORTED_MODULE_0___default().version));\n        checkDoctype(document);\n    }, []);\n}\nfunction usePrevious(current) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = current;\n    });\n    return ref;\n}\nfunction create() {\n    let lock = null;\n    function isClaimed() {\n        return Boolean(lock);\n    }\n    function isActive(value) {\n        return value === lock;\n    }\n    function claim(abandon) {\n        !!lock ?  true ? invariant(false, \"Cannot claim lock as it is already claimed\") : 0 : void 0;\n        const newLock = {\n            abandon\n        };\n        lock = newLock;\n        return newLock;\n    }\n    function release() {\n        !lock ?  true ? invariant(false, \"Cannot release lock when there is no lock\") : 0 : void 0;\n        lock = null;\n    }\n    function tryAbandon() {\n        if (lock) {\n            lock.abandon();\n            release();\n        }\n    }\n    return {\n        isClaimed,\n        isActive,\n        claim,\n        release,\n        tryAbandon\n    };\n}\nfunction isDragging(state) {\n    if (state.phase === \"IDLE\" || state.phase === \"DROP_ANIMATING\") {\n        return false;\n    }\n    return state.isDragging;\n}\nconst tab = 9;\nconst enter = 13;\nconst escape = 27;\nconst space = 32;\nconst pageUp = 33;\nconst pageDown = 34;\nconst end = 35;\nconst home = 36;\nconst arrowLeft = 37;\nconst arrowUp = 38;\nconst arrowRight = 39;\nconst arrowDown = 40;\nconst preventedKeys = {\n    [enter]: true,\n    [tab]: true\n};\nvar preventStandardKeyEvents = (event)=>{\n    if (preventedKeys[event.keyCode]) {\n        event.preventDefault();\n    }\n};\nconst supportedEventName = (()=>{\n    const base = \"visibilitychange\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    const candidates = [\n        base,\n        `ms${base}`,\n        `webkit${base}`,\n        `moz${base}`,\n        `o${base}`\n    ];\n    const supported = candidates.find((eventName)=>`on${eventName}` in document);\n    return supported || base;\n})();\nvar supportedPageVisibilityEventName = supportedEventName;\nconst primaryButton = 0;\nconst sloppyClickThreshold = 5;\nfunction isSloppyClickThresholdExceeded(original, current) {\n    return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\nconst idle$1 = {\n    type: \"IDLE\"\n};\nfunction getCaptureBindings(_ref) {\n    let { cancel, completed, getPhase, setPhase } = _ref;\n    return [\n        {\n            eventName: \"mousemove\",\n            fn: (event)=>{\n                const { button, clientX, clientY } = event;\n                if (button !== primaryButton) {\n                    return;\n                }\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                const phase = getPhase();\n                if (phase.type === \"DRAGGING\") {\n                    event.preventDefault();\n                    phase.actions.move(point);\n                    return;\n                }\n                !(phase.type === \"PENDING\") ?  true ? invariant(false, \"Cannot be IDLE\") : 0 : void 0;\n                const pending = phase.point;\n                if (!isSloppyClickThresholdExceeded(pending, point)) {\n                    return;\n                }\n                event.preventDefault();\n                const actions = phase.actions.fluidLift(point);\n                setPhase({\n                    type: \"DRAGGING\",\n                    actions\n                });\n            }\n        },\n        {\n            eventName: \"mouseup\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: (event)=>{\n                if (getPhase().type === \"DRAGGING\") {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type === \"PENDING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"scroll\",\n            options: {\n                passive: true,\n                capture: false\n            },\n            fn: ()=>{\n                if (getPhase().type === \"PENDING\") {\n                    cancel();\n                }\n            }\n        },\n        {\n            eventName: \"webkitmouseforcedown\",\n            fn: (event)=>{\n                const phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false, \"Unexpected phase\") : 0 : void 0;\n                if (phase.actions.shouldRespectForcePress()) {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedPageVisibilityEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useMouseSensor(api) {\n    const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$1);\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n    const startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            eventName: \"mousedown\",\n            fn: function onMouseDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.button !== primaryButton) {\n                    return;\n                }\n                if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                event.preventDefault();\n                const point = {\n                    x: event.clientX,\n                    y: event.clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        }), [\n        api\n    ]);\n    const preventForcePressBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            eventName: \"webkitmouseforcewillbegin\",\n            fn: (event)=>{\n                if (event.defaultPrevented) {\n                    return;\n                }\n                const id = api.findClosestDraggableId(event);\n                if (!id) {\n                    return;\n                }\n                const options = api.findOptionsForDraggable(id);\n                if (!options) {\n                    return;\n                }\n                if (options.shouldRespectForcePress) {\n                    return;\n                }\n                if (!api.canGetLock(id)) {\n                    return;\n                }\n                event.preventDefault();\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function listenForCapture() {\n        const options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            preventForcePressBinding,\n            startCaptureBinding\n        ], options);\n    }, [\n        preventForcePressBinding,\n        startCaptureBinding\n    ]);\n    const stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        phaseRef.current = idle$1;\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture\n    ]);\n    const cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    const bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function bindCapturingEvents() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        const bindings = getCaptureBindings({\n            cancel,\n            completed: stop,\n            getPhase: ()=>phaseRef.current,\n            setPhase: (phase)=>{\n                phaseRef.current = phase;\n            }\n        });\n        unbindEventsRef.current = bindEvents(window, bindings, options);\n    }, [\n        cancel,\n        stop\n    ]);\n    const startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function startPendingDrag(actions, point) {\n        !(phaseRef.current.type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        phaseRef.current = {\n            type: \"PENDING\",\n            point,\n            actions\n        };\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents\n    ]);\n    useLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nfunction noop$1() {}\nconst scrollJumpKeys = {\n    [pageDown]: true,\n    [pageUp]: true,\n    [home]: true,\n    [end]: true\n};\nfunction getDraggingBindings(actions, stop) {\n    function cancel() {\n        stop();\n        actions.cancel();\n    }\n    function drop() {\n        stop();\n        actions.drop();\n    }\n    return [\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === space) {\n                    event.preventDefault();\n                    drop();\n                    return;\n                }\n                if (event.keyCode === arrowDown) {\n                    event.preventDefault();\n                    actions.moveDown();\n                    return;\n                }\n                if (event.keyCode === arrowUp) {\n                    event.preventDefault();\n                    actions.moveUp();\n                    return;\n                }\n                if (event.keyCode === arrowRight) {\n                    event.preventDefault();\n                    actions.moveRight();\n                    return;\n                }\n                if (event.keyCode === arrowLeft) {\n                    event.preventDefault();\n                    actions.moveLeft();\n                    return;\n                }\n                if (scrollJumpKeys[event.keyCode]) {\n                    event.preventDefault();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: cancel\n        },\n        {\n            eventName: \"mouseup\",\n            fn: cancel\n        },\n        {\n            eventName: \"click\",\n            fn: cancel\n        },\n        {\n            eventName: \"touchstart\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"wheel\",\n            fn: cancel,\n            options: {\n                passive: true\n            }\n        },\n        {\n            eventName: supportedPageVisibilityEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useKeyboardSensor(api) {\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$1);\n    const startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            eventName: \"keydown\",\n            fn: function onKeyDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.keyCode !== space) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const preDrag = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!preDrag) {\n                    return;\n                }\n                event.preventDefault();\n                let isCapturing = true;\n                const actions = preDrag.snapLift();\n                unbindEventsRef.current();\n                function stop() {\n                    !isCapturing ?  true ? invariant(false, \"Cannot stop capturing a keyboard drag when not capturing\") : 0 : void 0;\n                    isCapturing = false;\n                    unbindEventsRef.current();\n                    listenForCapture();\n                }\n                unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n                    capture: true,\n                    passive: false\n                });\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryStartCapture() {\n        const options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    useLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nconst idle = {\n    type: \"IDLE\"\n};\nconst timeForLongPress = 120;\nconst forcePressThreshold = 0.15;\nfunction getWindowBindings(_ref) {\n    let { cancel, getPhase } = _ref;\n    return [\n        {\n            eventName: \"orientationchange\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"contextmenu\",\n            fn: (event)=>{\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: supportedPageVisibilityEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction getHandleBindings(_ref2) {\n    let { cancel, completed, getPhase } = _ref2;\n    return [\n        {\n            eventName: \"touchmove\",\n            options: {\n                capture: false\n            },\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                phase.hasMoved = true;\n                const { clientX, clientY } = event.touches[0];\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                event.preventDefault();\n                phase.actions.move(point);\n            }\n        },\n        {\n            eventName: \"touchend\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"touchcancel\",\n            fn: (event)=>{\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                cancel();\n            }\n        },\n        {\n            eventName: \"touchforcechange\",\n            fn: (event)=>{\n                const phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false) : 0 : void 0;\n                const touch = event.touches[0];\n                if (!touch) {\n                    return;\n                }\n                const isForcePress = touch.force >= forcePressThreshold;\n                if (!isForcePress) {\n                    return;\n                }\n                const shouldRespect = phase.actions.shouldRespectForcePress();\n                if (phase.type === \"PENDING\") {\n                    if (shouldRespect) {\n                        cancel();\n                    }\n                    return;\n                }\n                if (shouldRespect) {\n                    if (phase.hasMoved) {\n                        event.preventDefault();\n                        return;\n                    }\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedPageVisibilityEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useTouchSensor(api) {\n    const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle);\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n    const getPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function getPhase() {\n        return phaseRef.current;\n    }, []);\n    const setPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function setPhase(phase) {\n        phaseRef.current = phase;\n    }, []);\n    const startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            eventName: \"touchstart\",\n            fn: function onTouchStart(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                const touch = event.touches[0];\n                const { clientX, clientY } = touch;\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function listenForCapture() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    const stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        if (current.type === \"PENDING\") {\n            clearTimeout(current.longPressTimerId);\n        }\n        setPhase(idle);\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture,\n        setPhase\n    ]);\n    const cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    const bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function bindCapturingEvents() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        const args = {\n            cancel,\n            completed: stop,\n            getPhase\n        };\n        const unbindTarget = bindEvents(window, getHandleBindings(args), options);\n        const unbindWindow = bindEvents(window, getWindowBindings(args), options);\n        unbindEventsRef.current = function unbindAll() {\n            unbindTarget();\n            unbindWindow();\n        };\n    }, [\n        cancel,\n        getPhase,\n        stop\n    ]);\n    const startDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function startDragging() {\n        const phase = getPhase();\n        !(phase.type === \"PENDING\") ?  true ? invariant(false, `Cannot start dragging from phase ${phase.type}`) : 0 : void 0;\n        const actions = phase.actions.fluidLift(phase.point);\n        setPhase({\n            type: \"DRAGGING\",\n            actions,\n            hasMoved: false\n        });\n    }, [\n        getPhase,\n        setPhase\n    ]);\n    const startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function startPendingDrag(actions, point) {\n        !(getPhase().type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        const longPressTimerId = setTimeout(startDragging, timeForLongPress);\n        setPhase({\n            type: \"PENDING\",\n            point,\n            actions,\n            longPressTimerId\n        });\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents,\n        getPhase,\n        setPhase,\n        startDragging\n    ]);\n    useLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n            const phase = getPhase();\n            if (phase.type === \"PENDING\") {\n                clearTimeout(phase.longPressTimerId);\n                setPhase(idle);\n            }\n        };\n    }, [\n        getPhase,\n        listenForCapture,\n        setPhase\n    ]);\n    useLayoutEffect(function webkitHack() {\n        const unbind = bindEvents(window, [\n            {\n                eventName: \"touchmove\",\n                fn: ()=>{},\n                options: {\n                    capture: false,\n                    passive: false\n                }\n            }\n        ]);\n        return unbind;\n    }, []);\n}\nfunction useValidateSensorHooks(sensorHooks) {\n    useDev(()=>{\n        const previousRef = usePrevious(sensorHooks);\n        useDevSetupWarning(()=>{\n            !(previousRef.current.length === sensorHooks.length) ?  true ? invariant(false, \"Cannot change the amount of sensor hooks after mounting\") : 0 : void 0;\n        });\n    });\n}\nconst interactiveTagNames = [\n    \"input\",\n    \"button\",\n    \"textarea\",\n    \"select\",\n    \"option\",\n    \"optgroup\",\n    \"video\",\n    \"audio\"\n];\nfunction isAnInteractiveElement(parent, current) {\n    if (current == null) {\n        return false;\n    }\n    const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());\n    if (hasAnInteractiveTag) {\n        return true;\n    }\n    const attribute = current.getAttribute(\"contenteditable\");\n    if (attribute === \"true\" || attribute === \"\") {\n        return true;\n    }\n    if (current === parent) {\n        return false;\n    }\n    return isAnInteractiveElement(parent, current.parentElement);\n}\nfunction isEventInInteractiveElement(draggable, event) {\n    const target = event.target;\n    if (!isHtmlElement(target)) {\n        return false;\n    }\n    return isAnInteractiveElement(draggable, target);\n}\nvar getBorderBoxCenterPosition = (el)=>(0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)(el.getBoundingClientRect()).center;\nfunction isElement(el) {\n    return el instanceof getWindowFromEl(el).Element;\n}\nconst supportedMatchesName = (()=>{\n    const base = \"matches\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    const candidates = [\n        base,\n        \"msMatchesSelector\",\n        \"webkitMatchesSelector\"\n    ];\n    const value = candidates.find((name)=>name in Element.prototype);\n    return value || base;\n})();\nfunction closestPonyfill(el, selector) {\n    if (el == null) {\n        return null;\n    }\n    if (el[supportedMatchesName](selector)) {\n        return el;\n    }\n    return closestPonyfill(el.parentElement, selector);\n}\nfunction closest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    }\n    return closestPonyfill(el, selector);\n}\nfunction getSelector(contextId) {\n    return `[${dragHandle.contextId}=\"${contextId}\"]`;\n}\nfunction findClosestDragHandleFromEvent(contextId, event) {\n    const target = event.target;\n    if (!isElement(target)) {\n         true ? warning(\"event.target must be a Element\") : 0;\n        return null;\n    }\n    const selector = getSelector(contextId);\n    const handle = closest(target, selector);\n    if (!handle) {\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle must be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n    const handle = findClosestDragHandleFromEvent(contextId, event);\n    if (!handle) {\n        return null;\n    }\n    return handle.getAttribute(dragHandle.draggableId);\n}\nfunction findDraggable(contextId, draggableId) {\n    const selector = `[${draggable.contextId}=\"${contextId}\"]`;\n    const possible = querySelectorAll(document, selector);\n    const draggable$1 = possible.find((el)=>{\n        return el.getAttribute(draggable.id) === draggableId;\n    });\n    if (!draggable$1) {\n        return null;\n    }\n    if (!isHtmlElement(draggable$1)) {\n         true ? warning(\"Draggable element is not a HTMLElement\") : 0;\n        return null;\n    }\n    return draggable$1;\n}\nfunction preventDefault(event) {\n    event.preventDefault();\n}\nfunction isActive(_ref) {\n    let { expected, phase, isLockActive, shouldWarn } = _ref;\n    if (!isLockActive()) {\n        if (shouldWarn) {\n             true ? warning(`\n        Cannot perform action.\n        The sensor no longer has an action lock.\n\n        Tips:\n\n        - Throw away your action handlers when forceStop() is called\n        - Check actions.isActive() if you really need to\n      `) : 0;\n        }\n        return false;\n    }\n    if (expected !== phase) {\n        if (shouldWarn) {\n             true ? warning(`\n        Cannot perform action.\n        The actions you used belong to an outdated phase\n\n        Current phase: ${expected}\n        You called an action from outdated phase: ${phase}\n\n        Tips:\n\n        - Do not use preDragActions actions after calling preDragActions.lift()\n      `) : 0;\n        }\n        return false;\n    }\n    return true;\n}\nfunction canStart(_ref2) {\n    let { lockAPI, store, registry, draggableId } = _ref2;\n    if (lockAPI.isClaimed()) {\n        return false;\n    }\n    const entry = registry.draggable.findById(draggableId);\n    if (!entry) {\n         true ? warning(`Unable to find draggable with id: ${draggableId}`) : 0;\n        return false;\n    }\n    if (!entry.options.isEnabled) {\n        return false;\n    }\n    if (!canStartDrag(store.getState(), draggableId)) {\n        return false;\n    }\n    return true;\n}\nfunction tryStart(_ref3) {\n    let { lockAPI, contextId, store, registry, draggableId, forceSensorStop, sourceEvent } = _ref3;\n    const shouldStart = canStart({\n        lockAPI,\n        store,\n        registry,\n        draggableId\n    });\n    if (!shouldStart) {\n        return null;\n    }\n    const entry = registry.draggable.getById(draggableId);\n    const el = findDraggable(contextId, entry.descriptor.id);\n    if (!el) {\n         true ? warning(`Unable to find draggable element with id: ${draggableId}`) : 0;\n        return null;\n    }\n    if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n        return null;\n    }\n    const lock = lockAPI.claim(forceSensorStop || noop$2);\n    let phase = \"PRE_DRAG\";\n    function getShouldRespectForcePress() {\n        return entry.options.shouldRespectForcePress;\n    }\n    function isLockActive() {\n        return lockAPI.isActive(lock);\n    }\n    function tryDispatch(expected, getAction) {\n        if (isActive({\n            expected,\n            phase,\n            isLockActive,\n            shouldWarn: true\n        })) {\n            store.dispatch(getAction());\n        }\n    }\n    const tryDispatchWhenDragging = tryDispatch.bind(null, \"DRAGGING\");\n    function lift(args) {\n        function completed() {\n            lockAPI.release();\n            phase = \"COMPLETED\";\n        }\n        if (phase !== \"PRE_DRAG\") {\n            completed();\n             true ? invariant(false, `Cannot lift in phase ${phase}`) : 0;\n        }\n        store.dispatch(lift$1(args.liftActionArgs));\n        phase = \"DRAGGING\";\n        function finish(reason, options) {\n            if (options === void 0) {\n                options = {\n                    shouldBlockNextClick: false\n                };\n            }\n            args.cleanup();\n            if (options.shouldBlockNextClick) {\n                const unbind = bindEvents(window, [\n                    {\n                        eventName: \"click\",\n                        fn: preventDefault,\n                        options: {\n                            once: true,\n                            passive: false,\n                            capture: true\n                        }\n                    }\n                ]);\n                setTimeout(unbind);\n            }\n            completed();\n            store.dispatch(drop$1({\n                reason\n            }));\n        }\n        return {\n            isActive: ()=>isActive({\n                    expected: \"DRAGGING\",\n                    phase,\n                    isLockActive,\n                    shouldWarn: false\n                }),\n            shouldRespectForcePress: getShouldRespectForcePress,\n            drop: (options)=>finish(\"DROP\", options),\n            cancel: (options)=>finish(\"CANCEL\", options),\n            ...args.actions\n        };\n    }\n    function fluidLift(clientSelection) {\n        const move$1 = (0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((client)=>{\n            tryDispatchWhenDragging(()=>move({\n                    client\n                }));\n        });\n        const api = lift({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection,\n                movementMode: \"FLUID\"\n            },\n            cleanup: ()=>move$1.cancel(),\n            actions: {\n                move: move$1\n            }\n        });\n        return {\n            ...api,\n            move: move$1\n        };\n    }\n    function snapLift() {\n        const actions = {\n            moveUp: ()=>tryDispatchWhenDragging(moveUp),\n            moveRight: ()=>tryDispatchWhenDragging(moveRight),\n            moveDown: ()=>tryDispatchWhenDragging(moveDown),\n            moveLeft: ()=>tryDispatchWhenDragging(moveLeft)\n        };\n        return lift({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection: getBorderBoxCenterPosition(el),\n                movementMode: \"SNAP\"\n            },\n            cleanup: noop$2,\n            actions\n        });\n    }\n    function abortPreDrag() {\n        const shouldRelease = isActive({\n            expected: \"PRE_DRAG\",\n            phase,\n            isLockActive,\n            shouldWarn: true\n        });\n        if (shouldRelease) {\n            lockAPI.release();\n        }\n    }\n    const preDrag = {\n        isActive: ()=>isActive({\n                expected: \"PRE_DRAG\",\n                phase,\n                isLockActive,\n                shouldWarn: false\n            }),\n        shouldRespectForcePress: getShouldRespectForcePress,\n        fluidLift,\n        snapLift,\n        abort: abortPreDrag\n    };\n    return preDrag;\n}\nconst defaultSensors = [\n    useMouseSensor,\n    useKeyboardSensor,\n    useTouchSensor\n];\nfunction useSensorMarshal(_ref4) {\n    let { contextId, store, registry, customSensors, enableDefaultSensors } = _ref4;\n    const useSensors = [\n        ...enableDefaultSensors ? defaultSensors : [],\n        ...customSensors || []\n    ];\n    const lockAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>create())[0];\n    const tryAbandonLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryAbandonLock(previous, current) {\n        if (isDragging(previous) && !isDragging(current)) {\n            lockAPI.tryAbandon();\n        }\n    }, [\n        lockAPI\n    ]);\n    useLayoutEffect(function listenToStore() {\n        let previous = store.getState();\n        const unsubscribe = store.subscribe(()=>{\n            const current = store.getState();\n            tryAbandonLock(previous, current);\n            previous = current;\n        });\n        return unsubscribe;\n    }, [\n        lockAPI,\n        store,\n        tryAbandonLock\n    ]);\n    useLayoutEffect(()=>{\n        return lockAPI.tryAbandon;\n    }, [\n        lockAPI.tryAbandon\n    ]);\n    const canGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((draggableId)=>{\n        return canStart({\n            lockAPI,\n            registry,\n            store,\n            draggableId\n        });\n    }, [\n        lockAPI,\n        registry,\n        store\n    ]);\n    const tryGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((draggableId, forceStop, options)=>tryStart({\n            lockAPI,\n            registry,\n            contextId,\n            store,\n            draggableId,\n            forceSensorStop: forceStop || null,\n            sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n        }), [\n        contextId,\n        lockAPI,\n        registry,\n        store\n    ]);\n    const findClosestDraggableId = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((event)=>tryGetClosestDraggableIdFromEvent(contextId, event), [\n        contextId\n    ]);\n    const findOptionsForDraggable = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((id)=>{\n        const entry = registry.draggable.findById(id);\n        return entry ? entry.options : null;\n    }, [\n        registry.draggable\n    ]);\n    const tryReleaseLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryReleaseLock() {\n        if (!lockAPI.isClaimed()) {\n            return;\n        }\n        lockAPI.tryAbandon();\n        if (store.getState().phase !== \"IDLE\") {\n            store.dispatch(flush());\n        }\n    }, [\n        lockAPI,\n        store\n    ]);\n    const isLockClaimed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>lockAPI.isClaimed(), [\n        lockAPI\n    ]);\n    const api = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            canGetLock,\n            tryGetLock,\n            findClosestDraggableId,\n            findOptionsForDraggable,\n            tryReleaseLock,\n            isLockClaimed\n        }), [\n        canGetLock,\n        tryGetLock,\n        findClosestDraggableId,\n        findOptionsForDraggable,\n        tryReleaseLock,\n        isLockClaimed\n    ]);\n    useValidateSensorHooks(useSensors);\n    for(let i = 0; i < useSensors.length; i++){\n        useSensors[i](api);\n    }\n}\nconst createResponders = (props)=>({\n        onBeforeCapture: (t)=>{\n            const onBeforeCapureCallback = ()=>{\n                if (props.onBeforeCapture) {\n                    props.onBeforeCapture(t);\n                }\n            };\n            if (react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"16\") || react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"17\")) {\n                onBeforeCapureCallback();\n            } else {\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(onBeforeCapureCallback);\n            }\n        },\n        onBeforeDragStart: props.onBeforeDragStart,\n        onDragStart: props.onDragStart,\n        onDragEnd: props.onDragEnd,\n        onDragUpdate: props.onDragUpdate\n    });\nconst createAutoScrollerOptions = (props)=>({\n        ...defaultAutoScrollerOptions,\n        ...props.autoScrollerOptions,\n        durationDampening: {\n            ...defaultAutoScrollerOptions.durationDampening,\n            ...props.autoScrollerOptions\n        }\n    });\nfunction getStore(lazyRef) {\n    !lazyRef.current ?  true ? invariant(false, \"Could not find store from lazy ref\") : 0 : void 0;\n    return lazyRef.current;\n}\nfunction App(props) {\n    const { contextId, setCallbacks, sensors, nonce, dragHandleUsageInstructions } = props;\n    const lazyStoreRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    useStartupValidation();\n    const lastPropsRef = usePrevious(props);\n    const getResponders = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        return createResponders(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    const getAutoScrollerOptions = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        return createAutoScrollerOptions(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    const announce = useAnnouncer(contextId);\n    const dragHandleUsageInstructionsId = useHiddenTextElement({\n        contextId,\n        text: dragHandleUsageInstructions\n    });\n    const styleMarshal = useStyleMarshal(contextId, nonce);\n    const lazyDispatch = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((action)=>{\n        getStore(lazyStoreRef).dispatch(action);\n    }, []);\n    const marshalCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>(0,redux__WEBPACK_IMPORTED_MODULE_7__.bindActionCreators)({\n            publishWhileDragging,\n            updateDroppableScroll,\n            updateDroppableIsEnabled,\n            updateDroppableIsCombineEnabled,\n            collectionStarting\n        }, lazyDispatch), [\n        lazyDispatch\n    ]);\n    const registry = useRegistry();\n    const dimensionMarshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>{\n        return createDimensionMarshal(registry, marshalCallbacks);\n    }, [\n        registry,\n        marshalCallbacks\n    ]);\n    const autoScroller = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>createAutoScroller({\n            scrollWindow,\n            scrollDroppable: dimensionMarshal.scrollDroppable,\n            getAutoScrollerOptions,\n            ...(0,redux__WEBPACK_IMPORTED_MODULE_7__.bindActionCreators)({\n                move\n            }, lazyDispatch)\n        }), [\n        dimensionMarshal.scrollDroppable,\n        lazyDispatch,\n        getAutoScrollerOptions\n    ]);\n    const focusMarshal = useFocusMarshal(contextId);\n    const store = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>createStore({\n            announce,\n            autoScroller,\n            dimensionMarshal,\n            focusMarshal,\n            getResponders,\n            styleMarshal\n        }), [\n        announce,\n        autoScroller,\n        dimensionMarshal,\n        focusMarshal,\n        getResponders,\n        styleMarshal\n    ]);\n    if (true) {\n        if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n             true ? warning(\"unexpected store change\") : 0;\n        }\n    }\n    lazyStoreRef.current = store;\n    const tryResetStore = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const current = getStore(lazyStoreRef);\n        const state = current.getState();\n        if (state.phase !== \"IDLE\") {\n            current.dispatch(flush());\n        }\n    }, []);\n    const isDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const state = getStore(lazyStoreRef).getState();\n        if (state.phase === \"DROP_ANIMATING\") {\n            return true;\n        }\n        if (state.phase === \"IDLE\") {\n            return false;\n        }\n        return state.isDragging;\n    }, []);\n    const appCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            isDragging,\n            tryAbort: tryResetStore\n        }), [\n        isDragging,\n        tryResetStore\n    ]);\n    setCallbacks(appCallbacks);\n    const getCanLift = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((id)=>canStartDrag(getStore(lazyStoreRef).getState(), id), []);\n    const getIsMovementAllowed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>isMovementAllowed(getStore(lazyStoreRef).getState()), []);\n    const appContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            marshal: dimensionMarshal,\n            focus: focusMarshal,\n            contextId,\n            canLift: getCanLift,\n            isMovementAllowed: getIsMovementAllowed,\n            dragHandleUsageInstructionsId,\n            registry\n        }), [\n        contextId,\n        dimensionMarshal,\n        dragHandleUsageInstructionsId,\n        focusMarshal,\n        getCanLift,\n        getIsMovementAllowed,\n        registry\n    ]);\n    useSensorMarshal({\n        contextId,\n        store,\n        registry,\n        customSensors: sensors || null,\n        enableDefaultSensors: props.enableDefaultSensors !== false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return tryResetStore;\n    }, [\n        tryResetStore\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n        value: appContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_redux__WEBPACK_IMPORTED_MODULE_2__.Provider, {\n        context: StoreContext,\n        store: store\n    }, props.children));\n}\nlet count = 0;\nfunction resetDeprecatedUniqueContextId() {\n    count = 0;\n}\nfunction useDeprecatedUniqueContextId() {\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>`${count++}`, []);\n}\nfunction useUniqueContextId() {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n}\nvar useUniqueContextId$1 = \"useId\" in (react__WEBPACK_IMPORTED_MODULE_0___default()) ? useUniqueContextId : useDeprecatedUniqueContextId;\nfunction resetServerContext() {\n    if (\"useId\" in (react__WEBPACK_IMPORTED_MODULE_0___default())) {\n         true ? warning(`It is not necessary to call resetServerContext when using React 18+`) : 0;\n        return;\n    }\n    resetDeprecatedUniqueContextId();\n    resetDeprecatedUniqueId();\n}\nfunction DragDropContext(props) {\n    const contextId = useUniqueContextId$1();\n    const dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset$1.dragHandleUsageInstructions;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorBoundary, null, (setCallbacks)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(App, {\n            nonce: props.nonce,\n            contextId: contextId,\n            setCallbacks: setCallbacks,\n            dragHandleUsageInstructions: dragHandleUsageInstructions,\n            enableDefaultSensors: props.enableDefaultSensors,\n            sensors: props.sensors,\n            onBeforeCapture: props.onBeforeCapture,\n            onBeforeDragStart: props.onBeforeDragStart,\n            onDragStart: props.onDragStart,\n            onDragUpdate: props.onDragUpdate,\n            onDragEnd: props.onDragEnd,\n            autoScrollerOptions: props.autoScrollerOptions\n        }, props.children));\n}\nconst zIndexOptions = {\n    dragging: 5000,\n    dropAnimating: 4500\n};\nconst getDraggingTransition = (shouldAnimateDragMovement, dropping)=>{\n    if (dropping) {\n        return transitions.drop(dropping.duration);\n    }\n    if (shouldAnimateDragMovement) {\n        return transitions.snap;\n    }\n    return transitions.fluid;\n};\nconst getDraggingOpacity = (isCombining, isDropAnimating)=>{\n    if (!isCombining) {\n        return undefined;\n    }\n    return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\nconst getShouldDraggingAnimate = (dragging)=>{\n    if (dragging.forceShouldAnimate != null) {\n        return dragging.forceShouldAnimate;\n    }\n    return dragging.mode === \"SNAP\";\n};\nfunction getDraggingStyle(dragging) {\n    const dimension = dragging.dimension;\n    const box = dimension.client;\n    const { offset, combineWith, dropping } = dragging;\n    const isCombining = Boolean(combineWith);\n    const shouldAnimate = getShouldDraggingAnimate(dragging);\n    const isDropAnimating = Boolean(dropping);\n    const transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n    const style = {\n        position: \"fixed\",\n        top: box.marginBox.top,\n        left: box.marginBox.left,\n        boxSizing: \"border-box\",\n        width: box.borderBox.width,\n        height: box.borderBox.height,\n        transition: getDraggingTransition(shouldAnimate, dropping),\n        transform,\n        opacity: getDraggingOpacity(isCombining, isDropAnimating),\n        zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n        pointerEvents: \"none\"\n    };\n    return style;\n}\nfunction getSecondaryStyle(secondary) {\n    return {\n        transform: transforms.moveTo(secondary.offset),\n        transition: secondary.shouldAnimateDisplacement ? undefined : \"none\"\n    };\n}\nfunction getStyle$1(mapped) {\n    return mapped.type === \"DRAGGING\" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\nfunction getDimension$1(descriptor, el, windowScroll) {\n    if (windowScroll === void 0) {\n        windowScroll = origin;\n    }\n    const computedStyles = window.getComputedStyle(el);\n    const borderBox = el.getBoundingClientRect();\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.calculateBox)(borderBox, computedStyles);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.withScroll)(client, windowScroll);\n    const placeholder = {\n        client,\n        tagName: el.tagName.toLowerCase(),\n        display: computedStyles.display\n    };\n    const displaceBy = {\n        x: client.marginBox.width,\n        y: client.marginBox.height\n    };\n    const dimension = {\n        descriptor,\n        placeholder,\n        displaceBy,\n        client,\n        page\n    };\n    return dimension;\n}\nfunction useDraggablePublisher(args) {\n    const uniqueId = useUniqueId$1(\"draggable\");\n    const { descriptor, registry, getDraggableRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled } = args;\n    const options = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        }), [\n        canDragInteractiveElements,\n        isEnabled,\n        shouldRespectForcePress\n    ]);\n    const getDimension = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((windowScroll)=>{\n        const el = getDraggableRef();\n        !el ?  true ? invariant(false, \"Cannot get dimension when no ref is set\") : 0 : void 0;\n        return getDimension$1(descriptor, el, windowScroll);\n    }, [\n        descriptor,\n        getDraggableRef\n    ]);\n    const entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            uniqueId,\n            descriptor,\n            options,\n            getDimension\n        }), [\n        descriptor,\n        getDimension,\n        options,\n        uniqueId\n    ]);\n    const publishedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(entry);\n    const isFirstPublishRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    useLayoutEffect(()=>{\n        registry.draggable.register(publishedRef.current);\n        return ()=>registry.draggable.unregister(publishedRef.current);\n    }, [\n        registry.draggable\n    ]);\n    useLayoutEffect(()=>{\n        if (isFirstPublishRef.current) {\n            isFirstPublishRef.current = false;\n            return;\n        }\n        const last = publishedRef.current;\n        publishedRef.current = entry;\n        registry.draggable.update(entry, last);\n    }, [\n        entry,\n        registry.draggable\n    ]);\n}\nvar DroppableContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nfunction checkIsValidInnerRef(el) {\n    !(el && isHtmlElement(el)) ?  true ? invariant(false, `\n    provided.innerRef has not been provided with a HTMLElement.\n\n    You can find a guide on using the innerRef callback functions at:\n    https://github.com/hello-pangea/dnd/blob/main/docs/guides/using-inner-ref.md\n  `) : 0 : void 0;\n}\nfunction useValidation$1(props, contextId, getRef) {\n    useDevSetupWarning(()=>{\n        function prefix(id) {\n            return `Draggable[id: ${id}]: `;\n        }\n        const id = props.draggableId;\n        !id ?  true ? invariant(false, \"Draggable requires a draggableId\") : 0 : void 0;\n        !(typeof id === \"string\") ?  true ? invariant(false, `Draggable requires a [string] draggableId.\n      Provided: [type: ${typeof id}] (value: ${id})`) : 0 : void 0;\n        !Number.isInteger(props.index) ?  true ? invariant(false, `${prefix(id)} requires an integer index prop`) : 0 : void 0;\n        if (props.mapped.type === \"DRAGGING\") {\n            return;\n        }\n        checkIsValidInnerRef(getRef());\n        if (props.isEnabled) {\n            !findDragHandle(contextId, id) ?  true ? invariant(false, `${prefix(id)} Unable to find drag handle`) : 0 : void 0;\n        }\n    });\n}\nfunction useClonePropValidation(isClone) {\n    useDev(()=>{\n        const initialRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isClone);\n        useDevSetupWarning(()=>{\n            !(isClone === initialRef.current) ?  true ? invariant(false, \"Draggable isClone prop value changed during component life\") : 0 : void 0;\n        }, [\n            isClone\n        ]);\n    });\n}\nfunction useRequiredContext(Context) {\n    const result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    !result ?  true ? invariant(false, \"Could not find required context\") : 0 : void 0;\n    return result;\n}\nfunction preventHtml5Dnd(event) {\n    event.preventDefault();\n}\nconst Draggable = (props)=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function(el) {\n        if (el === void 0) {\n            el = null;\n        }\n        ref.current = el;\n    }, []);\n    const getRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>ref.current, []);\n    const { contextId, dragHandleUsageInstructionsId, registry } = useRequiredContext(AppContext);\n    const { type, droppableId } = useRequiredContext(DroppableContext);\n    const descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            id: props.draggableId,\n            index: props.index,\n            type,\n            droppableId\n        }), [\n        props.draggableId,\n        props.index,\n        type,\n        droppableId\n    ]);\n    const { children, draggableId, isEnabled, shouldRespectForcePress, canDragInteractiveElements, isClone, mapped, dropAnimationFinished: dropAnimationFinishedAction } = props;\n    useValidation$1(props, contextId, getRef);\n    useClonePropValidation(isClone);\n    if (!isClone) {\n        const forPublisher = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n                descriptor,\n                registry,\n                getDraggableRef: getRef,\n                canDragInteractiveElements,\n                shouldRespectForcePress,\n                isEnabled\n            }), [\n            descriptor,\n            registry,\n            getRef,\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        ]);\n        useDraggablePublisher(forPublisher);\n    }\n    const dragHandleProps = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>isEnabled ? {\n            tabIndex: 0,\n            role: \"button\",\n            \"aria-describedby\": dragHandleUsageInstructionsId,\n            \"data-rfd-drag-handle-draggable-id\": draggableId,\n            \"data-rfd-drag-handle-context-id\": contextId,\n            draggable: false,\n            onDragStart: preventHtml5Dnd\n        } : null, [\n        contextId,\n        dragHandleUsageInstructionsId,\n        draggableId,\n        isEnabled\n    ]);\n    const onMoveEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((event)=>{\n        if (mapped.type !== \"DRAGGING\") {\n            return;\n        }\n        if (!mapped.dropping) {\n            return;\n        }\n        if (event.propertyName !== \"transform\") {\n            return;\n        }\n        if (react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"16\") || react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"17\")) {\n            dropAnimationFinishedAction();\n        } else {\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(dropAnimationFinishedAction);\n        }\n    }, [\n        dropAnimationFinishedAction,\n        mapped\n    ]);\n    const provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>{\n        const style = getStyle$1(mapped);\n        const onTransitionEnd = mapped.type === \"DRAGGING\" && mapped.dropping ? onMoveEnd : undefined;\n        const result = {\n            innerRef: setRef,\n            draggableProps: {\n                \"data-rfd-draggable-context-id\": contextId,\n                \"data-rfd-draggable-id\": draggableId,\n                style,\n                onTransitionEnd\n            },\n            dragHandleProps\n        };\n        return result;\n    }, [\n        contextId,\n        dragHandleProps,\n        draggableId,\n        mapped,\n        onMoveEnd,\n        setRef\n    ]);\n    const rubric = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        }), [\n        descriptor.droppableId,\n        descriptor.id,\n        descriptor.index,\n        descriptor.type\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children(provided, mapped.snapshot, rubric));\n};\nvar Draggable$1 = Draggable;\nvar isStrictEqual = (a, b)=>a === b;\nvar whatIsDraggedOverFromResult = (result)=>{\n    const { combine, destination } = result;\n    if (destination) {\n        return destination.droppableId;\n    }\n    if (combine) {\n        return combine.droppableId;\n    }\n    return null;\n};\nconst getCombineWithFromResult = (result)=>{\n    return result.combine ? result.combine.draggableId : null;\n};\nconst getCombineWithFromImpact = (impact)=>{\n    return impact.at && impact.at.type === \"COMBINE\" ? impact.at.combine.draggableId : null;\n};\nfunction getDraggableSelector() {\n    const memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((x, y)=>({\n            x,\n            y\n        }));\n    const getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(mode, isClone, draggingOver, combineWith, dropping) {\n        if (draggingOver === void 0) {\n            draggingOver = null;\n        }\n        if (combineWith === void 0) {\n            combineWith = null;\n        }\n        if (dropping === void 0) {\n            dropping = null;\n        }\n        return {\n            isDragging: true,\n            isClone,\n            isDropAnimating: Boolean(dropping),\n            dropAnimation: dropping,\n            mode,\n            draggingOver,\n            combineWith,\n            combineTargetFor: null\n        };\n    });\n    const getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(offset, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {\n        if (draggingOver === void 0) {\n            draggingOver = null;\n        }\n        if (combineWith === void 0) {\n            combineWith = null;\n        }\n        if (forceShouldAnimate === void 0) {\n            forceShouldAnimate = null;\n        }\n        return {\n            mapped: {\n                type: \"DRAGGING\",\n                dropping: null,\n                draggingOver,\n                combineWith,\n                mode,\n                offset,\n                dimension,\n                forceShouldAnimate,\n                snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n            }\n        };\n    });\n    const selector = (state, ownProps)=>{\n        if (isDragging(state)) {\n            if (state.critical.draggable.id !== ownProps.draggableId) {\n                return null;\n            }\n            const offset = state.current.client.offset;\n            const dimension = state.dimensions.draggables[ownProps.draggableId];\n            const draggingOver = whatIsDraggedOver(state.impact);\n            const combineWith = getCombineWithFromImpact(state.impact);\n            const forceShouldAnimate = state.forceShouldAnimate;\n            return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (completed.result.draggableId !== ownProps.draggableId) {\n                return null;\n            }\n            const isClone = ownProps.isClone;\n            const dimension = state.dimensions.draggables[ownProps.draggableId];\n            const result = completed.result;\n            const mode = result.mode;\n            const draggingOver = whatIsDraggedOverFromResult(result);\n            const combineWith = getCombineWithFromResult(result);\n            const duration = state.dropDuration;\n            const dropping = {\n                duration,\n                curve: curves.drop,\n                moveTo: state.newHomeClientOffset,\n                opacity: combineWith ? combine.opacity.drop : null,\n                scale: combineWith ? combine.scale.drop : null\n            };\n            return {\n                mapped: {\n                    type: \"DRAGGING\",\n                    offset: state.newHomeClientOffset,\n                    dimension,\n                    dropping,\n                    draggingOver,\n                    combineWith,\n                    mode,\n                    forceShouldAnimate: null,\n                    snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, dropping)\n                }\n            };\n        }\n        return null;\n    };\n    return selector;\n}\nfunction getSecondarySnapshot(combineTargetFor) {\n    if (combineTargetFor === void 0) {\n        combineTargetFor = null;\n    }\n    return {\n        isDragging: false,\n        isDropAnimating: false,\n        isClone: false,\n        dropAnimation: null,\n        mode: null,\n        draggingOver: null,\n        combineTargetFor,\n        combineWith: null\n    };\n}\nconst atRest = {\n    mapped: {\n        type: \"SECONDARY\",\n        offset: origin,\n        combineTargetFor: null,\n        shouldAnimateDisplacement: true,\n        snapshot: getSecondarySnapshot(null)\n    }\n};\nfunction getSecondarySelector() {\n    const memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((x, y)=>({\n            x,\n            y\n        }));\n    const getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(getSecondarySnapshot);\n    const getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(offset, combineTargetFor, shouldAnimateDisplacement) {\n        if (combineTargetFor === void 0) {\n            combineTargetFor = null;\n        }\n        return {\n            mapped: {\n                type: \"SECONDARY\",\n                offset,\n                combineTargetFor,\n                shouldAnimateDisplacement,\n                snapshot: getMemoizedSnapshot(combineTargetFor)\n            }\n        };\n    });\n    const getFallback = (combineTargetFor)=>{\n        return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n    };\n    const getProps = (ownId, draggingId, impact, afterCritical)=>{\n        const visualDisplacement = impact.displaced.visible[ownId];\n        const isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n        const combine = tryGetCombine(impact);\n        const combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n        if (!visualDisplacement) {\n            if (!isAfterCriticalInVirtualList) {\n                return getFallback(combineTargetFor);\n            }\n            if (impact.displaced.invisible[ownId]) {\n                return null;\n            }\n            const change = negate(afterCritical.displacedBy.point);\n            const offset = memoizedOffset(change.x, change.y);\n            return getMemoizedProps(offset, combineTargetFor, true);\n        }\n        if (isAfterCriticalInVirtualList) {\n            return getFallback(combineTargetFor);\n        }\n        const displaceBy = impact.displacedBy.point;\n        const offset = memoizedOffset(displaceBy.x, displaceBy.y);\n        return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n    };\n    const selector = (state, ownProps)=>{\n        if (isDragging(state)) {\n            if (state.critical.draggable.id === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (completed.result.draggableId === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n        }\n        return null;\n    };\n    return selector;\n}\nconst makeMapStateToProps$1 = ()=>{\n    const draggingSelector = getDraggableSelector();\n    const secondarySelector = getSecondarySelector();\n    const selector = (state, ownProps)=>draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n    return selector;\n};\nconst mapDispatchToProps$1 = {\n    dropAnimationFinished: dropAnimationFinished\n};\nconst ConnectedDraggable = (0,react_redux__WEBPACK_IMPORTED_MODULE_2__.connect)(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n    context: StoreContext,\n    areStatePropsEqual: isStrictEqual\n})(Draggable$1);\nvar ConnectedDraggable$1 = ConnectedDraggable;\nfunction PrivateDraggable(props) {\n    const droppableContext = useRequiredContext(DroppableContext);\n    const isUsingCloneFor = droppableContext.isUsingCloneFor;\n    if (isUsingCloneFor === props.draggableId && !props.isClone) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ConnectedDraggable$1, props);\n}\nfunction PublicDraggable(props) {\n    const isEnabled = typeof props.isDragDisabled === \"boolean\" ? !props.isDragDisabled : true;\n    const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n    const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({}, props, {\n        isClone: false,\n        isEnabled: isEnabled,\n        canDragInteractiveElements: canDragInteractiveElements,\n        shouldRespectForcePress: shouldRespectForcePress\n    }));\n}\nconst isEqual = (base)=>(value)=>base === value;\nconst isScroll = isEqual(\"scroll\");\nconst isAuto = isEqual(\"auto\");\nconst isVisible = isEqual(\"visible\");\nconst isEither = (overflow, fn)=>fn(overflow.overflowX) || fn(overflow.overflowY);\nconst isBoth = (overflow, fn)=>fn(overflow.overflowX) && fn(overflow.overflowY);\nconst isElementScrollable = (el)=>{\n    const style = window.getComputedStyle(el);\n    const overflow = {\n        overflowX: style.overflowX,\n        overflowY: style.overflowY\n    };\n    return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\nconst isBodyScrollable = ()=>{\n    if (false) {}\n    const body = getBodyElement();\n    const html = document.documentElement;\n    !html ?  true ? invariant(false) : 0 : void 0;\n    if (!isElementScrollable(body)) {\n        return false;\n    }\n    const htmlStyle = window.getComputedStyle(html);\n    const htmlOverflow = {\n        overflowX: htmlStyle.overflowX,\n        overflowY: htmlStyle.overflowY\n    };\n    if (isBoth(htmlOverflow, isVisible)) {\n        return false;\n    }\n     true ? warning(`\n    We have detected that your <body> element might be a scroll container.\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\n\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\n    we will be treating the <body> as *not* a scroll container\n\n    More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/how-we-detect-scroll-containers.md\n  `) : 0;\n    return false;\n};\nconst getClosestScrollable = (el)=>{\n    if (el == null) {\n        return null;\n    }\n    if (el === document.body) {\n        return isBodyScrollable() ? el : null;\n    }\n    if (el === document.documentElement) {\n        return null;\n    }\n    if (!isElementScrollable(el)) {\n        return getClosestScrollable(el.parentElement);\n    }\n    return el;\n};\nvar getClosestScrollable$1 = getClosestScrollable;\nvar checkForNestedScrollContainers = (scrollable)=>{\n    if (!scrollable) {\n        return;\n    }\n    const anotherScrollParent = getClosestScrollable$1(scrollable.parentElement);\n    if (!anotherScrollParent) {\n        return;\n    }\n     true ? warning(`\n    Droppable: unsupported nested scroll container detected.\n    A Droppable can only have one scroll parent (which can be itself)\n    Nested scroll containers are currently not supported.\n\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\n  `) : 0;\n};\nvar getScroll = (el)=>({\n        x: el.scrollLeft,\n        y: el.scrollTop\n    });\nconst getIsFixed = (el)=>{\n    if (!el) {\n        return false;\n    }\n    const style = window.getComputedStyle(el);\n    if (style.position === \"fixed\") {\n        return true;\n    }\n    return getIsFixed(el.parentElement);\n};\nvar getEnv = (start)=>{\n    const closestScrollable = getClosestScrollable$1(start);\n    const isFixedOnPage = getIsFixed(start);\n    return {\n        closestScrollable,\n        isFixedOnPage\n    };\n};\nvar getDroppableDimension = (_ref)=>{\n    let { descriptor, isEnabled, isCombineEnabled, isFixedOnPage, direction, client, page, closest } = _ref;\n    const frame = (()=>{\n        if (!closest) {\n            return null;\n        }\n        const { scrollSize, client: frameClient } = closest;\n        const maxScroll = getMaxScroll({\n            scrollHeight: scrollSize.scrollHeight,\n            scrollWidth: scrollSize.scrollWidth,\n            height: frameClient.paddingBox.height,\n            width: frameClient.paddingBox.width\n        });\n        return {\n            pageMarginBox: closest.page.marginBox,\n            frameClient,\n            scrollSize,\n            shouldClipSubject: closest.shouldClipSubject,\n            scroll: {\n                initial: closest.scroll,\n                current: closest.scroll,\n                max: maxScroll,\n                diff: {\n                    value: origin,\n                    displacement: origin\n                }\n            }\n        };\n    })();\n    const axis = direction === \"vertical\" ? vertical : horizontal;\n    const subject = getSubject({\n        page,\n        withPlaceholder: null,\n        axis,\n        frame\n    });\n    const dimension = {\n        descriptor,\n        isCombineEnabled,\n        isFixedOnPage,\n        axis,\n        isEnabled,\n        client,\n        page,\n        frame,\n        subject\n    };\n    return dimension;\n};\nconst getClient = (targetRef, closestScrollable)=>{\n    const base = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getBox)(targetRef);\n    if (!closestScrollable) {\n        return base;\n    }\n    if (targetRef !== closestScrollable) {\n        return base;\n    }\n    const top = base.paddingBox.top - closestScrollable.scrollTop;\n    const left = base.paddingBox.left - closestScrollable.scrollLeft;\n    const bottom = top + closestScrollable.scrollHeight;\n    const right = left + closestScrollable.scrollWidth;\n    const paddingBox = {\n        top,\n        right,\n        bottom,\n        left\n    };\n    const borderBox = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.expand)(paddingBox, base.border);\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.createBox)({\n        borderBox,\n        margin: base.margin,\n        border: base.border,\n        padding: base.padding\n    });\n    return client;\n};\nvar getDimension = (_ref)=>{\n    let { ref, descriptor, env, windowScroll, direction, isDropDisabled, isCombineEnabled, shouldClipSubject } = _ref;\n    const closestScrollable = env.closestScrollable;\n    const client = getClient(ref, closestScrollable);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.withScroll)(client, windowScroll);\n    const closest = (()=>{\n        if (!closestScrollable) {\n            return null;\n        }\n        const frameClient = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getBox)(closestScrollable);\n        const scrollSize = {\n            scrollHeight: closestScrollable.scrollHeight,\n            scrollWidth: closestScrollable.scrollWidth\n        };\n        return {\n            client: frameClient,\n            page: (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.withScroll)(frameClient, windowScroll),\n            scroll: getScroll(closestScrollable),\n            scrollSize,\n            shouldClipSubject\n        };\n    })();\n    const dimension = getDroppableDimension({\n        descriptor,\n        isEnabled: !isDropDisabled,\n        isCombineEnabled,\n        isFixedOnPage: env.isFixedOnPage,\n        direction,\n        client,\n        page,\n        closest\n    });\n    return dimension;\n};\nconst immediate = {\n    passive: false\n};\nconst delayed = {\n    passive: true\n};\nvar getListenerOptions = (options)=>options.shouldPublishImmediately ? immediate : delayed;\nconst getClosestScrollableFromDrag = (dragging)=>dragging && dragging.env.closestScrollable || null;\nfunction useDroppablePublisher(args) {\n    const whileDraggingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const appContext = useRequiredContext(AppContext);\n    const uniqueId = useUniqueId$1(\"droppable\");\n    const { registry, marshal } = appContext;\n    const previousRef = usePrevious(args);\n    const descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            id: args.droppableId,\n            type: args.type,\n            mode: args.mode\n        }), [\n        args.droppableId,\n        args.mode,\n        args.type\n    ]);\n    const publishedDescriptorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(descriptor);\n    const memoizedUpdateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>(0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((x, y)=>{\n            !whileDraggingRef.current ?  true ? invariant(false, \"Can only update scroll when dragging\") : 0 : void 0;\n            const scroll = {\n                x,\n                y\n            };\n            marshal.updateDroppableScroll(descriptor.id, scroll);\n        }), [\n        descriptor.id,\n        marshal\n    ]);\n    const getClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        if (!dragging || !dragging.env.closestScrollable) {\n            return origin;\n        }\n        return getScroll(dragging.env.closestScrollable);\n    }, []);\n    const updateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const scroll = getClosestScroll();\n        memoizedUpdateScroll(scroll.x, scroll.y);\n    }, [\n        getClosestScroll,\n        memoizedUpdateScroll\n    ]);\n    const scheduleScrollUpdate = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>(0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(updateScroll), [\n        updateScroll\n    ]);\n    const onClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Could not find scroll options while scrolling\") : 0 : void 0;\n        const options = dragging.scrollOptions;\n        if (options.shouldPublishImmediately) {\n            updateScroll();\n            return;\n        }\n        scheduleScrollUpdate();\n    }, [\n        scheduleScrollUpdate,\n        updateScroll\n    ]);\n    const getDimensionAndWatchScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((windowScroll, options)=>{\n        !!whileDraggingRef.current ?  true ? invariant(false, \"Cannot collect a droppable while a drag is occurring\") : 0 : void 0;\n        const previous = previousRef.current;\n        const ref = previous.getDroppableRef();\n        !ref ?  true ? invariant(false, \"Cannot collect without a droppable ref\") : 0 : void 0;\n        const env = getEnv(ref);\n        const dragging = {\n            ref,\n            descriptor,\n            env,\n            scrollOptions: options\n        };\n        whileDraggingRef.current = dragging;\n        const dimension = getDimension({\n            ref,\n            descriptor,\n            env,\n            windowScroll,\n            direction: previous.direction,\n            isDropDisabled: previous.isDropDisabled,\n            isCombineEnabled: previous.isCombineEnabled,\n            shouldClipSubject: !previous.ignoreContainerClipping\n        });\n        const scrollable = env.closestScrollable;\n        if (scrollable) {\n            scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n            scrollable.addEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n            if (true) {\n                checkForNestedScrollContainers(scrollable);\n            }\n        }\n        return dimension;\n    }, [\n        appContext.contextId,\n        descriptor,\n        onClosestScroll,\n        previousRef\n    ]);\n    const getScrollWhileDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Can only recollect Droppable client for Droppables that have a scroll container\") : 0 : void 0;\n        return getScroll(closest);\n    }, []);\n    const dragStopped = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot stop drag when no active drag\") : 0 : void 0;\n        const closest = getClosestScrollableFromDrag(dragging);\n        whileDraggingRef.current = null;\n        if (!closest) {\n            return;\n        }\n        scheduleScrollUpdate.cancel();\n        closest.removeAttribute(scrollContainer.contextId);\n        closest.removeEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n    }, [\n        onClosestScroll,\n        scheduleScrollUpdate\n    ]);\n    const scroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((change)=>{\n        const dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot scroll when there is no drag\") : 0 : void 0;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !closest ?  true ? invariant(false, \"Cannot scroll a droppable with no closest scrollable\") : 0 : void 0;\n        closest.scrollTop += change.y;\n        closest.scrollLeft += change.x;\n    }, []);\n    const callbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>{\n        return {\n            getDimensionAndWatchScroll,\n            getScrollWhileDragging,\n            dragStopped,\n            scroll\n        };\n    }, [\n        dragStopped,\n        getDimensionAndWatchScroll,\n        getScrollWhileDragging,\n        scroll\n    ]);\n    const entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            uniqueId,\n            descriptor,\n            callbacks\n        }), [\n        callbacks,\n        descriptor,\n        uniqueId\n    ]);\n    useLayoutEffect(()=>{\n        publishedDescriptorRef.current = entry.descriptor;\n        registry.droppable.register(entry);\n        return ()=>{\n            if (whileDraggingRef.current) {\n                 true ? warning(\"Unsupported: changing the droppableId or type of a Droppable during a drag\") : 0;\n                dragStopped();\n            }\n            registry.droppable.unregister(entry);\n        };\n    }, [\n        callbacks,\n        descriptor,\n        dragStopped,\n        entry,\n        marshal,\n        registry.droppable\n    ]);\n    useLayoutEffect(()=>{\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n    }, [\n        args.isDropDisabled,\n        marshal\n    ]);\n    useLayoutEffect(()=>{\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n    }, [\n        args.isCombineEnabled,\n        marshal\n    ]);\n}\nfunction noop() {}\nconst empty = {\n    width: 0,\n    height: 0,\n    margin: noSpacing\n};\nconst getSize = (_ref)=>{\n    let { isAnimatingOpenOnMount, placeholder, animate } = _ref;\n    if (isAnimatingOpenOnMount) {\n        return empty;\n    }\n    if (animate === \"close\") {\n        return empty;\n    }\n    return {\n        height: placeholder.client.borderBox.height,\n        width: placeholder.client.borderBox.width,\n        margin: placeholder.client.margin\n    };\n};\nconst getStyle = (_ref2)=>{\n    let { isAnimatingOpenOnMount, placeholder, animate } = _ref2;\n    const size = getSize({\n        isAnimatingOpenOnMount,\n        placeholder,\n        animate\n    });\n    return {\n        display: placeholder.display,\n        boxSizing: \"border-box\",\n        width: size.width,\n        height: size.height,\n        marginTop: size.margin.top,\n        marginRight: size.margin.right,\n        marginBottom: size.margin.bottom,\n        marginLeft: size.margin.left,\n        flexShrink: \"0\",\n        flexGrow: \"0\",\n        pointerEvents: \"none\",\n        transition: animate !== \"none\" ? transitions.placeholder : null\n    };\n};\nconst Placeholder = (props)=>{\n    const animateOpenTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const tryClearAnimateOpenTimer = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        if (!animateOpenTimerRef.current) {\n            return;\n        }\n        clearTimeout(animateOpenTimerRef.current);\n        animateOpenTimerRef.current = null;\n    }, []);\n    const { animate, onTransitionEnd, onClose, contextId } = props;\n    const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.animate === \"open\");\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isAnimatingOpenOnMount) {\n            return noop;\n        }\n        if (animate !== \"open\") {\n            tryClearAnimateOpenTimer();\n            setIsAnimatingOpenOnMount(false);\n            return noop;\n        }\n        if (animateOpenTimerRef.current) {\n            return noop;\n        }\n        animateOpenTimerRef.current = setTimeout(()=>{\n            animateOpenTimerRef.current = null;\n            setIsAnimatingOpenOnMount(false);\n        });\n        return tryClearAnimateOpenTimer;\n    }, [\n        animate,\n        isAnimatingOpenOnMount,\n        tryClearAnimateOpenTimer\n    ]);\n    const onSizeChangeEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((event)=>{\n        if (event.propertyName !== \"height\") {\n            return;\n        }\n        onTransitionEnd();\n        if (animate === \"close\") {\n            onClose();\n        }\n    }, [\n        animate,\n        onClose,\n        onTransitionEnd\n    ]);\n    const style = getStyle({\n        isAnimatingOpenOnMount,\n        animate: props.animate,\n        placeholder: props.placeholder\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(props.placeholder.tagName, {\n        style,\n        \"data-rfd-placeholder-context-id\": contextId,\n        onTransitionEnd: onSizeChangeEnd,\n        ref: props.innerRef\n    });\n};\nvar Placeholder$1 = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().memo(Placeholder);\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\nfunction runChecks(args, checks) {\n    checks.forEach((check)=>check(args));\n}\nconst shared = [\n    function required(_ref) {\n        let { props } = _ref;\n        !props.droppableId ?  true ? invariant(false, \"A Droppable requires a droppableId prop\") : 0 : void 0;\n        !(typeof props.droppableId === \"string\") ?  true ? invariant(false, `A Droppable requires a [string] droppableId. Provided: [${typeof props.droppableId}]`) : 0 : void 0;\n    },\n    function boolean(_ref2) {\n        let { props } = _ref2;\n        !isBoolean(props.isDropDisabled) ?  true ? invariant(false, \"isDropDisabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.isCombineEnabled) ?  true ? invariant(false, \"isCombineEnabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.ignoreContainerClipping) ?  true ? invariant(false, \"ignoreContainerClipping must be a boolean\") : 0 : void 0;\n    },\n    function ref(_ref3) {\n        let { getDroppableRef } = _ref3;\n        checkIsValidInnerRef(getDroppableRef());\n    }\n];\nconst standard = [\n    function placeholder(_ref4) {\n        let { props, getPlaceholderRef } = _ref4;\n        if (!props.placeholder) {\n            return;\n        }\n        const ref = getPlaceholderRef();\n        if (ref) {\n            return;\n        }\n         true ? warning(`\n      Droppable setup issue [droppableId: \"${props.droppableId}\"]:\n      DroppableProvided > placeholder could not be found.\n\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\n      More information: https://github.com/hello-pangea/dnd/blob/main/docs/api/droppable.md\n    `) : 0;\n    }\n];\nconst virtual = [\n    function hasClone(_ref5) {\n        let { props } = _ref5;\n        !props.renderClone ?  true ? invariant(false, \"Must provide a clone render function (renderClone) for virtual lists\") : 0 : void 0;\n    },\n    function hasNoPlaceholder(_ref6) {\n        let { getPlaceholderRef } = _ref6;\n        !!getPlaceholderRef() ?  true ? invariant(false, \"Expected virtual list to not have a placeholder\") : 0 : void 0;\n    }\n];\nfunction useValidation(args) {\n    useDevSetupWarning(()=>{\n        runChecks(args, shared);\n        if (args.props.mode === \"standard\") {\n            runChecks(args, standard);\n        }\n        if (args.props.mode === \"virtual\") {\n            runChecks(args, virtual);\n        }\n    });\n}\nclass AnimateInOut extends (react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent) {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            isVisible: Boolean(this.props.on),\n            data: this.props.on,\n            animate: this.props.shouldAnimate && this.props.on ? \"open\" : \"none\"\n        };\n        this.onClose = ()=>{\n            if (this.state.animate !== \"close\") {\n                return;\n            }\n            this.setState({\n                isVisible: false\n            });\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        if (!props.shouldAnimate) {\n            return {\n                isVisible: Boolean(props.on),\n                data: props.on,\n                animate: \"none\"\n            };\n        }\n        if (props.on) {\n            return {\n                isVisible: true,\n                data: props.on,\n                animate: \"open\"\n            };\n        }\n        if (state.isVisible) {\n            return {\n                isVisible: true,\n                data: state.data,\n                animate: \"close\"\n            };\n        }\n        return {\n            isVisible: false,\n            animate: \"close\",\n            data: null\n        };\n    }\n    render() {\n        if (!this.state.isVisible) {\n            return null;\n        }\n        const provided = {\n            onClose: this.onClose,\n            data: this.state.data,\n            animate: this.state.animate\n        };\n        return this.props.children(provided);\n    }\n}\nconst Droppable = (props)=>{\n    const appContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AppContext);\n    !appContext ?  true ? invariant(false, \"Could not find app context\") : 0 : void 0;\n    const { contextId, isMovementAllowed } = appContext;\n    const droppableRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { children, droppableId, type, mode, direction, ignoreContainerClipping, isDropDisabled, isCombineEnabled, snapshot, useClone, updateViewportMaxScroll, getContainerForClone } = props;\n    const getDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>droppableRef.current, []);\n    const setDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function(value) {\n        if (value === void 0) {\n            value = null;\n        }\n        droppableRef.current = value;\n    }, []);\n    const getPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>placeholderRef.current, []);\n    const setPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function(value) {\n        if (value === void 0) {\n            value = null;\n        }\n        placeholderRef.current = value;\n    }, []);\n    useValidation({\n        props,\n        getDroppableRef,\n        getPlaceholderRef\n    });\n    const onPlaceholderTransitionEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        if (isMovementAllowed()) {\n            updateViewportMaxScroll({\n                maxScroll: getMaxWindowScroll()\n            });\n        }\n    }, [\n        isMovementAllowed,\n        updateViewportMaxScroll\n    ]);\n    useDroppablePublisher({\n        droppableId,\n        type,\n        mode,\n        direction,\n        isDropDisabled,\n        isCombineEnabled,\n        ignoreContainerClipping,\n        getDroppableRef\n    });\n    const placeholder = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimateInOut, {\n            on: props.placeholder,\n            shouldAnimate: props.shouldAnimatePlaceholder\n        }, (_ref)=>{\n            let { onClose, data, animate } = _ref;\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Placeholder$1, {\n                placeholder: data,\n                onClose: onClose,\n                innerRef: setPlaceholderRef,\n                animate: animate,\n                contextId: contextId,\n                onTransitionEnd: onPlaceholderTransitionEnd\n            });\n        }), [\n        contextId,\n        onPlaceholderTransitionEnd,\n        props.placeholder,\n        props.shouldAnimatePlaceholder,\n        setPlaceholderRef\n    ]);\n    const provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            innerRef: setDroppableRef,\n            placeholder,\n            droppableProps: {\n                \"data-rfd-droppable-id\": droppableId,\n                \"data-rfd-droppable-context-id\": contextId\n            }\n        }), [\n        contextId,\n        droppableId,\n        placeholder,\n        setDroppableRef\n    ]);\n    const isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n    const droppableContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            droppableId,\n            type,\n            isUsingCloneFor\n        }), [\n        droppableId,\n        isUsingCloneFor,\n        type\n    ]);\n    function getClone() {\n        if (!useClone) {\n            return null;\n        }\n        const { dragging, render } = useClone;\n        const node = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, {\n            draggableId: dragging.draggableId,\n            index: dragging.source.index,\n            isClone: true,\n            isEnabled: true,\n            shouldRespectForcePress: false,\n            canDragInteractiveElements: true\n        }, (draggableProvided, draggableSnapshot)=>render(draggableProvided, draggableSnapshot, dragging));\n        return /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_1___default().createPortal(node, getContainerForClone());\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DroppableContext.Provider, {\n        value: droppableContext\n    }, children(provided, snapshot), getClone());\n};\nvar Droppable$1 = Droppable;\nfunction getBody() {\n    !document.body ?  true ? invariant(false, \"document.body is not ready\") : 0 : void 0;\n    return document.body;\n}\nconst defaultProps = {\n    mode: \"standard\",\n    type: \"DEFAULT\",\n    direction: \"vertical\",\n    isDropDisabled: false,\n    isCombineEnabled: false,\n    ignoreContainerClipping: false,\n    renderClone: null,\n    getContainerForClone: getBody\n};\nconst attachDefaultPropsToOwnProps = (ownProps)=>{\n    let mergedProps = {\n        ...ownProps\n    };\n    let defaultPropKey;\n    for(defaultPropKey in defaultProps){\n        if (ownProps[defaultPropKey] === undefined) {\n            mergedProps = {\n                ...mergedProps,\n                [defaultPropKey]: defaultProps[defaultPropKey]\n            };\n        }\n    }\n    return mergedProps;\n};\nconst isMatchingType = (type, critical)=>type === critical.droppable.type;\nconst getDraggable = (critical, dimensions)=>dimensions.draggables[critical.draggable.id];\nconst makeMapStateToProps = ()=>{\n    const idleWithAnimation = {\n        placeholder: null,\n        shouldAnimatePlaceholder: true,\n        snapshot: {\n            isDraggingOver: false,\n            draggingOverWith: null,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: false\n        },\n        useClone: null\n    };\n    const idleWithoutAnimation = {\n        ...idleWithAnimation,\n        shouldAnimatePlaceholder: false\n    };\n    const getDraggableRubric = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((descriptor)=>({\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        }));\n    const getMapProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone)=>{\n        const draggableId = dragging.descriptor.id;\n        const isHome = dragging.descriptor.droppableId === id;\n        if (isHome) {\n            const useClone = renderClone ? {\n                render: renderClone,\n                dragging: getDraggableRubric(dragging.descriptor)\n            } : null;\n            const snapshot = {\n                isDraggingOver: isDraggingOverForConsumer,\n                draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n                draggingFromThisWith: draggableId,\n                isUsingPlaceholder: true\n            };\n            return {\n                placeholder: dragging.placeholder,\n                shouldAnimatePlaceholder: false,\n                snapshot,\n                useClone\n            };\n        }\n        if (!isEnabled) {\n            return idleWithoutAnimation;\n        }\n        if (!isDraggingOverForImpact) {\n            return idleWithAnimation;\n        }\n        const snapshot = {\n            isDraggingOver: isDraggingOverForConsumer,\n            draggingOverWith: draggableId,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: true\n        };\n        return {\n            placeholder: dragging.placeholder,\n            shouldAnimatePlaceholder: true,\n            snapshot,\n            useClone: null\n        };\n    });\n    const selector = (state, ownProps)=>{\n        const ownPropsWithDefaultProps = attachDefaultPropsToOwnProps(ownProps);\n        const id = ownPropsWithDefaultProps.droppableId;\n        const type = ownPropsWithDefaultProps.type;\n        const isEnabled = !ownPropsWithDefaultProps.isDropDisabled;\n        const renderClone = ownPropsWithDefaultProps.renderClone;\n        if (isDragging(state)) {\n            const critical = state.critical;\n            if (!isMatchingType(type, critical)) {\n                return idleWithoutAnimation;\n            }\n            const dragging = getDraggable(critical, state.dimensions);\n            const isDraggingOver = whatIsDraggedOver(state.impact) === id;\n            return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            const dragging = getDraggable(completed.critical, state.dimensions);\n            return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, dragging, renderClone);\n        }\n        if (state.phase === \"IDLE\" && state.completed && !state.shouldFlush) {\n            const completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            const wasOver = whatIsDraggedOver(completed.impact) === id;\n            const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === \"COMBINE\");\n            const isHome = completed.critical.droppable.id === id;\n            if (wasOver) {\n                return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n            }\n            if (isHome) {\n                return idleWithAnimation;\n            }\n            return idleWithoutAnimation;\n        }\n        return idleWithoutAnimation;\n    };\n    return selector;\n};\nconst mapDispatchToProps = {\n    updateViewportMaxScroll: updateViewportMaxScroll\n};\nconst ConnectedDroppable = (0,react_redux__WEBPACK_IMPORTED_MODULE_2__.connect)(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps)=>{\n    return {\n        ...attachDefaultPropsToOwnProps(ownProps),\n        ...stateProps,\n        ...dispatchProps\n    };\n}, {\n    context: StoreContext,\n    areStatePropsEqual: isStrictEqual\n})(Droppable$1);\nvar ConnectedDroppable$1 = ConnectedDroppable;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlbGxvLXBhbmdlYS9kbmQvZGlzdC9kbmQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RztBQUM3RDtBQUNtRDtBQUNuRDtBQUNJO0FBQ2lEO0FBQ2hFO0FBQ047QUFDMkI7QUFFMUQsTUFBTTRCLGlCQUFpQkMsa0JBQXlCO0FBQ2hELE1BQU1DLGdCQUFnQjtBQUN0QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMsVUFBVUMsQ0FBQUEsUUFBU0EsTUFBTUMsT0FBTyxDQUFDSixlQUFlLEtBQUtJLE9BQU8sQ0FBQ0gscUJBQXFCLElBQUlJLElBQUk7QUFDaEcsTUFBTUMsZ0JBQWdCQyxDQUFBQSxVQUFXTCxRQUFRLENBQUM7OztJQUd0QyxFQUFFQSxRQUFRSyxTQUFTOzs7QUFHdkIsQ0FBQztBQUNELE1BQU1DLHNCQUFzQkQsQ0FBQUEsVUFBVztRQUFDRCxjQUFjQztRQUFVO1FBQXdEO1FBQW9CO0tBQWtCO0FBQzlKLE1BQU1FLGlCQUFpQjtBQUN2QixTQUFTQyxJQUFJQyxJQUFJLEVBQUVKLE9BQU87SUFDeEIsSUFBSVQsZ0JBQWdCO1FBQ2xCO0lBQ0Y7SUFDQSxJQUFJLEtBQXVELEVBQUUsRUFFNUQ7SUFDRGUsT0FBTyxDQUFDRixLQUFLLElBQUlILG9CQUFvQkQ7QUFDdkM7QUFDQSxNQUFNTyxVQUFVSixJQUFJSyxJQUFJLENBQUMsTUFBTTtBQUMvQixNQUFNQyxRQUFRTixJQUFJSyxJQUFJLENBQUMsTUFBTTtBQUU3QixTQUFTRSxVQUFVO0FBRW5CLFNBQVNDLFdBQVdDLE1BQU0sRUFBRUMsV0FBVztJQUNyQyxPQUFPO1FBQ0wsR0FBR0QsTUFBTTtRQUNULEdBQUdDLFdBQVc7SUFDaEI7QUFDRjtBQUNBLFNBQVNDLFdBQVdDLEVBQUUsRUFBRUMsUUFBUSxFQUFFQyxhQUFhO0lBQzdDLE1BQU1DLGFBQWFGLFNBQVNHLEdBQUcsQ0FBQ0MsQ0FBQUE7UUFDOUIsTUFBTUMsVUFBVVYsV0FBV00sZUFBZUcsUUFBUUMsT0FBTztRQUN6RE4sR0FBR08sZ0JBQWdCLENBQUNGLFFBQVFHLFNBQVMsRUFBRUgsUUFBUUksRUFBRSxFQUFFSDtRQUNuRCxPQUFPLFNBQVNJO1lBQ2RWLEdBQUdXLG1CQUFtQixDQUFDTixRQUFRRyxTQUFTLEVBQUVILFFBQVFJLEVBQUUsRUFBRUg7UUFDeEQ7SUFDRjtJQUNBLE9BQU8sU0FBU007UUFDZFQsV0FBV1UsT0FBTyxDQUFDSCxDQUFBQTtZQUNqQkE7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxNQUFNSSxlQUFlckMsa0JBQXlCO0FBQzlDLE1BQU1zQyxXQUFXO0FBQ2pCLE1BQU1DLHFCQUFxQkM7QUFBTztBQUNsQ0QsYUFBYUUsU0FBUyxDQUFDQyxRQUFRLEdBQUcsU0FBU0E7SUFDekMsT0FBTyxJQUFJLENBQUNsQyxPQUFPO0FBQ3JCO0FBQ0EsU0FBU21DLFVBQVVDLFNBQVMsRUFBRXBDLE9BQU87SUFDbkMsSUFBSW9DLFdBQVc7UUFDYjtJQUNGO0lBQ0EsSUFBSVAsY0FBYztRQUNoQixNQUFNLElBQUlFLGFBQWFEO0lBQ3pCLE9BQU87UUFDTCxNQUFNLElBQUlDLGFBQWEsQ0FBQyxFQUFFRCxTQUFTLEVBQUUsRUFBRTlCLFdBQVcsR0FBRyxDQUFDO0lBQ3hEO0FBQ0Y7QUFFQSxNQUFNcUMsc0JBQXNCMUUsd0RBQWU7SUFDekM0RSxhQUFjO1FBQ1osS0FBSyxJQUFJQztRQUNULElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ2hCLE1BQU0sR0FBR2Y7UUFDZCxJQUFJLENBQUNnQyxhQUFhLEdBQUdDLENBQUFBO1lBQ25CLE1BQU1GLFlBQVksSUFBSSxDQUFDRyxZQUFZO1lBQ25DLElBQUlILFVBQVVJLFVBQVUsSUFBSTtnQkFDMUJKLFVBQVVLLFFBQVE7Z0JBbkYxQixLQW9GNkMsR0FBR3ZDLFFBQVEsQ0FBQzs7O01BR25ELENBQUMsSUFBSSxDQUFNO1lBQ1g7WUFDQSxNQUFNd0MsTUFBTUosTUFBTWxDLEtBQUs7WUFDdkIsSUFBSXNDLGVBQWVoQixjQUFjO2dCQUMvQlksTUFBTUssY0FBYztnQkFDcEIsSUFBSXhELElBQXlCLEVBQWM7b0JBQ3pDaUIsTUFBTXNDLElBQUkvQyxPQUFPO2dCQUNuQjtZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUM0QyxZQUFZLEdBQUc7WUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQ0gsU0FBUyxFQUFFO2dCQUNuQixNQUFNLElBQUlULE1BQU07WUFDbEI7WUFDQSxPQUFPLElBQUksQ0FBQ1MsU0FBUztRQUN2QjtRQUNBLElBQUksQ0FBQ1EsWUFBWSxHQUFHUixDQUFBQTtZQUNsQixJQUFJLENBQUNBLFNBQVMsR0FBR0E7UUFDbkI7SUFDRjtJQUNBUyxvQkFBb0I7UUFDbEIsSUFBSSxDQUFDekIsTUFBTSxHQUFHWCxXQUFXVCxRQUFRO1lBQUM7Z0JBQ2hDa0IsV0FBVztnQkFDWEMsSUFBSSxJQUFJLENBQUNrQixhQUFhO1lBQ3hCO1NBQUU7SUFDSjtJQUNBUyxrQkFBa0JKLEdBQUcsRUFBRTtRQUNyQixJQUFJQSxlQUFlaEIsY0FBYztZQUMvQixJQUFJdkMsSUFBeUIsRUFBYztnQkFDekNpQixNQUFNc0MsSUFBSS9DLE9BQU87WUFDbkI7WUFDQSxJQUFJLENBQUNvRCxRQUFRLENBQUMsQ0FBQztZQUNmO1FBQ0Y7UUFDQSxNQUFNTDtJQUNSO0lBQ0FNLHVCQUF1QjtRQUNyQixJQUFJLENBQUM1QixNQUFNO0lBQ2I7SUFDQTZCLFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxRQUFRLENBQUMsSUFBSSxDQUFDUCxZQUFZO0lBQzlDO0FBQ0Y7QUFFQSxNQUFNUSw4QkFBOEIsQ0FBQzs7OztBQUlyQyxDQUFDO0FBQ0QsTUFBTUMsV0FBV0MsQ0FBQUEsUUFBU0EsUUFBUTtBQUNsQyxNQUFNQyxjQUFjQyxDQUFBQSxRQUFTLENBQUM7c0NBQ1EsRUFBRUgsU0FBU0csTUFBTUMsTUFBTSxDQUFDSCxLQUFLLEVBQUU7QUFDckUsQ0FBQztBQUNELE1BQU1JLGVBQWUsQ0FBQ0QsUUFBUUU7SUFDNUIsTUFBTUMsZUFBZUgsT0FBT0ksV0FBVyxLQUFLRixZQUFZRSxXQUFXO0lBQ25FLE1BQU1DLGdCQUFnQlQsU0FBU0ksT0FBT0gsS0FBSztJQUMzQyxNQUFNUyxjQUFjVixTQUFTTSxZQUFZTCxLQUFLO0lBQzlDLElBQUlNLGNBQWM7UUFDaEIsT0FBTyxDQUFDOzRDQUNnQyxFQUFFRSxjQUFjO2tCQUMxQyxFQUFFQyxZQUFZO0lBQzVCLENBQUM7SUFDSDtJQUNBLE9BQU8sQ0FBQzswQ0FDZ0MsRUFBRUQsY0FBYztZQUM5QyxFQUFFTCxPQUFPSSxXQUFXLENBQUM7WUFDckIsRUFBRUYsWUFBWUUsV0FBVyxDQUFDO2dCQUN0QixFQUFFRSxZQUFZO0VBQzVCLENBQUM7QUFDSDtBQUNBLE1BQU1DLGNBQWMsQ0FBQ0MsSUFBSVIsUUFBUVM7SUFDL0IsTUFBTUMsYUFBYVYsT0FBT0ksV0FBVyxLQUFLSyxRQUFRTCxXQUFXO0lBQzdELElBQUlNLFlBQVk7UUFDZCxPQUFPLENBQUM7ZUFDRyxFQUFFRixHQUFHOzZCQUNTLEVBQUVDLFFBQVFFLFdBQVcsQ0FBQyxDQUFDO0lBQ2xEO0lBQ0EsT0FBTyxDQUFDO2VBQ0ssRUFBRUgsR0FBRztjQUNOLEVBQUVSLE9BQU9JLFdBQVcsQ0FBQzs2QkFDTixFQUFFSyxRQUFRRSxXQUFXLENBQUM7Y0FDckMsRUFBRUYsUUFBUUwsV0FBVyxDQUFDO0lBQ2hDLENBQUM7QUFDTDtBQUNBLE1BQU1RLGVBQWVDLENBQUFBO0lBQ25CLE1BQU1DLFdBQVdELE9BQU9YLFdBQVc7SUFDbkMsSUFBSVksVUFBVTtRQUNaLE9BQU9iLGFBQWFZLE9BQU9iLE1BQU0sRUFBRWM7SUFDckM7SUFDQSxNQUFNTCxVQUFVSSxPQUFPSixPQUFPO0lBQzlCLElBQUlBLFNBQVM7UUFDWCxPQUFPRixZQUFZTSxPQUFPRixXQUFXLEVBQUVFLE9BQU9iLE1BQU0sRUFBRVM7SUFDeEQ7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxNQUFNTSxrQkFBa0JmLENBQUFBLFNBQVUsQ0FBQzs7S0FFOUIsRUFBRUosU0FBU0ksT0FBT0gsS0FBSyxFQUFFO0FBQzlCLENBQUM7QUFDRCxNQUFNbUIsWUFBWUMsQ0FBQUE7SUFDaEIsSUFBSUEsT0FBT0MsTUFBTSxLQUFLLFVBQVU7UUFDOUIsT0FBTyxDQUFDOztNQUVOLEVBQUVILGdCQUFnQkUsT0FBT2pCLE1BQU0sRUFBRTtJQUNuQyxDQUFDO0lBQ0g7SUFDQSxNQUFNYyxXQUFXRyxPQUFPZixXQUFXO0lBQ25DLE1BQU1PLFVBQVVRLE9BQU9SLE9BQU87SUFDOUIsSUFBSUssVUFBVTtRQUNaLE9BQU8sQ0FBQzs7TUFFTixFQUFFYixhQUFhZ0IsT0FBT2pCLE1BQU0sRUFBRWMsVUFBVTtJQUMxQyxDQUFDO0lBQ0g7SUFDQSxJQUFJTCxTQUFTO1FBQ1gsT0FBTyxDQUFDOztNQUVOLEVBQUVGLFlBQVlVLE9BQU9OLFdBQVcsRUFBRU0sT0FBT2pCLE1BQU0sRUFBRVMsU0FBUztJQUM1RCxDQUFDO0lBQ0g7SUFDQSxPQUFPLENBQUM7O0lBRU4sRUFBRU0sZ0JBQWdCRSxPQUFPakIsTUFBTSxFQUFFO0VBQ25DLENBQUM7QUFDSDtBQUNBLE1BQU1tQixTQUFTO0lBQ2J4QjtJQUNBRztJQUNBYztJQUNBSTtBQUNGO0FBQ0EsSUFBSUksV0FBV0Q7QUFFZixNQUFNRSxTQUFTO0lBQ2JDLEdBQUc7SUFDSEMsR0FBRztBQUNMO0FBQ0EsTUFBTUMsTUFBTSxDQUFDQyxRQUFRQyxTQUFZO1FBQy9CSixHQUFHRyxPQUFPSCxDQUFDLEdBQUdJLE9BQU9KLENBQUM7UUFDdEJDLEdBQUdFLE9BQU9GLENBQUMsR0FBR0csT0FBT0gsQ0FBQztJQUN4QjtBQUNBLE1BQU1JLFdBQVcsQ0FBQ0YsUUFBUUMsU0FBWTtRQUNwQ0osR0FBR0csT0FBT0gsQ0FBQyxHQUFHSSxPQUFPSixDQUFDO1FBQ3RCQyxHQUFHRSxPQUFPRixDQUFDLEdBQUdHLE9BQU9ILENBQUM7SUFDeEI7QUFDQSxNQUFNSyxZQUFZLENBQUNILFFBQVFDLFNBQVdELE9BQU9ILENBQUMsS0FBS0ksT0FBT0osQ0FBQyxJQUFJRyxPQUFPRixDQUFDLEtBQUtHLE9BQU9ILENBQUM7QUFDcEYsTUFBTU0sU0FBU0MsQ0FBQUEsUUFBVTtRQUN2QlIsR0FBR1EsTUFBTVIsQ0FBQyxLQUFLLElBQUksQ0FBQ1EsTUFBTVIsQ0FBQyxHQUFHO1FBQzlCQyxHQUFHTyxNQUFNUCxDQUFDLEtBQUssSUFBSSxDQUFDTyxNQUFNUCxDQUFDLEdBQUc7SUFDaEM7QUFDQSxNQUFNUSxRQUFRLFNBQVVDLElBQUksRUFBRWxHLEtBQUssRUFBRW1HLFVBQVU7SUFDN0MsSUFBSUEsZUFBZSxLQUFLLEdBQUc7UUFDekJBLGFBQWE7SUFDZjtJQUNBLElBQUlELFNBQVMsS0FBSztRQUNoQixPQUFPO1lBQ0xWLEdBQUd4RjtZQUNIeUYsR0FBR1U7UUFDTDtJQUNGO0lBQ0EsT0FBTztRQUNMWCxHQUFHVztRQUNIVixHQUFHekY7SUFDTDtBQUNGO0FBQ0EsTUFBTW9HLFdBQVcsQ0FBQ1QsUUFBUUMsU0FBV1MsS0FBS0MsSUFBSSxDQUFDLENBQUNWLE9BQU9KLENBQUMsR0FBR0csT0FBT0gsQ0FBQyxLQUFLLElBQUksQ0FBQ0ksT0FBT0gsQ0FBQyxHQUFHRSxPQUFPRixDQUFDLEtBQUs7QUFDckcsTUFBTWMsWUFBWSxDQUFDQyxRQUFRQyxTQUFXSixLQUFLSyxHQUFHLElBQUlELE9BQU9sRixHQUFHLENBQUN5RSxDQUFBQSxRQUFTSSxTQUFTSSxRQUFRUjtBQUN2RixNQUFNVyxRQUFRL0UsQ0FBQUEsS0FBTW9FLENBQUFBLFFBQVU7WUFDNUJSLEdBQUc1RCxHQUFHb0UsTUFBTVIsQ0FBQztZQUNiQyxHQUFHN0QsR0FBR29FLE1BQU1QLENBQUM7UUFDZjtBQUVBLElBQUltQixjQUFlLENBQUNDLE9BQU9DO0lBQ3pCLE1BQU0zQixTQUFTbEcsc0RBQU9BLENBQUM7UUFDckI4SCxLQUFLVixLQUFLVyxHQUFHLENBQUNGLFFBQVFDLEdBQUcsRUFBRUYsTUFBTUUsR0FBRztRQUNwQ0UsT0FBT1osS0FBS0ssR0FBRyxDQUFDSSxRQUFRRyxLQUFLLEVBQUVKLE1BQU1JLEtBQUs7UUFDMUNDLFFBQVFiLEtBQUtLLEdBQUcsQ0FBQ0ksUUFBUUksTUFBTSxFQUFFTCxNQUFNSyxNQUFNO1FBQzdDQyxNQUFNZCxLQUFLVyxHQUFHLENBQUNGLFFBQVFLLElBQUksRUFBRU4sTUFBTU0sSUFBSTtJQUN6QztJQUNBLElBQUloQyxPQUFPaUMsS0FBSyxJQUFJLEtBQUtqQyxPQUFPa0MsTUFBTSxJQUFJLEdBQUc7UUFDM0MsT0FBTztJQUNUO0lBQ0EsT0FBT2xDO0FBQ1Q7QUFFQSxNQUFNbUMsbUJBQW1CLENBQUNDLFNBQVN2QixRQUFXO1FBQzVDZSxLQUFLUSxRQUFRUixHQUFHLEdBQUdmLE1BQU1QLENBQUM7UUFDMUIwQixNQUFNSSxRQUFRSixJQUFJLEdBQUduQixNQUFNUixDQUFDO1FBQzVCMEIsUUFBUUssUUFBUUwsTUFBTSxHQUFHbEIsTUFBTVAsQ0FBQztRQUNoQ3dCLE9BQU9NLFFBQVFOLEtBQUssR0FBR2pCLE1BQU1SLENBQUM7SUFDaEM7QUFDQSxNQUFNZ0MsYUFBYUQsQ0FBQUEsVUFBVztRQUFDO1lBQzdCL0IsR0FBRytCLFFBQVFKLElBQUk7WUFDZjFCLEdBQUc4QixRQUFRUixHQUFHO1FBQ2hCO1FBQUc7WUFDRHZCLEdBQUcrQixRQUFRTixLQUFLO1lBQ2hCeEIsR0FBRzhCLFFBQVFSLEdBQUc7UUFDaEI7UUFBRztZQUNEdkIsR0FBRytCLFFBQVFKLElBQUk7WUFDZjFCLEdBQUc4QixRQUFRTCxNQUFNO1FBQ25CO1FBQUc7WUFDRDFCLEdBQUcrQixRQUFRTixLQUFLO1lBQ2hCeEIsR0FBRzhCLFFBQVFMLE1BQU07UUFDbkI7S0FBRTtBQUNGLE1BQU1PLFlBQVk7SUFDaEJWLEtBQUs7SUFDTEUsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLE1BQU07QUFDUjtBQUVBLE1BQU1PLFdBQVcsQ0FBQ2xCLFFBQVFLO0lBQ3hCLElBQUksQ0FBQ0EsT0FBTztRQUNWLE9BQU9MO0lBQ1Q7SUFDQSxPQUFPYyxpQkFBaUJkLFFBQVFLLE1BQU1jLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDQyxZQUFZO0FBQ2hFO0FBQ0EsTUFBTUMsV0FBVyxDQUFDdEIsUUFBUXVCLE1BQU1DO0lBQzlCLElBQUlBLG1CQUFtQkEsZ0JBQWdCQyxXQUFXLEVBQUU7UUFDbEQsT0FBTztZQUNMLEdBQUd6QixNQUFNO1lBQ1QsQ0FBQ3VCLEtBQUtHLEdBQUcsQ0FBQyxFQUFFMUIsTUFBTSxDQUFDdUIsS0FBS0csR0FBRyxDQUFDLEdBQUdGLGdCQUFnQkMsV0FBVyxDQUFDRixLQUFLN0IsSUFBSSxDQUFDO1FBQ3ZFO0lBQ0Y7SUFDQSxPQUFPTTtBQUNUO0FBQ0EsTUFBTTJCLE9BQU8sQ0FBQzNCLFFBQVFLO0lBQ3BCLElBQUlBLFNBQVNBLE1BQU11QixpQkFBaUIsRUFBRTtRQUNwQyxPQUFPeEIsWUFBWUMsTUFBTXdCLGFBQWEsRUFBRTdCO0lBQzFDO0lBQ0EsT0FBT3ZILHNEQUFPQSxDQUFDdUg7QUFDakI7QUFDQSxJQUFJOEIsYUFBY0MsQ0FBQUE7SUFDaEIsSUFBSSxFQUNGQyxJQUFJLEVBQ0pSLGVBQWUsRUFDZkQsSUFBSSxFQUNKbEIsS0FBSyxFQUNOLEdBQUcwQjtJQUNKLE1BQU1FLFdBQVdmLFNBQVNjLEtBQUtFLFNBQVMsRUFBRTdCO0lBQzFDLE1BQU04QixZQUFZYixTQUFTVyxVQUFVVixNQUFNQztJQUMzQyxNQUFNWSxVQUFVVCxLQUFLUSxXQUFXOUI7SUFDaEMsT0FBTztRQUNMMkI7UUFDQVI7UUFDQWEsUUFBUUQ7SUFDVjtBQUNGO0FBRUEsSUFBSUUsa0JBQW1CLENBQUNDLFdBQVdDO0lBQ2pDLENBQUNELFVBQVVsQyxLQUFLLEdBQUdqSCxLQUFxQyxHQUFHMkMsVUFBVSxTQUFTQSxDQUFnQixHQUFHLEtBQUs7SUFDdEcsTUFBTTBHLGFBQWFGLFVBQVVsQyxLQUFLO0lBQ2xDLE1BQU1xQyxhQUFhckQsU0FBU21ELFdBQVdDLFdBQVd0QixNQUFNLENBQUN3QixPQUFPO0lBQ2hFLE1BQU1DLHFCQUFxQnJELE9BQU9tRDtJQUNsQyxNQUFNckMsUUFBUTtRQUNaLEdBQUdvQyxVQUFVO1FBQ2J0QixRQUFRO1lBQ053QixTQUFTRixXQUFXdEIsTUFBTSxDQUFDd0IsT0FBTztZQUNsQ0UsU0FBU0w7WUFDVHBCLE1BQU07Z0JBQ0o1SCxPQUFPa0o7Z0JBQ1ByQixjQUFjdUI7WUFDaEI7WUFDQXBDLEtBQUtpQyxXQUFXdEIsTUFBTSxDQUFDWCxHQUFHO1FBQzVCO0lBQ0Y7SUFDQSxNQUFNRixVQUFVd0IsV0FBVztRQUN6QkUsTUFBTU8sVUFBVWpDLE9BQU8sQ0FBQzBCLElBQUk7UUFDNUJSLGlCQUFpQmUsVUFBVWpDLE9BQU8sQ0FBQ2tCLGVBQWU7UUFDbERELE1BQU1nQixVQUFVaEIsSUFBSTtRQUNwQmxCO0lBQ0Y7SUFDQSxNQUFNMUIsU0FBUztRQUNiLEdBQUc0RCxTQUFTO1FBQ1psQztRQUNBQztJQUNGO0lBQ0EsT0FBTzNCO0FBQ1Q7QUFFQSxNQUFNbUUsaUJBQWlCOUosdURBQVVBLENBQUMrSixDQUFBQSxhQUFjQSxXQUFXQyxNQUFNLENBQUMsQ0FBQ0MsVUFBVUo7UUFDM0VJLFFBQVEsQ0FBQ0osUUFBUUssVUFBVSxDQUFDaEYsRUFBRSxDQUFDLEdBQUcyRTtRQUNsQyxPQUFPSTtJQUNULEdBQUcsQ0FBQztBQUNKLE1BQU1FLGlCQUFpQm5LLHVEQUFVQSxDQUFDb0ssQ0FBQUEsYUFBY0EsV0FBV0osTUFBTSxDQUFDLENBQUNDLFVBQVVKO1FBQzNFSSxRQUFRLENBQUNKLFFBQVFLLFVBQVUsQ0FBQ2hGLEVBQUUsQ0FBQyxHQUFHMkU7UUFDbEMsT0FBT0k7SUFDVCxHQUFHLENBQUM7QUFDSixNQUFNSSxrQkFBa0JySyx1REFBVUEsQ0FBQytKLENBQUFBLGFBQWNPLE9BQU9DLE1BQU0sQ0FBQ1I7QUFDL0QsTUFBTVMsa0JBQWtCeEssdURBQVVBLENBQUNvSyxDQUFBQSxhQUFjRSxPQUFPQyxNQUFNLENBQUNIO0FBRS9ELElBQUlLLCtCQUErQnpLLHVEQUFVQSxDQUFDLENBQUM4RSxhQUFhc0Y7SUFDMUQsTUFBTXpFLFNBQVM2RSxnQkFBZ0JKLFlBQVlNLE1BQU0sQ0FBQ0MsQ0FBQUEsWUFBYTdGLGdCQUFnQjZGLFVBQVVULFVBQVUsQ0FBQ3BGLFdBQVcsRUFBRThGLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFWCxVQUFVLENBQUMzRixLQUFLLEdBQUd1RyxFQUFFWixVQUFVLENBQUMzRixLQUFLO0lBQ3ZLLE9BQU9vQjtBQUNUO0FBRUEsU0FBU29GLGtCQUFrQkMsTUFBTTtJQUMvQixJQUFJQSxPQUFPQyxFQUFFLElBQUlELE9BQU9DLEVBQUUsQ0FBQ2pLLElBQUksS0FBSyxXQUFXO1FBQzdDLE9BQU9nSyxPQUFPQyxFQUFFLENBQUNyRyxXQUFXO0lBQzlCO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU3NHLGNBQWNGLE1BQU07SUFDM0IsSUFBSUEsT0FBT0MsRUFBRSxJQUFJRCxPQUFPQyxFQUFFLENBQUNqSyxJQUFJLEtBQUssV0FBVztRQUM3QyxPQUFPZ0ssT0FBT0MsRUFBRSxDQUFDOUYsT0FBTztJQUMxQjtJQUNBLE9BQU87QUFDVDtBQUVBLElBQUlnRywwQkFBMEJuTCx1REFBVUEsQ0FBQyxDQUFDb0wsUUFBUUMsT0FBU0EsS0FBS1gsTUFBTSxDQUFDWSxDQUFBQSxPQUFRQSxLQUFLcEIsVUFBVSxDQUFDaEYsRUFBRSxLQUFLa0csT0FBT2xCLFVBQVUsQ0FBQ2hGLEVBQUU7QUFFMUgsSUFBSXFHLG9CQUFxQnhDLENBQUFBO0lBQ3ZCLElBQUksRUFDRnlDLGVBQWUsRUFDZmIsU0FBUyxFQUNUL0YsV0FBVyxFQUNYNkcsaUJBQWlCLEVBQ2pCQyxjQUFjLEVBQ2YsR0FBRzNDO0lBQ0osSUFBSSxDQUFDbkUsWUFBWStHLGdCQUFnQixFQUFFO1FBQ2pDLE9BQU87SUFDVDtJQUNBLE1BQU1uRyxXQUFXdUYsa0JBQWtCVztJQUNuQyxJQUFJLENBQUNsRyxVQUFVO1FBQ2IsT0FBTztJQUNUO0lBQ0EsU0FBU29HLFVBQVU1RSxNQUFNO1FBQ3ZCLE1BQU1pRSxLQUFLO1lBQ1RqSyxNQUFNO1lBQ05tRSxTQUFTO2dCQUNQRSxhQUFhMkI7Z0JBQ2JsQyxhQUFhRixZQUFZc0YsVUFBVSxDQUFDaEYsRUFBRTtZQUN4QztRQUNGO1FBQ0EsT0FBTztZQUNMLEdBQUd3RyxjQUFjO1lBQ2pCVDtRQUNGO0lBQ0Y7SUFDQSxNQUFNWSxNQUFNSCxlQUFlSSxTQUFTLENBQUNELEdBQUc7SUFDeEMsTUFBTUUsWUFBWUYsSUFBSUcsTUFBTSxHQUFHSCxHQUFHLENBQUMsRUFBRSxHQUFHO0lBQ3hDLElBQUlMLGlCQUFpQjtRQUNuQixPQUFPTyxZQUFZSCxVQUFVRyxhQUFhO0lBQzVDO0lBQ0EsTUFBTUUsbUJBQW1CZCx3QkFBd0JSLFdBQVdjO0lBQzVELElBQUksQ0FBQ00sV0FBVztRQUNkLElBQUksQ0FBQ0UsaUJBQWlCRCxNQUFNLEVBQUU7WUFDNUIsT0FBTztRQUNUO1FBQ0EsTUFBTUUsT0FBT0QsZ0JBQWdCLENBQUNBLGlCQUFpQkQsTUFBTSxHQUFHLEVBQUU7UUFDMUQsT0FBT0osVUFBVU0sS0FBS2hDLFVBQVUsQ0FBQ2hGLEVBQUU7SUFDckM7SUFDQSxNQUFNaUgsaUJBQWlCRixpQkFBaUJHLFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRW5DLFVBQVUsQ0FBQ2hGLEVBQUUsS0FBSzZHO0lBQzNFLENBQUVJLENBQUFBLG1CQUFtQixDQUFDLEtBQUsvTCxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLDBDQUEwQ0EsQ0FBZ0IsR0FBRyxLQUFLO0lBQ3RKLE1BQU11SixnQkFBZ0JILGlCQUFpQjtJQUN2QyxJQUFJRyxnQkFBZ0IsR0FBRztRQUNyQixPQUFPO0lBQ1Q7SUFDQSxNQUFNQyxTQUFTTixnQkFBZ0IsQ0FBQ0ssY0FBYztJQUM5QyxPQUFPVixVQUFVVyxPQUFPckMsVUFBVSxDQUFDaEYsRUFBRTtBQUN2QztBQUVBLElBQUlzSCxXQUFZLENBQUM3QixXQUFXL0YsY0FBZ0IrRixVQUFVVCxVQUFVLENBQUNwRixXQUFXLEtBQUtGLFlBQVlzRixVQUFVLENBQUNoRixFQUFFO0FBRTFHLE1BQU11SCxnQkFBZ0I7SUFDcEJqRyxPQUFPVDtJQUNQdkYsT0FBTztBQUNUO0FBQ0EsTUFBTWtNLGNBQWM7SUFDbEJDLFdBQVcsQ0FBQztJQUNaQyxTQUFTLENBQUM7SUFDVmYsS0FBSyxFQUFFO0FBQ1Q7QUFDQSxNQUFNZ0IsV0FBVztJQUNmZixXQUFXWTtJQUNYSSxhQUFhTDtJQUNieEIsSUFBSTtBQUNOO0FBQ0EsSUFBSThCLGFBQWFGO0FBRWpCLElBQUlHLFdBQVksQ0FBQ0MsWUFBWUMsYUFBZTFNLENBQUFBLFFBQVN5TSxjQUFjek0sU0FBU0EsU0FBUzBNO0FBRXJGLElBQUlDLGlDQUFrQzlGLENBQUFBO0lBQ3BDLE1BQU0rRixtQkFBbUJKLFNBQVMzRixNQUFNRSxHQUFHLEVBQUVGLE1BQU1LLE1BQU07SUFDekQsTUFBTTJGLHFCQUFxQkwsU0FBUzNGLE1BQU1NLElBQUksRUFBRU4sTUFBTUksS0FBSztJQUMzRCxPQUFPSCxDQUFBQTtRQUNMLE1BQU1nRyxjQUFjRixpQkFBaUI5RixRQUFRQyxHQUFHLEtBQUs2RixpQkFBaUI5RixRQUFRSSxNQUFNLEtBQUsyRixtQkFBbUIvRixRQUFRSyxJQUFJLEtBQUswRixtQkFBbUIvRixRQUFRRyxLQUFLO1FBQzdKLElBQUk2RixhQUFhO1lBQ2YsT0FBTztRQUNUO1FBQ0EsTUFBTUMsK0JBQStCSCxpQkFBaUI5RixRQUFRQyxHQUFHLEtBQUs2RixpQkFBaUI5RixRQUFRSSxNQUFNO1FBQ3JHLE1BQU04RixpQ0FBaUNILG1CQUFtQi9GLFFBQVFLLElBQUksS0FBSzBGLG1CQUFtQi9GLFFBQVFHLEtBQUs7UUFDM0csTUFBTWdHLHVCQUF1QkYsZ0NBQWdDQztRQUM3RCxJQUFJQyxzQkFBc0I7WUFDeEIsT0FBTztRQUNUO1FBQ0EsTUFBTUMscUJBQXFCcEcsUUFBUUMsR0FBRyxHQUFHRixNQUFNRSxHQUFHLElBQUlELFFBQVFJLE1BQU0sR0FBR0wsTUFBTUssTUFBTTtRQUNuRixNQUFNaUcsdUJBQXVCckcsUUFBUUssSUFBSSxHQUFHTixNQUFNTSxJQUFJLElBQUlMLFFBQVFHLEtBQUssR0FBR0osTUFBTUksS0FBSztRQUNyRixNQUFNbUcsMEJBQTBCRixzQkFBc0JDO1FBQ3RELElBQUlDLHlCQUF5QjtZQUMzQixPQUFPO1FBQ1Q7UUFDQSxNQUFNQywwQkFBMEJILHNCQUFzQkYsa0NBQWtDRyx3QkFBd0JKO1FBQ2hILE9BQU9NO0lBQ1Q7QUFDRjtBQUVBLElBQUlDLCtCQUFnQ3pHLENBQUFBO0lBQ2xDLE1BQU0rRixtQkFBbUJKLFNBQVMzRixNQUFNRSxHQUFHLEVBQUVGLE1BQU1LLE1BQU07SUFDekQsTUFBTTJGLHFCQUFxQkwsU0FBUzNGLE1BQU1NLElBQUksRUFBRU4sTUFBTUksS0FBSztJQUMzRCxPQUFPSCxDQUFBQTtRQUNMLE1BQU1nRyxjQUFjRixpQkFBaUI5RixRQUFRQyxHQUFHLEtBQUs2RixpQkFBaUI5RixRQUFRSSxNQUFNLEtBQUsyRixtQkFBbUIvRixRQUFRSyxJQUFJLEtBQUswRixtQkFBbUIvRixRQUFRRyxLQUFLO1FBQzdKLE9BQU82RjtJQUNUO0FBQ0Y7QUFFQSxNQUFNUyxXQUFXO0lBQ2ZDLFdBQVc7SUFDWHRILE1BQU07SUFDTnVILGVBQWU7SUFDZnhKLE9BQU87SUFDUGlFLEtBQUs7SUFDTHdGLE1BQU07SUFDTkMsZ0JBQWdCO0lBQ2hCQyxjQUFjO0lBQ2RDLGVBQWU7QUFDakI7QUFDQSxNQUFNQyxhQUFhO0lBQ2pCTixXQUFXO0lBQ1h0SCxNQUFNO0lBQ051SCxlQUFlO0lBQ2Z4SixPQUFPO0lBQ1BpRSxLQUFLO0lBQ0x3RixNQUFNO0lBQ05DLGdCQUFnQjtJQUNoQkMsY0FBYztJQUNkQyxlQUFlO0FBQ2pCO0FBRUEsSUFBSUUscUNBQXNDaEcsQ0FBQUEsT0FBUWxCLENBQUFBO1FBQ2hELE1BQU0rRixtQkFBbUJKLFNBQVMzRixNQUFNRSxHQUFHLEVBQUVGLE1BQU1LLE1BQU07UUFDekQsTUFBTTJGLHFCQUFxQkwsU0FBUzNGLE1BQU1NLElBQUksRUFBRU4sTUFBTUksS0FBSztRQUMzRCxPQUFPSCxDQUFBQTtZQUNMLElBQUlpQixTQUFTd0YsVUFBVTtnQkFDckIsT0FBT1gsaUJBQWlCOUYsUUFBUUMsR0FBRyxLQUFLNkYsaUJBQWlCOUYsUUFBUUksTUFBTTtZQUN6RTtZQUNBLE9BQU8yRixtQkFBbUIvRixRQUFRSyxJQUFJLEtBQUswRixtQkFBbUIvRixRQUFRRyxLQUFLO1FBQzdFO0lBQ0Y7QUFFQSxNQUFNK0csd0JBQXdCLENBQUN4SCxRQUFRcEM7SUFDckMsTUFBTXlELGVBQWV6RCxZQUFZeUMsS0FBSyxHQUFHekMsWUFBWXlDLEtBQUssQ0FBQ2MsTUFBTSxDQUFDQyxJQUFJLENBQUNDLFlBQVksR0FBR3RDO0lBQ3RGLE9BQU8rQixpQkFBaUJkLFFBQVFxQjtBQUNsQztBQUNBLE1BQU1vRyx1QkFBdUIsQ0FBQ3pILFFBQVFwQyxhQUFhOEo7SUFDakQsSUFBSSxDQUFDOUosWUFBWTBDLE9BQU8sQ0FBQytCLE1BQU0sRUFBRTtRQUMvQixPQUFPO0lBQ1Q7SUFDQSxPQUFPcUYsd0JBQXdCOUosWUFBWTBDLE9BQU8sQ0FBQytCLE1BQU0sRUFBRXJDO0FBQzdEO0FBQ0EsTUFBTTJILHNCQUFzQixDQUFDM0gsUUFBUTRILFVBQVVGLDBCQUE0QkEsd0JBQXdCRSxVQUFVNUg7QUFDN0csTUFBTTZILGNBQWM5RixDQUFBQTtJQUNsQixJQUFJLEVBQ0YvQixRQUFROEgsYUFBYSxFQUNyQmxLLFdBQVcsRUFDWGdLLFFBQVEsRUFDUkcseUJBQXlCLEVBQ3pCTCx1QkFBdUIsRUFDeEIsR0FBRzNGO0lBQ0osTUFBTWlHLGtCQUFrQkQsNEJBQTRCUCxzQkFBc0JNLGVBQWVsSyxlQUFla0s7SUFDeEcsT0FBT0wscUJBQXFCTyxpQkFBaUJwSyxhQUFhOEosNEJBQTRCQyxvQkFBb0JLLGlCQUFpQkosVUFBVUY7QUFDdkk7QUFDQSxNQUFNTyxxQkFBcUJDLENBQUFBLE9BQVFMLFlBQVk7UUFDN0MsR0FBR0ssSUFBSTtRQUNQUix5QkFBeUJ2QjtJQUMzQjtBQUNBLE1BQU1nQyxtQkFBbUJELENBQUFBLE9BQVFMLFlBQVk7UUFDM0MsR0FBR0ssSUFBSTtRQUNQUix5QkFBeUJaO0lBQzNCO0FBQ0EsTUFBTXNCLHlCQUF5QkYsQ0FBQUEsT0FBUUwsWUFBWTtRQUNqRCxHQUFHSyxJQUFJO1FBQ1BSLHlCQUF5QkgsbUNBQW1DVyxLQUFLdEssV0FBVyxDQUFDMkQsSUFBSTtJQUNuRjtBQUVBLE1BQU04RyxtQkFBbUIsQ0FBQ25LLElBQUlnSCxNQUFNb0Q7SUFDbEMsSUFBSSxPQUFPQSx1QkFBdUIsV0FBVztRQUMzQyxPQUFPQTtJQUNUO0lBQ0EsSUFBSSxDQUFDcEQsTUFBTTtRQUNULE9BQU87SUFDVDtJQUNBLE1BQU0sRUFDSlMsU0FBUyxFQUNUQyxPQUFPLEVBQ1IsR0FBR1Y7SUFDSixJQUFJUyxTQUFTLENBQUN6SCxHQUFHLEVBQUU7UUFDakIsT0FBTztJQUNUO0lBQ0EsTUFBTStFLFdBQVcyQyxPQUFPLENBQUMxSCxHQUFHO0lBQzVCLE9BQU8rRSxXQUFXQSxTQUFTc0YsYUFBYSxHQUFHO0FBQzdDO0FBQ0EsU0FBU0MsVUFBVTdFLFNBQVMsRUFBRW1DLFdBQVc7SUFDdkMsTUFBTTVELFlBQVl5QixVQUFVM0IsSUFBSSxDQUFDRSxTQUFTO0lBQzFDLE1BQU11RyxXQUFXO1FBQ2ZsSSxLQUFLdUYsWUFBWXRHLEtBQUssQ0FBQ1AsQ0FBQztRQUN4QndCLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNbUYsWUFBWXRHLEtBQUssQ0FBQ1IsQ0FBQztJQUMzQjtJQUNBLE9BQU92RyxzREFBT0EsQ0FBQ0MscURBQU1BLENBQUN3SixXQUFXdUc7QUFDbkM7QUFDQSxTQUFTQyxzQkFBc0IzRyxJQUFJO0lBQ2pDLElBQUksRUFDRjRHLGFBQWEsRUFDYi9LLFdBQVcsRUFDWGtJLFdBQVcsRUFDWDhCLFFBQVEsRUFDUlUsa0JBQWtCLEVBQ2xCcEQsSUFBSSxFQUNMLEdBQUduRDtJQUNKLE9BQU80RyxjQUFjM0YsTUFBTSxDQUFDLFNBQVM1SixRQUFRd1AsTUFBTSxFQUFFakYsU0FBUztRQUM1RCxNQUFNM0QsU0FBU3dJLFVBQVU3RSxXQUFXbUM7UUFDcEMsTUFBTTVILEtBQUt5RixVQUFVVCxVQUFVLENBQUNoRixFQUFFO1FBQ2xDMEssT0FBTy9ELEdBQUcsQ0FBQ2dFLElBQUksQ0FBQzNLO1FBQ2hCLE1BQU00SyxZQUFZYixtQkFBbUI7WUFDbkNqSTtZQUNBcEM7WUFDQWdLO1lBQ0FHLDJCQUEyQjtRQUM3QjtRQUNBLElBQUksQ0FBQ2UsV0FBVztZQUNkRixPQUFPakQsU0FBUyxDQUFDaEMsVUFBVVQsVUFBVSxDQUFDaEYsRUFBRSxDQUFDLEdBQUc7WUFDNUMsT0FBTzBLO1FBQ1Q7UUFDQSxNQUFNTCxnQkFBZ0JGLGlCQUFpQm5LLElBQUlnSCxNQUFNb0Q7UUFDakQsTUFBTWpILGVBQWU7WUFDbkJoRCxhQUFhSDtZQUNicUs7UUFDRjtRQUNBSyxPQUFPaEQsT0FBTyxDQUFDMUgsR0FBRyxHQUFHbUQ7UUFDckIsT0FBT3VIO0lBQ1QsR0FBRztRQUNEL0QsS0FBSyxFQUFFO1FBQ1BlLFNBQVMsQ0FBQztRQUNWRCxXQUFXLENBQUM7SUFDZDtBQUNGO0FBRUEsU0FBU29ELG1CQUFtQjNGLFVBQVUsRUFBRW5JLE9BQU87SUFDN0MsSUFBSSxDQUFDbUksV0FBVzRCLE1BQU0sRUFBRTtRQUN0QixPQUFPO0lBQ1Q7SUFDQSxNQUFNZ0Usa0JBQWtCNUYsVUFBVSxDQUFDQSxXQUFXNEIsTUFBTSxHQUFHLEVBQUUsQ0FBQzlCLFVBQVUsQ0FBQzNGLEtBQUs7SUFDMUUsT0FBT3RDLFFBQVFtRCxVQUFVLEdBQUc0SyxrQkFBa0JBLGtCQUFrQjtBQUNsRTtBQUNBLFNBQVNDLFFBQVFsSCxJQUFJO0lBQ25CLElBQUksRUFDRjBDLGlCQUFpQixFQUNqQnJHLFVBQVUsRUFDVjBILFdBQVcsRUFDWGxJLFdBQVcsRUFDWixHQUFHbUU7SUFDSixNQUFNbUgsV0FBV0gsbUJBQW1CdEUsbUJBQW1CO1FBQ3JEckc7SUFDRjtJQUNBLE9BQU87UUFDTDBHLFdBQVdZO1FBQ1hJO1FBQ0E3QixJQUFJO1lBQ0ZqSyxNQUFNO1lBQ040RCxhQUFhO2dCQUNYRSxhQUFhRixZQUFZc0YsVUFBVSxDQUFDaEYsRUFBRTtnQkFDdENYLE9BQU8yTDtZQUNUO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU0MsdUJBQXVCQyxLQUFLO0lBQ25DLElBQUksRUFDRnpGLFNBQVMsRUFDVGMsaUJBQWlCLEVBQ2pCN0csV0FBVyxFQUNYZ0ssUUFBUSxFQUNSOUIsV0FBVyxFQUNYWixJQUFJLEVBQ0ozSCxLQUFLLEVBQ0wrSyxrQkFBa0IsRUFDbkIsR0FBR2M7SUFDSixNQUFNaEwsYUFBYW9ILFNBQVM3QixXQUFXL0Y7SUFDdkMsSUFBSUwsU0FBUyxNQUFNO1FBQ2pCLE9BQU8wTCxRQUFRO1lBQ2J4RTtZQUNBckc7WUFDQTBIO1lBQ0FsSTtRQUNGO0lBQ0Y7SUFDQSxNQUFNeUwsUUFBUTVFLGtCQUFrQjZFLElBQUksQ0FBQ2hGLENBQUFBLE9BQVFBLEtBQUtwQixVQUFVLENBQUMzRixLQUFLLEtBQUtBO0lBQ3ZFLElBQUksQ0FBQzhMLE9BQU87UUFDVixPQUFPSixRQUFRO1lBQ2J4RTtZQUNBckc7WUFDQTBIO1lBQ0FsSTtRQUNGO0lBQ0Y7SUFDQSxNQUFNMkwsa0JBQWtCcEYsd0JBQXdCUixXQUFXYztJQUMzRCxNQUFNK0UsWUFBWS9FLGtCQUFrQmdGLE9BQU8sQ0FBQ0o7SUFDNUMsTUFBTUssV0FBV0gsZ0JBQWdCSSxLQUFLLENBQUNIO0lBQ3ZDLE1BQU0xRSxZQUFZNEQsc0JBQXNCO1FBQ3RDQyxlQUFlZTtRQUNmOUw7UUFDQWtJO1FBQ0FaO1FBQ0EwQyxVQUFVQSxTQUFTdkgsS0FBSztRQUN4QmlJO0lBQ0Y7SUFDQSxPQUFPO1FBQ0x4RDtRQUNBZ0I7UUFDQTdCLElBQUk7WUFDRmpLLE1BQU07WUFDTjRELGFBQWE7Z0JBQ1hFLGFBQWFGLFlBQVlzRixVQUFVLENBQUNoRixFQUFFO2dCQUN0Q1g7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLFNBQVNxTSxzQkFBc0J2TCxXQUFXLEVBQUV3TCxhQUFhO0lBQ3ZELE9BQU9DLFFBQVFELGNBQWNFLFFBQVEsQ0FBQzFMLFlBQVk7QUFDcEQ7QUFFQSxJQUFJMkwsY0FBZWpJLENBQUFBO0lBQ2pCLElBQUksRUFDRnlDLGVBQWUsRUFDZjVHLFdBQVcsRUFDWHdGLFVBQVUsRUFDVmpGLE9BQU8sRUFDUDBMLGFBQWEsRUFDZCxHQUFHOUg7SUFDSixJQUFJLENBQUNuRSxZQUFZK0csZ0JBQWdCLEVBQUU7UUFDakMsT0FBTztJQUNUO0lBQ0EsTUFBTXNGLFlBQVk5TCxRQUFRRSxXQUFXO0lBQ3JDLE1BQU02TCxjQUFjOUcsVUFBVSxDQUFDNkcsVUFBVTtJQUN6QyxNQUFNRSxtQkFBbUJELFlBQVloSCxVQUFVLENBQUMzRixLQUFLO0lBQ3JELE1BQU02TSxtQ0FBbUNSLHNCQUFzQkssV0FBV0o7SUFDMUUsSUFBSU8sa0NBQWtDO1FBQ3BDLElBQUk1RixpQkFBaUI7WUFDbkIsT0FBTzJGO1FBQ1Q7UUFDQSxPQUFPQSxtQkFBbUI7SUFDNUI7SUFDQSxJQUFJM0YsaUJBQWlCO1FBQ25CLE9BQU8yRixtQkFBbUI7SUFDNUI7SUFDQSxPQUFPQTtBQUNUO0FBRUEsSUFBSUUsY0FBZXRJLENBQUFBO0lBQ2pCLElBQUksRUFDRnlDLGVBQWUsRUFDZjNHLFlBQVksRUFDWjRHLGlCQUFpQixFQUNqQmpHLFFBQVEsRUFDVCxHQUFHdUQ7SUFDSixJQUFJLENBQUMwQyxrQkFBa0JPLE1BQU0sRUFBRTtRQUM3QixPQUFPO0lBQ1Q7SUFDQSxNQUFNc0YsZUFBZTlMLFNBQVNqQixLQUFLO0lBQ25DLE1BQU0rSCxnQkFBZ0JkLGtCQUFrQjhGLGVBQWUsSUFBSUEsZUFBZTtJQUMxRSxNQUFNQyxhQUFhOUYsaUJBQWlCLENBQUMsRUFBRSxDQUFDdkIsVUFBVSxDQUFDM0YsS0FBSztJQUN4RCxNQUFNaU4sWUFBWS9GLGlCQUFpQixDQUFDQSxrQkFBa0JPLE1BQU0sR0FBRyxFQUFFLENBQUM5QixVQUFVLENBQUMzRixLQUFLO0lBQ2xGLE1BQU0ySSxhQUFhckksZUFBZTJNLFlBQVlBLFlBQVk7SUFDMUQsSUFBSWxGLGdCQUFnQmlGLFlBQVk7UUFDOUIsT0FBTztJQUNUO0lBQ0EsSUFBSWpGLGdCQUFnQlksWUFBWTtRQUM5QixPQUFPO0lBQ1Q7SUFDQSxPQUFPWjtBQUNUO0FBRUEsSUFBSW1GLGtCQUFtQjFJLENBQUFBO0lBQ3JCLElBQUksRUFDRnlDLGVBQWUsRUFDZjNHLFlBQVksRUFDWjhGLFNBQVMsRUFDVFAsVUFBVSxFQUNWeEYsV0FBVyxFQUNYNkcsaUJBQWlCLEVBQ2pCQyxjQUFjLEVBQ2RrRCxRQUFRLEVBQ1JpQyxhQUFhLEVBQ2QsR0FBRzlIO0lBQ0osTUFBTTJJLFFBQVFoRyxlQUFlVCxFQUFFO0lBQy9CLENBQUN5RyxRQUFRdFIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywrREFBK0RBLENBQWdCLEdBQUcsS0FBSztJQUN6SixJQUFJMk8sTUFBTTFRLElBQUksS0FBSyxXQUFXO1FBQzVCLE1BQU1rUCxXQUFXbUIsWUFBWTtZQUMzQjdGO1lBQ0EzRztZQUNBVyxVQUFVa00sTUFBTTlNLFdBQVc7WUFDM0I2RztRQUNGO1FBQ0EsSUFBSXlFLFlBQVksTUFBTTtZQUNwQixPQUFPO1FBQ1Q7UUFDQSxPQUFPQyx1QkFBdUI7WUFDNUJ4RjtZQUNBYztZQUNBN0c7WUFDQWdLO1lBQ0ExQyxNQUFNUixlQUFlSSxTQUFTO1lBQzlCZ0IsYUFBYXBCLGVBQWVvQixXQUFXO1lBQ3ZDdkksT0FBTzJMO1FBQ1Q7SUFDRjtJQUNBLE1BQU1BLFdBQVdjLFlBQVk7UUFDM0J4RjtRQUNBNUc7UUFDQWtILFdBQVdKLGVBQWVJLFNBQVM7UUFDbkMxQjtRQUNBakYsU0FBU3VNLE1BQU12TSxPQUFPO1FBQ3RCMEw7SUFDRjtJQUNBLElBQUlYLFlBQVksTUFBTTtRQUNwQixPQUFPO0lBQ1Q7SUFDQSxPQUFPQyx1QkFBdUI7UUFDNUJ4RjtRQUNBYztRQUNBN0c7UUFDQWdLO1FBQ0ExQyxNQUFNUixlQUFlSSxTQUFTO1FBQzlCZ0IsYUFBYXBCLGVBQWVvQixXQUFXO1FBQ3ZDdkksT0FBTzJMO0lBQ1Q7QUFDRjtBQUVBLElBQUl5Qiw4QkFBK0I1SSxDQUFBQTtJQUNqQyxJQUFJLEVBQ0YrQyxTQUFTLEVBQ1QrRSxhQUFhLEVBQ2JLLFdBQVcsRUFDWHBFLFdBQVcsRUFDWixHQUFHL0Q7SUFDSixNQUFNNkksY0FBY2QsUUFBUWhGLFVBQVVjLE9BQU8sQ0FBQ3NFLFlBQVksSUFBSXBGLFVBQVVhLFNBQVMsQ0FBQ3VFLFlBQVk7SUFDOUYsSUFBSU4sc0JBQXNCTSxhQUFhTCxnQkFBZ0I7UUFDckQsT0FBT2UsY0FBYzdMLFNBQVNRLE9BQU91RyxZQUFZdEcsS0FBSztJQUN4RDtJQUNBLE9BQU9vTCxjQUFjOUUsWUFBWXRHLEtBQUssR0FBR1Q7QUFDM0M7QUFFQSxJQUFJOEwsZ0JBQWlCOUksQ0FBQUE7SUFDbkIsSUFBSSxFQUNGOEgsYUFBYSxFQUNiN0YsTUFBTSxFQUNOWixVQUFVLEVBQ1gsR0FBR3JCO0lBQ0osTUFBTTVELFVBQVUrRixjQUFjRjtJQUM5QixDQUFDN0YsVUFBVS9FLEtBQXFDLEdBQUcyQyxVQUFVLFNBQVNBLENBQWdCLEdBQUcsS0FBSztJQUM5RixNQUFNbU8sY0FBYy9MLFFBQVFFLFdBQVc7SUFDdkMsTUFBTXlNLFNBQVMxSCxVQUFVLENBQUM4RyxZQUFZLENBQUNsSSxJQUFJLENBQUMrSSxTQUFTLENBQUNELE1BQU07SUFDNUQsTUFBTUUsYUFBYUwsNEJBQTRCO1FBQzdDN0YsV0FBV2QsT0FBT2MsU0FBUztRQUMzQitFO1FBQ0FLO1FBQ0FwRSxhQUFhOUIsT0FBTzhCLFdBQVc7SUFDakM7SUFDQSxPQUFPNUcsSUFBSTRMLFFBQVFFO0FBQ3JCO0FBRUEsTUFBTUMscUNBQXFDLENBQUMxSixNQUFNMkosTUFBUUEsSUFBSUMsTUFBTSxDQUFDNUosS0FBSzlELEtBQUssQ0FBQyxHQUFHeU4sSUFBSUgsU0FBUyxDQUFDeEosS0FBSzJGLElBQUksQ0FBQyxHQUFHO0FBQzlHLE1BQU1rRSxtQ0FBbUMsQ0FBQzdKLE1BQU0ySixNQUFRQSxJQUFJQyxNQUFNLENBQUM1SixLQUFLRyxHQUFHLENBQUMsR0FBR3dKLElBQUlILFNBQVMsQ0FBQ3hKLEtBQUsyRixJQUFJLENBQUMsR0FBRztBQUMxRyxNQUFNbUUsOEJBQThCLENBQUM5SixNQUFNdkIsUUFBUXNMLFdBQWF0TCxNQUFNLENBQUN1QixLQUFLNEYsY0FBYyxDQUFDLEdBQUdtRSxTQUFTSCxNQUFNLENBQUM1SixLQUFLNEYsY0FBYyxDQUFDLEdBQUdtRSxTQUFTUCxTQUFTLENBQUN4SixLQUFLOEYsYUFBYSxDQUFDLEdBQUc7QUFDOUssTUFBTWtFLFVBQVV4SixDQUFBQTtJQUNkLElBQUksRUFDRlIsSUFBSSxFQUNKaUssY0FBYyxFQUNkRixRQUFRLEVBQ1QsR0FBR3ZKO0lBQ0osT0FBT3RDLE1BQU04QixLQUFLN0IsSUFBSSxFQUFFOEwsZUFBZXRKLFNBQVMsQ0FBQ1gsS0FBS0csR0FBRyxDQUFDLEdBQUd1SixtQ0FBbUMxSixNQUFNK0osV0FBV0QsNEJBQTRCOUosTUFBTWlLLGVBQWV0SixTQUFTLEVBQUVvSjtBQUMvSztBQUNBLE1BQU1HLFdBQVdyQyxDQUFBQTtJQUNmLElBQUksRUFDRjdILElBQUksRUFDSmlLLGNBQWMsRUFDZEYsUUFBUSxFQUNULEdBQUdsQztJQUNKLE9BQU8zSixNQUFNOEIsS0FBSzdCLElBQUksRUFBRThMLGVBQWV0SixTQUFTLENBQUNYLEtBQUs5RCxLQUFLLENBQUMsR0FBRzJOLGlDQUFpQzdKLE1BQU0rSixXQUFXRCw0QkFBNEI5SixNQUFNaUssZUFBZXRKLFNBQVMsRUFBRW9KO0FBQy9LO0FBQ0EsTUFBTUksY0FBY0MsQ0FBQUE7SUFDbEIsSUFBSSxFQUNGcEssSUFBSSxFQUNKcUssUUFBUSxFQUNSTixRQUFRLEVBQ1QsR0FBR0s7SUFDSixPQUFPbE0sTUFBTThCLEtBQUs3QixJQUFJLEVBQUVrTSxTQUFTQyxVQUFVLENBQUN0SyxLQUFLOUQsS0FBSyxDQUFDLEdBQUd3TixtQ0FBbUMxSixNQUFNK0osV0FBV0QsNEJBQTRCOUosTUFBTXFLLFNBQVNDLFVBQVUsRUFBRVA7QUFDdks7QUFFQSxJQUFJUSxpQkFBa0IvSixDQUFBQTtJQUNwQixJQUFJLEVBQ0ZpQyxNQUFNLEVBQ05MLFNBQVMsRUFDVFAsVUFBVSxFQUNWYixTQUFTLEVBQ1RzSCxhQUFhLEVBQ2QsR0FBRzlIO0lBQ0osTUFBTTBDLG9CQUFvQmhCLDZCQUE2QmxCLFVBQVVXLFVBQVUsQ0FBQ2hGLEVBQUUsRUFBRWtGO0lBQ2hGLE1BQU0ySSxnQkFBZ0JwSSxVQUFVM0IsSUFBSTtJQUNwQyxNQUFNVCxPQUFPZ0IsVUFBVWhCLElBQUk7SUFDM0IsSUFBSSxDQUFDa0Qsa0JBQWtCTyxNQUFNLEVBQUU7UUFDN0IsT0FBTzBHLFlBQVk7WUFDakJuSztZQUNBcUssVUFBVXJKLFVBQVVQLElBQUk7WUFDeEJzSixVQUFVUztRQUNaO0lBQ0Y7SUFDQSxNQUFNLEVBQ0pqSCxTQUFTLEVBQ1RnQixXQUFXLEVBQ1osR0FBRzlCO0lBQ0osTUFBTWdJLGVBQWVsSCxVQUFVRCxHQUFHLENBQUMsRUFBRTtJQUNyQyxJQUFJbUgsY0FBYztRQUNoQixNQUFNQyxVQUFVN0ksVUFBVSxDQUFDNEksYUFBYTtRQUN4QyxJQUFJcEMsc0JBQXNCb0MsY0FBY25DLGdCQUFnQjtZQUN0RCxPQUFPNEIsU0FBUztnQkFDZGxLO2dCQUNBaUssZ0JBQWdCUyxRQUFRakssSUFBSTtnQkFDNUJzSixVQUFVUztZQUNaO1FBQ0Y7UUFDQSxNQUFNRyxtQkFBbUJ2VCxxREFBTUEsQ0FBQ3NULFFBQVFqSyxJQUFJLEVBQUU4RCxZQUFZdEcsS0FBSztRQUMvRCxPQUFPaU0sU0FBUztZQUNkbEs7WUFDQWlLLGdCQUFnQlU7WUFDaEJaLFVBQVVTO1FBQ1o7SUFDRjtJQUNBLE1BQU03RyxPQUFPVCxpQkFBaUIsQ0FBQ0Esa0JBQWtCTyxNQUFNLEdBQUcsRUFBRTtJQUM1RCxJQUFJRSxLQUFLaEMsVUFBVSxDQUFDaEYsRUFBRSxLQUFLeUYsVUFBVVQsVUFBVSxDQUFDaEYsRUFBRSxFQUFFO1FBQ2xELE9BQU82TixjQUFjaEIsU0FBUyxDQUFDRCxNQUFNO0lBQ3ZDO0lBQ0EsSUFBSWxCLHNCQUFzQjFFLEtBQUtoQyxVQUFVLENBQUNoRixFQUFFLEVBQUUyTCxnQkFBZ0I7UUFDNUQsTUFBTTdILE9BQU9ySixxREFBTUEsQ0FBQ3VNLEtBQUtsRCxJQUFJLEVBQUV6QyxPQUFPc0ssY0FBYy9ELFdBQVcsQ0FBQ3RHLEtBQUs7UUFDckUsT0FBTytMLFFBQVE7WUFDYmhLO1lBQ0FpSyxnQkFBZ0J4SjtZQUNoQnNKLFVBQVVTO1FBQ1o7SUFDRjtJQUNBLE9BQU9SLFFBQVE7UUFDYmhLO1FBQ0FpSyxnQkFBZ0J0RyxLQUFLbEQsSUFBSTtRQUN6QnNKLFVBQVVTO0lBQ1o7QUFDRjtBQUVBLElBQUloRSw0QkFBNkIsQ0FBQ3hGLFdBQVcvQztJQUMzQyxNQUFNYSxRQUFRa0MsVUFBVWxDLEtBQUs7SUFDN0IsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBT2I7SUFDVDtJQUNBLE9BQU9OLElBQUlNLE9BQU9hLE1BQU1jLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDQyxZQUFZO0FBQ2xEO0FBRUEsTUFBTThLLHdDQUF3Q3BLLENBQUFBO0lBQzVDLElBQUksRUFDRmlDLE1BQU0sRUFDTkwsU0FBUyxFQUNUcEIsU0FBUyxFQUNUYSxVQUFVLEVBQ1Z5RyxhQUFhLEVBQ2QsR0FBRzlIO0lBQ0osTUFBTXFLLFdBQVd6SSxVQUFVM0IsSUFBSSxDQUFDK0ksU0FBUyxDQUFDRCxNQUFNO0lBQ2hELE1BQU03RyxLQUFLRCxPQUFPQyxFQUFFO0lBQ3BCLElBQUksQ0FBQzFCLFdBQVc7UUFDZCxPQUFPNko7SUFDVDtJQUNBLElBQUksQ0FBQ25JLElBQUk7UUFDUCxPQUFPbUk7SUFDVDtJQUNBLElBQUluSSxHQUFHakssSUFBSSxLQUFLLFdBQVc7UUFDekIsT0FBTzhSLGVBQWU7WUFDcEI5SDtZQUNBTDtZQUNBUDtZQUNBYjtZQUNBc0g7UUFDRjtJQUNGO0lBQ0EsT0FBT2dCLGNBQWM7UUFDbkI3RztRQUNBWjtRQUNBeUc7SUFDRjtBQUNGO0FBQ0EsSUFBSXdDLG1DQUFvQ25FLENBQUFBO0lBQ3RDLE1BQU1vRSxzQkFBc0JILHNDQUFzQ2pFO0lBQ2xFLE1BQU0zRixZQUFZMkYsS0FBSzNGLFNBQVM7SUFDaEMsTUFBTTJKLG1CQUFtQjNKLFlBQVl3RiwwQkFBMEJ4RixXQUFXK0osdUJBQXVCQTtJQUNqRyxPQUFPSjtBQUNUO0FBRUEsSUFBSUssaUJBQWtCLENBQUMzRSxVQUFVcEY7SUFDL0IsTUFBTXBCLE9BQU8vQixTQUFTbUQsV0FBV29GLFNBQVN6RyxNQUFNLENBQUN3QixPQUFPO0lBQ3hELE1BQU10QixlQUFlOUIsT0FBTzZCO0lBQzVCLE1BQU1mLFFBQVE1SCxzREFBT0EsQ0FBQztRQUNwQjhILEtBQUtpQyxVQUFVdkQsQ0FBQztRQUNoQnlCLFFBQVE4QixVQUFVdkQsQ0FBQyxHQUFHMkksU0FBU3ZILEtBQUssQ0FBQ1EsTUFBTTtRQUMzQ0YsTUFBTTZCLFVBQVV4RCxDQUFDO1FBQ2pCeUIsT0FBTytCLFVBQVV4RCxDQUFDLEdBQUc0SSxTQUFTdkgsS0FBSyxDQUFDTyxLQUFLO0lBQzNDO0lBQ0EsTUFBTTRMLFVBQVU7UUFDZG5NO1FBQ0FjLFFBQVE7WUFDTndCLFNBQVNpRixTQUFTekcsTUFBTSxDQUFDd0IsT0FBTztZQUNoQ25DLEtBQUtvSCxTQUFTekcsTUFBTSxDQUFDWCxHQUFHO1lBQ3hCcUMsU0FBU0w7WUFDVHBCLE1BQU07Z0JBQ0o1SCxPQUFPNEg7Z0JBQ1BDO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT21MO0FBQ1Q7QUFFQSxTQUFTQyxnQkFBZ0JDLEdBQUcsRUFBRXRKLFVBQVU7SUFDdEMsT0FBT3NKLElBQUkzUixHQUFHLENBQUNtRCxDQUFBQSxLQUFNa0YsVUFBVSxDQUFDbEYsR0FBRztBQUNyQztBQUNBLFNBQVN5TyxjQUFjek8sRUFBRSxFQUFFMEssTUFBTTtJQUMvQixJQUFLLElBQUlnRSxJQUFJLEdBQUdBLElBQUloRSxPQUFPNUQsTUFBTSxFQUFFNEgsSUFBSztRQUN0QyxNQUFNdkwsZUFBZXVILE1BQU0sQ0FBQ2dFLEVBQUUsQ0FBQ2hILE9BQU8sQ0FBQzFILEdBQUc7UUFDMUMsSUFBSW1ELGNBQWM7WUFDaEIsT0FBT0E7UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBQ0EsSUFBSXdMLHdCQUF5QjlLLENBQUFBO0lBQzNCLElBQUksRUFDRmlDLE1BQU0sRUFDTjRELFFBQVEsRUFDUmhLLFdBQVcsRUFDWHdGLFVBQVUsRUFDVjBKLGVBQWUsRUFDaEIsR0FBRy9LO0lBQ0osTUFBTWdMLG1CQUFtQlIsZUFBZTNFLFVBQVUxSSxJQUFJMEksU0FBU3pHLE1BQU0sQ0FBQzBCLE9BQU8sRUFBRWlLO0lBQy9FLE1BQU1FLG9CQUFvQnBQLFlBQVl5QyxLQUFLLEdBQUdpQyxnQkFBZ0IxRSxhQUFhc0IsSUFBSXRCLFlBQVl5QyxLQUFLLENBQUNjLE1BQU0sQ0FBQzBCLE9BQU8sRUFBRWlLLG9CQUFvQmxQO0lBQ3JJLE1BQU1zSCxPQUFPbEIsT0FBT2MsU0FBUztJQUM3QixNQUFNbUkscUJBQXFCdkUsc0JBQXNCO1FBQy9DQyxlQUFlOEQsZ0JBQWdCdkgsS0FBS0wsR0FBRyxFQUFFekI7UUFDekN4RjtRQUNBa0ksYUFBYTlCLE9BQU84QixXQUFXO1FBQy9COEIsVUFBVW1GLGlCQUFpQjFNLEtBQUs7UUFDaEM2RTtRQUNBb0Qsb0JBQW9CO0lBQ3RCO0lBQ0EsTUFBTTRFLHNCQUFzQnhFLHNCQUFzQjtRQUNoREMsZUFBZThELGdCQUFnQnZILEtBQUtMLEdBQUcsRUFBRXpCO1FBQ3pDeEYsYUFBYW9QO1FBQ2JsSCxhQUFhOUIsT0FBTzhCLFdBQVc7UUFDL0I4QixVQUFVQSxTQUFTdkgsS0FBSztRQUN4QjZFO1FBQ0FvRCxvQkFBb0I7SUFDdEI7SUFDQSxNQUFNM0MsWUFBWSxDQUFDO0lBQ25CLE1BQU1DLFVBQVUsQ0FBQztJQUNqQixNQUFNZ0QsU0FBUztRQUFDMUQ7UUFBTStIO1FBQW9CQztLQUFvQjtJQUM5RGhJLEtBQUtMLEdBQUcsQ0FBQ3JKLE9BQU8sQ0FBQzBDLENBQUFBO1FBQ2YsTUFBTW1ELGVBQWVzTCxjQUFjek8sSUFBSTBLO1FBQ3ZDLElBQUl2SCxjQUFjO1lBQ2hCdUUsT0FBTyxDQUFDMUgsR0FBRyxHQUFHbUQ7WUFDZDtRQUNGO1FBQ0FzRSxTQUFTLENBQUN6SCxHQUFHLEdBQUc7SUFDbEI7SUFDQSxNQUFNaVAsWUFBWTtRQUNoQixHQUFHbkosTUFBTTtRQUNUYyxXQUFXO1lBQ1RELEtBQUtLLEtBQUtMLEdBQUc7WUFDYmM7WUFDQUM7UUFDRjtJQUNGO0lBQ0EsT0FBT3VIO0FBQ1Q7QUFFQSxJQUFJQywyQkFBNEIsQ0FBQ3hGLFVBQVVwSSxRQUFVTixJQUFJMEksU0FBU3pHLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDQyxZQUFZLEVBQUU3QjtBQUU1RixJQUFJNk4sbUNBQW9DdEwsQ0FBQUE7SUFDdEMsSUFBSSxFQUNGdUwsbUJBQW1CLEVBQ25CM0osU0FBUyxFQUNUaUUsUUFBUSxFQUNULEdBQUc3RjtJQUNKLE1BQU13TCwwQkFBMEJILHlCQUF5QnhGLFVBQVUwRjtJQUNuRSxNQUFNM1UsU0FBUzBHLFNBQVNrTyx5QkFBeUI1SixVQUFVM0IsSUFBSSxDQUFDK0ksU0FBUyxDQUFDRCxNQUFNO0lBQ2hGLE9BQU81TCxJQUFJeUUsVUFBVTZKLE1BQU0sQ0FBQ3pDLFNBQVMsQ0FBQ0QsTUFBTSxFQUFFblM7QUFDaEQ7QUFFQSxJQUFJOFUsZ0NBQWlDMUwsQ0FBQUE7SUFDbkMsSUFBSSxFQUNGNEIsU0FBUyxFQUNUL0YsV0FBVyxFQUNYOFAsc0JBQXNCLEVBQ3RCOUYsUUFBUSxFQUNSRyx5QkFBeUIsRUFDekI0RixpQkFBaUIsS0FBSyxFQUN2QixHQUFHNUw7SUFDSixNQUFNNkwsZUFBZXZPLFNBQVNxTyx3QkFBd0IvSixVQUFVM0IsSUFBSSxDQUFDK0ksU0FBUyxDQUFDRCxNQUFNO0lBQ3JGLE1BQU0rQyxVQUFVL00saUJBQWlCNkMsVUFBVTNCLElBQUksQ0FBQytJLFNBQVMsRUFBRTZDO0lBQzNELE1BQU0xRixPQUFPO1FBQ1hsSSxRQUFRNk47UUFDUmpRO1FBQ0FtSztRQUNBSDtJQUNGO0lBQ0EsT0FBTytGLGlCQUFpQnZGLHVCQUF1QkYsUUFBUUMsaUJBQWlCRDtBQUMxRTtBQUVBLElBQUk0RixrQkFBbUIvTCxDQUFBQTtJQUNyQixJQUFJLEVBQ0Z5QyxlQUFlLEVBQ2ZiLFNBQVMsRUFDVC9GLFdBQVcsRUFDWHdGLFVBQVUsRUFDVnNCLGNBQWMsRUFDZGtELFFBQVEsRUFDUm1HLDJCQUEyQixFQUMzQkMsdUJBQXVCLEVBQ3ZCbkUsYUFBYSxFQUNkLEdBQUc5SDtJQUNKLElBQUksQ0FBQ25FLFlBQVlxUSxTQUFTLEVBQUU7UUFDMUIsT0FBTztJQUNUO0lBQ0EsTUFBTXhKLG9CQUFvQmhCLDZCQUE2QjdGLFlBQVlzRixVQUFVLENBQUNoRixFQUFFLEVBQUVrRjtJQUNsRixNQUFNdkYsZUFBZTJILFNBQVM3QixXQUFXL0Y7SUFDekMsTUFBTW9HLFNBQVNPLGtCQUFrQjtRQUMvQkM7UUFDQWI7UUFDQS9GO1FBQ0E2RztRQUNBQztJQUNGLE1BQU0rRixnQkFBZ0I7UUFDcEJqRztRQUNBM0c7UUFDQThGO1FBQ0FQO1FBQ0F4RjtRQUNBNkc7UUFDQUM7UUFDQWtEO1FBQ0FpQztJQUNGO0lBQ0EsSUFBSSxDQUFDN0YsUUFBUTtRQUNYLE9BQU87SUFDVDtJQUNBLE1BQU1zSixzQkFBc0JqQixpQ0FBaUM7UUFDM0RySTtRQUNBTDtRQUNBcEIsV0FBVzNFO1FBQ1h3RjtRQUNBeUc7SUFDRjtJQUNBLE1BQU1xRSx5QkFBeUJULDhCQUE4QjtRQUMzRDlKO1FBQ0EvRjtRQUNBOFAsd0JBQXdCSjtRQUN4QjFGLFVBQVVBLFNBQVN2SCxLQUFLO1FBQ3hCMEgsMkJBQTJCO1FBQzNCNEYsZ0JBQWdCO0lBQ2xCO0lBQ0EsSUFBSU8sd0JBQXdCO1FBQzFCLE1BQU1DLGtCQUFrQmQsaUNBQWlDO1lBQ3ZEQztZQUNBM0o7WUFDQWlFO1FBQ0Y7UUFDQSxPQUFPO1lBQ0x1RztZQUNBbks7WUFDQW9LLG1CQUFtQjtRQUNyQjtJQUNGO0lBQ0EsTUFBTXhPLFdBQVdQLFNBQVNpTyxxQkFBcUJTO0lBQy9DLE1BQU1NLFdBQVd4QixzQkFBc0I7UUFDckM3STtRQUNBNEQ7UUFDQWhLO1FBQ0F3RjtRQUNBMEosaUJBQWlCbE47SUFDbkI7SUFDQSxPQUFPO1FBQ0x1TyxpQkFBaUJIO1FBQ2pCaEssUUFBUXFLO1FBQ1JELG1CQUFtQnhPO0lBQ3JCO0FBQ0Y7QUFFQSxNQUFNME8saUJBQWlCL0wsQ0FBQUE7SUFDckIsTUFBTWdNLE9BQU9oTSxVQUFVakMsT0FBTyxDQUFDK0IsTUFBTTtJQUNyQyxDQUFDa00sT0FBT25WLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sNENBQTRDQSxDQUFnQixHQUFHLEtBQUs7SUFDckksT0FBT3dTO0FBQ1Q7QUFDQSxJQUFJQyw0QkFBNkJ6TSxDQUFBQTtJQUMvQixJQUFJLEVBQ0Z5QyxlQUFlLEVBQ2Y4SSxtQkFBbUIsRUFDbkI1UCxNQUFNLEVBQ05xRixVQUFVLEVBQ1Y2RSxRQUFRLEVBQ1QsR0FBRzdGO0lBQ0osTUFBTU0sU0FBUzNFLE9BQU80QyxPQUFPLENBQUMrQixNQUFNO0lBQ3BDLElBQUksQ0FBQ0EsUUFBUTtRQUNYLE9BQU87SUFDVDtJQUNBLE1BQU1kLE9BQU83RCxPQUFPNkQsSUFBSTtJQUN4QixNQUFNa04seUJBQXlCekksU0FBUzNELE1BQU0sQ0FBQ2QsS0FBSzlELEtBQUssQ0FBQyxFQUFFNEUsTUFBTSxDQUFDZCxLQUFLRyxHQUFHLENBQUM7SUFDNUUsTUFBTWdOLGFBQWFyTCxnQkFBZ0JOLFlBQVlXLE1BQU0sQ0FBQ25CLENBQUFBLFlBQWFBLGNBQWM3RSxRQUFRZ0csTUFBTSxDQUFDbkIsQ0FBQUEsWUFBYUEsVUFBVTBMLFNBQVMsRUFBRXZLLE1BQU0sQ0FBQ25CLENBQUFBLFlBQWF1SCxRQUFRdkgsVUFBVWpDLE9BQU8sQ0FBQytCLE1BQU0sR0FBR3FCLE1BQU0sQ0FBQ25CLENBQUFBLFlBQWE0RCwrQkFBK0J5QixTQUFTdkgsS0FBSyxFQUFFaU8sZUFBZS9MLGFBQWFtQixNQUFNLENBQUNuQixDQUFBQTtRQUM3UixNQUFNb00saUJBQWlCTCxlQUFlL0w7UUFDdEMsSUFBSWlDLGlCQUFpQjtZQUNuQixPQUFPbkMsTUFBTSxDQUFDZCxLQUFLNkYsWUFBWSxDQUFDLEdBQUd1SCxjQUFjLENBQUNwTixLQUFLNkYsWUFBWSxDQUFDO1FBQ3RFO1FBQ0EsT0FBT3VILGNBQWMsQ0FBQ3BOLEtBQUs0RixjQUFjLENBQUMsR0FBRzlFLE1BQU0sQ0FBQ2QsS0FBSzRGLGNBQWMsQ0FBQztJQUMxRSxHQUFHekQsTUFBTSxDQUFDbkIsQ0FBQUE7UUFDUixNQUFNb00saUJBQWlCTCxlQUFlL0w7UUFDdEMsTUFBTXFNLDhCQUE4QjVJLFNBQVMySSxjQUFjLENBQUNwTixLQUFLOUQsS0FBSyxDQUFDLEVBQUVrUixjQUFjLENBQUNwTixLQUFLRyxHQUFHLENBQUM7UUFDakcsT0FBTytNLHVCQUF1QkUsY0FBYyxDQUFDcE4sS0FBSzlELEtBQUssQ0FBQyxLQUFLZ1IsdUJBQXVCRSxjQUFjLENBQUNwTixLQUFLRyxHQUFHLENBQUMsS0FBS2tOLDRCQUE0QnZNLE1BQU0sQ0FBQ2QsS0FBSzlELEtBQUssQ0FBQyxLQUFLbVIsNEJBQTRCdk0sTUFBTSxDQUFDZCxLQUFLRyxHQUFHLENBQUM7SUFDbE4sR0FBR2tDLElBQUksQ0FBQyxDQUFDQyxHQUFHQztRQUNWLE1BQU0rSyxRQUFRUCxlQUFlekssRUFBRSxDQUFDdEMsS0FBSzRGLGNBQWMsQ0FBQztRQUNwRCxNQUFNMkgsU0FBU1IsZUFBZXhLLEVBQUUsQ0FBQ3ZDLEtBQUs0RixjQUFjLENBQUM7UUFDckQsSUFBSTNDLGlCQUFpQjtZQUNuQixPQUFPcUssUUFBUUM7UUFDakI7UUFDQSxPQUFPQSxTQUFTRDtJQUNsQixHQUFHbkwsTUFBTSxDQUFDLENBQUNuQixXQUFXaEYsT0FBT3dSLFFBQVVULGVBQWUvTCxVQUFVLENBQUNoQixLQUFLNEYsY0FBYyxDQUFDLEtBQUttSCxlQUFlUyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUN4TixLQUFLNEYsY0FBYyxDQUFDO0lBQ3ZJLElBQUksQ0FBQ3VILFdBQVcxSixNQUFNLEVBQUU7UUFDdEIsT0FBTztJQUNUO0lBQ0EsSUFBSTBKLFdBQVcxSixNQUFNLEtBQUssR0FBRztRQUMzQixPQUFPMEosVUFBVSxDQUFDLEVBQUU7SUFDdEI7SUFDQSxNQUFNTSxXQUFXTixXQUFXaEwsTUFBTSxDQUFDbkIsQ0FBQUE7UUFDakMsTUFBTTBNLG9CQUFvQmpKLFNBQVNzSSxlQUFlL0wsVUFBVSxDQUFDaEIsS0FBSzlELEtBQUssQ0FBQyxFQUFFNlEsZUFBZS9MLFVBQVUsQ0FBQ2hCLEtBQUtHLEdBQUcsQ0FBQztRQUM3RyxPQUFPdU4sa0JBQWtCM0IsbUJBQW1CLENBQUMvTCxLQUFLN0IsSUFBSSxDQUFDO0lBQ3pEO0lBQ0EsSUFBSXNQLFNBQVNoSyxNQUFNLEtBQUssR0FBRztRQUN6QixPQUFPZ0ssUUFBUSxDQUFDLEVBQUU7SUFDcEI7SUFDQSxJQUFJQSxTQUFTaEssTUFBTSxHQUFHLEdBQUc7UUFDdkIsT0FBT2dLLFNBQVNwTCxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTXdLLGVBQWV6SyxFQUFFLENBQUN0QyxLQUFLOUQsS0FBSyxDQUFDLEdBQUc2USxlQUFleEssRUFBRSxDQUFDdkMsS0FBSzlELEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRTtJQUNsRztJQUNBLE9BQU9pUixXQUFXOUssSUFBSSxDQUFDLENBQUNDLEdBQUdDO1FBQ3pCLE1BQU0rSyxRQUFROU8sVUFBVXVOLHFCQUFxQnRNLFdBQVdzTixlQUFleks7UUFDdkUsTUFBTWlMLFNBQVMvTyxVQUFVdU4scUJBQXFCdE0sV0FBV3NOLGVBQWV4SztRQUN4RSxJQUFJK0ssVUFBVUMsUUFBUTtZQUNwQixPQUFPRCxRQUFRQztRQUNqQjtRQUNBLE9BQU9SLGVBQWV6SyxFQUFFLENBQUN0QyxLQUFLOUQsS0FBSyxDQUFDLEdBQUc2USxlQUFleEssRUFBRSxDQUFDdkMsS0FBSzlELEtBQUssQ0FBQztJQUN0RSxFQUFFLENBQUMsRUFBRTtBQUNQO0FBRUEsTUFBTXlSLGdDQUFnQyxDQUFDdkwsV0FBV2tHO0lBQ2hELE1BQU11QyxXQUFXekksVUFBVTNCLElBQUksQ0FBQytJLFNBQVMsQ0FBQ0QsTUFBTTtJQUNoRCxPQUFPbEIsc0JBQXNCakcsVUFBVVQsVUFBVSxDQUFDaEYsRUFBRSxFQUFFMkwsaUJBQWlCeEssU0FBUytNLFVBQVV2QyxjQUFjL0QsV0FBVyxDQUFDdEcsS0FBSyxJQUFJNE07QUFDL0g7QUFDQSxNQUFNK0MsMEJBQTBCLENBQUN4TCxXQUFXa0c7SUFDMUMsTUFBTXVDLFdBQVd6SSxVQUFVM0IsSUFBSSxDQUFDK0ksU0FBUztJQUN6QyxPQUFPbkIsc0JBQXNCakcsVUFBVVQsVUFBVSxDQUFDaEYsRUFBRSxFQUFFMkwsaUJBQWlCL0ksaUJBQWlCc0wsVUFBVTdNLE9BQU9zSyxjQUFjL0QsV0FBVyxDQUFDdEcsS0FBSyxLQUFLNE07QUFDL0k7QUFFQSxJQUFJZ0Qsc0JBQXVCck4sQ0FBQUE7SUFDekIsSUFBSSxFQUNGdUwsbUJBQW1CLEVBQ25CMUYsUUFBUSxFQUNSaEssV0FBVyxFQUNYNkcsaUJBQWlCLEVBQ2pCb0YsYUFBYSxFQUNkLEdBQUc5SDtJQUNKLE1BQU1zTixTQUFTNUssa0JBQWtCZixNQUFNLENBQUNDLENBQUFBLFlBQWF3RSxpQkFBaUI7WUFDcEVuSSxRQUFRbVAsd0JBQXdCeEwsV0FBV2tHO1lBQzNDak07WUFDQWdLLFVBQVVBLFNBQVN2SCxLQUFLO1lBQ3hCMEgsMkJBQTJCO1FBQzdCLElBQUluRSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0M7UUFDWCxNQUFNd0wsY0FBYzFQLFNBQVMwTixxQkFBcUJ2RiwwQkFBMEJuSyxhQUFhc1IsOEJBQThCckwsR0FBR2dHO1FBQzFILE1BQU0wRixjQUFjM1AsU0FBUzBOLHFCQUFxQnZGLDBCQUEwQm5LLGFBQWFzUiw4QkFBOEJwTCxHQUFHK0Y7UUFDMUgsSUFBSXlGLGNBQWNDLGFBQWE7WUFDN0IsT0FBTyxDQUFDO1FBQ1Y7UUFDQSxJQUFJQSxjQUFjRCxhQUFhO1lBQzdCLE9BQU87UUFDVDtRQUNBLE9BQU96TCxFQUFFWCxVQUFVLENBQUMzRixLQUFLLEdBQUd1RyxFQUFFWixVQUFVLENBQUMzRixLQUFLO0lBQ2hEO0lBQ0EsT0FBTzhSLE1BQU0sQ0FBQyxFQUFFLElBQUk7QUFDdEI7QUFFQSxJQUFJRyxpQkFBaUJ4Vyx1REFBVUEsQ0FBQyxTQUFTd1csZUFBZWpPLElBQUksRUFBRXlKLFVBQVU7SUFDdEUsTUFBTTNKLGVBQWUySixVQUFVLENBQUN6SixLQUFLN0IsSUFBSSxDQUFDO0lBQzFDLE9BQU87UUFDTGxHLE9BQU82SDtRQUNQN0IsT0FBT0MsTUFBTThCLEtBQUs3QixJQUFJLEVBQUUyQjtJQUMxQjtBQUNGO0FBRUEsTUFBTW9PLGtDQUFrQyxDQUFDbE4sV0FBV21OLGlCQUFpQnRNO0lBQ25FLE1BQU03QixPQUFPZ0IsVUFBVWhCLElBQUk7SUFDM0IsSUFBSWdCLFVBQVVXLFVBQVUsQ0FBQ3lNLElBQUksS0FBSyxXQUFXO1FBQzNDLE9BQU9sUSxNQUFNOEIsS0FBSzdCLElBQUksRUFBRWdRLGVBQWUsQ0FBQ25PLEtBQUs3QixJQUFJLENBQUM7SUFDcEQ7SUFDQSxNQUFNa1EsaUJBQWlCck4sVUFBVWpDLE9BQU8sQ0FBQzBCLElBQUksQ0FBQzZKLFVBQVUsQ0FBQ3RLLEtBQUsyRixJQUFJLENBQUM7SUFDbkUsTUFBTTJJLGtCQUFrQnBNLDZCQUE2QmxCLFVBQVVXLFVBQVUsQ0FBQ2hGLEVBQUUsRUFBRWtGO0lBQzlFLE1BQU0wTSxZQUFZRCxnQkFBZ0I3TSxNQUFNLENBQUMsQ0FBQytNLEtBQUtDLFlBQWNELE1BQU1DLFVBQVV4QyxNQUFNLENBQUN0TCxTQUFTLENBQUNYLEtBQUsyRixJQUFJLENBQUMsRUFBRTtJQUMxRyxNQUFNK0ksZ0JBQWdCSCxZQUFZSixlQUFlLENBQUNuTyxLQUFLN0IsSUFBSSxDQUFDO0lBQzVELE1BQU13USxnQkFBZ0JELGdCQUFnQkw7SUFDdEMsSUFBSU0saUJBQWlCLEdBQUc7UUFDdEIsT0FBTztJQUNUO0lBQ0EsT0FBT3pRLE1BQU04QixLQUFLN0IsSUFBSSxFQUFFd1E7QUFDMUI7QUFDQSxNQUFNQyxnQkFBZ0IsQ0FBQzlQLE9BQU9HLE1BQVM7UUFDckMsR0FBR0gsS0FBSztRQUNSYyxRQUFRO1lBQ04sR0FBR2QsTUFBTWMsTUFBTTtZQUNmWDtRQUNGO0lBQ0Y7QUFDQSxNQUFNNFAsaUJBQWlCLENBQUM3TixXQUFXb0IsV0FBV1A7SUFDNUMsTUFBTS9DLFFBQVFrQyxVQUFVbEMsS0FBSztJQUM3QixDQUFDLENBQUNtRixTQUFTN0IsV0FBV3BCLGFBQWFuSixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLG1EQUFtREEsQ0FBZ0IsR0FBRyxLQUFLO0lBQ3ZLLENBQUMsQ0FBQ3dHLFVBQVVqQyxPQUFPLENBQUNrQixlQUFlLEdBQUdwSSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHNFQUFzRUEsQ0FBZ0IsR0FBRyxLQUFLO0lBQzdMLE1BQU0yVCxrQkFBa0JGLGVBQWVqTixVQUFVaEIsSUFBSSxFQUFFb0MsVUFBVXFILFVBQVUsRUFBRXhMLEtBQUs7SUFDbEYsTUFBTTZRLGlCQUFpQlosZ0NBQWdDbE4sV0FBV21OLGlCQUFpQnRNO0lBQ25GLE1BQU1rTixRQUFRO1FBQ1paO1FBQ0FqTyxhQUFhNE87UUFDYkUsbUJBQW1CaE8sVUFBVWxDLEtBQUssR0FBR2tDLFVBQVVsQyxLQUFLLENBQUNjLE1BQU0sQ0FBQ1gsR0FBRyxHQUFHO0lBQ3BFO0lBQ0EsSUFBSSxDQUFDSCxPQUFPO1FBQ1YsTUFBTUMsVUFBVXdCLFdBQVc7WUFDekJFLE1BQU1PLFVBQVVqQyxPQUFPLENBQUMwQixJQUFJO1lBQzVCUixpQkFBaUI4TztZQUNqQi9PLE1BQU1nQixVQUFVaEIsSUFBSTtZQUNwQmxCLE9BQU9rQyxVQUFVbEMsS0FBSztRQUN4QjtRQUNBLE9BQU87WUFDTCxHQUFHa0MsU0FBUztZQUNaakM7UUFDRjtJQUNGO0lBQ0EsTUFBTWtRLFlBQVlILGlCQUFpQm5SLElBQUltQixNQUFNYyxNQUFNLENBQUNYLEdBQUcsRUFBRTZQLGtCQUFrQmhRLE1BQU1jLE1BQU0sQ0FBQ1gsR0FBRztJQUMzRixNQUFNaVEsV0FBV04sY0FBYzlQLE9BQU9tUTtJQUN0QyxNQUFNbFEsVUFBVXdCLFdBQVc7UUFDekJFLE1BQU1PLFVBQVVqQyxPQUFPLENBQUMwQixJQUFJO1FBQzVCUixpQkFBaUI4TztRQUNqQi9PLE1BQU1nQixVQUFVaEIsSUFBSTtRQUNwQmxCLE9BQU9vUTtJQUNUO0lBQ0EsT0FBTztRQUNMLEdBQUdsTyxTQUFTO1FBQ1pqQztRQUNBRCxPQUFPb1E7SUFDVDtBQUNGO0FBQ0EsTUFBTUMsb0JBQW9Cbk8sQ0FBQUE7SUFDeEIsTUFBTStOLFFBQVEvTixVQUFVakMsT0FBTyxDQUFDa0IsZUFBZTtJQUMvQyxDQUFDOE8sUUFBUWxYLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sZ0VBQWdFQSxDQUFnQixHQUFHLEtBQUs7SUFDMUosTUFBTXNFLFFBQVFrQyxVQUFVbEMsS0FBSztJQUM3QixJQUFJLENBQUNBLE9BQU87UUFDVixNQUFNQyxVQUFVd0IsV0FBVztZQUN6QkUsTUFBTU8sVUFBVWpDLE9BQU8sQ0FBQzBCLElBQUk7WUFDNUJULE1BQU1nQixVQUFVaEIsSUFBSTtZQUNwQmxCLE9BQU87WUFDUG1CLGlCQUFpQjtRQUNuQjtRQUNBLE9BQU87WUFDTCxHQUFHZSxTQUFTO1lBQ1pqQztRQUNGO0lBQ0Y7SUFDQSxNQUFNcVEsZUFBZUwsTUFBTUMsaUJBQWlCO0lBQzVDLENBQUNJLGVBQWV2WCxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLDBGQUEwRkEsQ0FBZ0IsR0FBRyxLQUFLO0lBQzNMLE1BQU0wVSxXQUFXTixjQUFjOVAsT0FBT3NRO0lBQ3RDLE1BQU1yUSxVQUFVd0IsV0FBVztRQUN6QkUsTUFBTU8sVUFBVWpDLE9BQU8sQ0FBQzBCLElBQUk7UUFDNUJULE1BQU1nQixVQUFVaEIsSUFBSTtRQUNwQmxCLE9BQU9vUTtRQUNQalAsaUJBQWlCO0lBQ25CO0lBQ0EsT0FBTztRQUNMLEdBQUdlLFNBQVM7UUFDWmpDO1FBQ0FELE9BQU9vUTtJQUNUO0FBQ0Y7QUFFQSxJQUFJRyxxQkFBc0I3TyxDQUFBQTtJQUN4QixJQUFJLEVBQ0ZnTSwyQkFBMkIsRUFDM0J2QyxjQUFjLEVBQ2QvRyxpQkFBaUIsRUFDakJkLFNBQVMsRUFDVFAsVUFBVSxFQUNWeEYsV0FBVyxFQUNYZ0ssUUFBUSxFQUNSaUMsYUFBYSxFQUNkLEdBQUc5SDtJQUNKLElBQUksQ0FBQ3lKLGdCQUFnQjtRQUNuQixJQUFJL0csa0JBQWtCTyxNQUFNLEVBQUU7WUFDNUIsT0FBTztRQUNUO1FBQ0EsTUFBTTZMLFdBQVc7WUFDZi9MLFdBQVdZO1lBQ1hJLGFBQWFMO1lBQ2J4QixJQUFJO2dCQUNGakssTUFBTTtnQkFDTjRELGFBQWE7b0JBQ1hFLGFBQWFGLFlBQVlzRixVQUFVLENBQUNoRixFQUFFO29CQUN0Q1gsT0FBTztnQkFDVDtZQUNGO1FBQ0Y7UUFDQSxNQUFNdVQsOEJBQThCekUsaUNBQWlDO1lBQ25FckksUUFBUTZNO1lBQ1JsTjtZQUNBcEIsV0FBVzNFO1lBQ1h3RjtZQUNBeUc7UUFDRjtRQUNBLE1BQU1ySSxrQkFBa0JnRSxTQUFTN0IsV0FBVy9GLGVBQWVBLGNBQWN3UyxlQUFleFMsYUFBYStGLFdBQVdQO1FBQ2hILE1BQU04Syx5QkFBeUJULDhCQUE4QjtZQUMzRDlKO1lBQ0EvRixhQUFhNEQ7WUFDYmtNLHdCQUF3Qm9EO1lBQ3hCbEosVUFBVUEsU0FBU3ZILEtBQUs7WUFDeEIwSCwyQkFBMkI7WUFDM0I0RixnQkFBZ0I7UUFDbEI7UUFDQSxPQUFPTyx5QkFBeUIyQyxXQUFXO0lBQzdDO0lBQ0EsTUFBTUUsc0JBQXNCakgsUUFBUWlFLDJCQUEyQixDQUFDblEsWUFBWTJELElBQUksQ0FBQzdCLElBQUksQ0FBQyxJQUFJOEwsZUFBZXhKLElBQUksQ0FBQytJLFNBQVMsQ0FBQ0QsTUFBTSxDQUFDbE4sWUFBWTJELElBQUksQ0FBQzdCLElBQUksQ0FBQztJQUNySixNQUFNNEYsZ0JBQWdCLENBQUM7UUFDckIsTUFBTTBMLGFBQWF4RixlQUFldEksVUFBVSxDQUFDM0YsS0FBSztRQUNsRCxJQUFJaU8sZUFBZXRJLFVBQVUsQ0FBQ2hGLEVBQUUsS0FBS3lGLFVBQVVULFVBQVUsQ0FBQ2hGLEVBQUUsRUFBRTtZQUM1RCxPQUFPOFM7UUFDVDtRQUNBLElBQUlELHFCQUFxQjtZQUN2QixPQUFPQztRQUNUO1FBQ0EsT0FBT0EsYUFBYTtJQUN0QjtJQUNBLE1BQU1sTCxjQUFjMEosZUFBZTVSLFlBQVkyRCxJQUFJLEVBQUVvQyxVQUFVcUgsVUFBVTtJQUN6RSxPQUFPN0IsdUJBQXVCO1FBQzVCeEY7UUFDQWM7UUFDQTdHO1FBQ0FnSztRQUNBOUI7UUFDQVosTUFBTVE7UUFDTm5JLE9BQU8rSDtJQUNUO0FBQ0Y7QUFFQSxJQUFJMkwsZ0JBQWlCbFAsQ0FBQUE7SUFDbkIsSUFBSSxFQUNGeUMsZUFBZSxFQUNmdUosMkJBQTJCLEVBQzNCcEssU0FBUyxFQUNUdU4sTUFBTSxFQUNOOU4sVUFBVSxFQUNWTCxVQUFVLEVBQ1Y2RSxRQUFRLEVBQ1JpQyxhQUFhLEVBQ2QsR0FBRzlIO0lBQ0osTUFBTW5FLGNBQWM0USwwQkFBMEI7UUFDNUNoSztRQUNBOEkscUJBQXFCUztRQUNyQnJRLFFBQVF3VDtRQUNSbk87UUFDQTZFO0lBQ0Y7SUFDQSxJQUFJLENBQUNoSyxhQUFhO1FBQ2hCLE9BQU87SUFDVDtJQUNBLE1BQU02RyxvQkFBb0JoQiw2QkFBNkI3RixZQUFZc0YsVUFBVSxDQUFDaEYsRUFBRSxFQUFFa0Y7SUFDbEYsTUFBTW9JLGlCQUFpQjRELG9CQUFvQjtRQUN6QzlCLHFCQUFxQlM7UUFDckJuRztRQUNBaEs7UUFDQTZHO1FBQ0FvRjtJQUNGO0lBQ0EsTUFBTTdGLFNBQVM0TSxtQkFBbUI7UUFDaEM3QztRQUNBblE7UUFDQStGO1FBQ0FQO1FBQ0FvSTtRQUNBL0c7UUFDQW1EO1FBQ0FpQztJQUNGO0lBQ0EsSUFBSSxDQUFDN0YsUUFBUTtRQUNYLE9BQU87SUFDVDtJQUNBLE1BQU1zSixzQkFBc0JqQixpQ0FBaUM7UUFDM0RySTtRQUNBTDtRQUNBcEIsV0FBVzNFO1FBQ1h3RjtRQUNBeUc7SUFDRjtJQUNBLE1BQU1zRSxrQkFBa0JkLGlDQUFpQztRQUN2REM7UUFDQTNKO1FBQ0FpRTtJQUNGO0lBQ0EsT0FBTztRQUNMdUc7UUFDQW5LO1FBQ0FvSyxtQkFBbUI7SUFDckI7QUFDRjtBQUVBLElBQUkrQyxvQkFBcUJuTixDQUFBQTtJQUN2QixNQUFNQyxLQUFLRCxPQUFPQyxFQUFFO0lBQ3BCLElBQUksQ0FBQ0EsSUFBSTtRQUNQLE9BQU87SUFDVDtJQUNBLElBQUlBLEdBQUdqSyxJQUFJLEtBQUssV0FBVztRQUN6QixPQUFPaUssR0FBR3JHLFdBQVcsQ0FBQ0UsV0FBVztJQUNuQztJQUNBLE9BQU9tRyxHQUFHOUYsT0FBTyxDQUFDTCxXQUFXO0FBQy9CO0FBRUEsTUFBTXNULHFCQUFxQixDQUFDcE4sUUFBUWpCO0lBQ2xDLE1BQU03RSxLQUFLaVQsa0JBQWtCbk47SUFDN0IsT0FBTzlGLEtBQUs2RSxVQUFVLENBQUM3RSxHQUFHLEdBQUc7QUFDL0I7QUFDQSxJQUFJbVQsa0JBQW1CdFAsQ0FBQUE7SUFDckIsSUFBSSxFQUNGdVAsS0FBSyxFQUNMdFgsSUFBSSxFQUNMLEdBQUcrSDtJQUNKLE1BQU13UCxpQkFBaUJILG1CQUFtQkUsTUFBTXROLE1BQU0sRUFBRXNOLE1BQU1FLFVBQVUsQ0FBQ3pPLFVBQVU7SUFDbkYsTUFBTTBPLDRCQUE0QjNILFFBQVF5SDtJQUMxQyxNQUFNRyxPQUFPSixNQUFNRSxVQUFVLENBQUN6TyxVQUFVLENBQUN1TyxNQUFNSyxRQUFRLENBQUNwUCxTQUFTLENBQUNyRSxFQUFFLENBQUM7SUFDckUsTUFBTWdULFNBQVNLLGtCQUFrQkc7SUFDakMsTUFBTTFLLFlBQVlrSyxPQUFPM1AsSUFBSSxDQUFDeUYsU0FBUztJQUN2QyxNQUFNNEsscUJBQXFCNUssY0FBYyxjQUFlaE4sQ0FBQUEsU0FBUyxhQUFhQSxTQUFTLFdBQVUsS0FBTWdOLGNBQWMsZ0JBQWlCaE4sQ0FBQUEsU0FBUyxlQUFlQSxTQUFTLFlBQVc7SUFDbEwsSUFBSTRYLHNCQUFzQixDQUFDSCwyQkFBMkI7UUFDcEQsT0FBTztJQUNUO0lBQ0EsTUFBTWpOLGtCQUFrQnhLLFNBQVMsZUFBZUEsU0FBUztJQUN6RCxNQUFNMkosWUFBWTJOLE1BQU1FLFVBQVUsQ0FBQ3BPLFVBQVUsQ0FBQ2tPLE1BQU1LLFFBQVEsQ0FBQ2hPLFNBQVMsQ0FBQ3pGLEVBQUUsQ0FBQztJQUMxRSxNQUFNNlAsOEJBQThCdUQsTUFBTXpPLE9BQU8sQ0FBQ2IsSUFBSSxDQUFDNlAsZUFBZTtJQUN0RSxNQUFNLEVBQ0p6TyxVQUFVLEVBQ1ZMLFVBQVUsRUFDWCxHQUFHdU8sTUFBTUUsVUFBVTtJQUNwQixPQUFPSSxxQkFBcUI5RCxnQkFBZ0I7UUFDMUN0SjtRQUNBdUo7UUFDQXBLO1FBQ0EvRixhQUFhc1Q7UUFDYjlOO1FBQ0F3RSxVQUFVMEosTUFBTTFKLFFBQVE7UUFDeEJvRyx5QkFBeUJzRCxNQUFNek8sT0FBTyxDQUFDMkssTUFBTSxDQUFDc0UsU0FBUztRQUN2RHBOLGdCQUFnQjRNLE1BQU10TixNQUFNO1FBQzVCNkYsZUFBZXlILE1BQU16SCxhQUFhO0lBQ3BDLEtBQUtvSCxjQUFjO1FBQ2pCek07UUFDQXVKO1FBQ0FwSztRQUNBdU47UUFDQTlOO1FBQ0FMO1FBQ0E2RSxVQUFVMEosTUFBTTFKLFFBQVE7UUFDeEJpQyxlQUFleUgsTUFBTXpILGFBQWE7SUFDcEM7QUFDRjtBQUVBLFNBQVNrSSxrQkFBa0JULEtBQUs7SUFDOUIsT0FBT0EsTUFBTVUsS0FBSyxLQUFLLGNBQWNWLE1BQU1VLEtBQUssS0FBSztBQUN2RDtBQUVBLFNBQVNDLGtCQUFrQjVSLEtBQUs7SUFDOUIsTUFBTStGLG1CQUFtQkosU0FBUzNGLE1BQU1FLEdBQUcsRUFBRUYsTUFBTUssTUFBTTtJQUN6RCxNQUFNMkYscUJBQXFCTCxTQUFTM0YsTUFBTU0sSUFBSSxFQUFFTixNQUFNSSxLQUFLO0lBQzNELE9BQU8sU0FBU3lSLElBQUkxUyxLQUFLO1FBQ3ZCLE9BQU80RyxpQkFBaUI1RyxNQUFNUCxDQUFDLEtBQUtvSCxtQkFBbUI3RyxNQUFNUixDQUFDO0lBQ2hFO0FBQ0Y7QUFFQSxTQUFTbVQsY0FBY3RELEtBQUssRUFBRUMsTUFBTTtJQUNsQyxPQUFPRCxNQUFNbE8sSUFBSSxHQUFHbU8sT0FBT3JPLEtBQUssSUFBSW9PLE1BQU1wTyxLQUFLLEdBQUdxTyxPQUFPbk8sSUFBSSxJQUFJa08sTUFBTXRPLEdBQUcsR0FBR3VPLE9BQU9wTyxNQUFNLElBQUltTyxNQUFNbk8sTUFBTSxHQUFHb08sT0FBT3ZPLEdBQUc7QUFDekg7QUFDQSxTQUFTNlIsZ0JBQWdCclEsSUFBSTtJQUMzQixJQUFJLEVBQ0ZzUSxhQUFhLEVBQ2IxTyxTQUFTLEVBQ1QrSyxVQUFVLEVBQ1gsR0FBRzNNO0lBQ0osTUFBTXVRLGNBQWMzTyxVQUFVM0IsSUFBSSxDQUFDK0ksU0FBUyxDQUFDRCxNQUFNO0lBQ25ELE1BQU11RSxTQUFTWCxXQUFXM1QsR0FBRyxDQUFDd1gsQ0FBQUE7UUFDNUIsTUFBTWhSLE9BQU9nUixVQUFVaFIsSUFBSTtRQUMzQixNQUFNdkIsU0FBU1AsTUFBTThTLFVBQVVoUixJQUFJLENBQUM3QixJQUFJLEVBQUUyUyxjQUFjdkgsTUFBTSxDQUFDdkosS0FBSzdCLElBQUksQ0FBQyxFQUFFNlMsVUFBVXZRLElBQUksQ0FBQytJLFNBQVMsQ0FBQ0QsTUFBTSxDQUFDdkosS0FBSzBGLGFBQWEsQ0FBQztRQUM5SCxPQUFPO1lBQ0wvSSxJQUFJcVUsVUFBVXJQLFVBQVUsQ0FBQ2hGLEVBQUU7WUFDM0IwQixVQUFVQSxTQUFTMFMsYUFBYXRTO1FBQ2xDO0lBQ0YsR0FBRzRELElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFbEUsUUFBUSxHQUFHaUUsRUFBRWpFLFFBQVE7SUFDekMsT0FBT3lQLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLENBQUNuUixFQUFFLEdBQUc7QUFDcEM7QUFDQSxTQUFTc1UsaUJBQWlCcEosS0FBSztJQUM3QixJQUFJLEVBQ0ZpSixhQUFhLEVBQ2IxTyxTQUFTLEVBQ1RaLFVBQVUsRUFDWCxHQUFHcUc7SUFDSixNQUFNc0YsYUFBYXJMLGdCQUFnQk4sWUFBWVcsTUFBTSxDQUFDWSxDQUFBQTtRQUNwRCxJQUFJLENBQUNBLEtBQUsySixTQUFTLEVBQUU7WUFDbkIsT0FBTztRQUNUO1FBQ0EsTUFBTTVMLFNBQVNpQyxLQUFLaEUsT0FBTyxDQUFDK0IsTUFBTTtRQUNsQyxJQUFJLENBQUNBLFFBQVE7WUFDWCxPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUM4UCxjQUFjRSxlQUFlaFEsU0FBUztZQUN6QyxPQUFPO1FBQ1Q7UUFDQSxJQUFJNFAsa0JBQWtCNVAsUUFBUWdRLGNBQWN2SCxNQUFNLEdBQUc7WUFDbkQsT0FBTztRQUNUO1FBQ0EsTUFBTXZKLE9BQU8rQyxLQUFLL0MsSUFBSTtRQUN0QixNQUFNa1IsY0FBY3BRLE9BQU95SSxNQUFNLENBQUN2SixLQUFLMEYsYUFBYSxDQUFDO1FBQ3JELE1BQU1FLGlCQUFpQmtMLGFBQWEsQ0FBQzlRLEtBQUs0RixjQUFjLENBQUM7UUFDekQsTUFBTUMsZUFBZWlMLGFBQWEsQ0FBQzlRLEtBQUs2RixZQUFZLENBQUM7UUFDckQsTUFBTWQsY0FBY04sU0FBUzNELE1BQU0sQ0FBQ2QsS0FBSzRGLGNBQWMsQ0FBQyxFQUFFOUUsTUFBTSxDQUFDZCxLQUFLNkYsWUFBWSxDQUFDO1FBQ25GLE1BQU1zTCxtQkFBbUJwTSxZQUFZYTtRQUNyQyxNQUFNd0wsaUJBQWlCck0sWUFBWWM7UUFDbkMsSUFBSSxDQUFDc0wsb0JBQW9CLENBQUNDLGdCQUFnQjtZQUN4QyxPQUFPO1FBQ1Q7UUFDQSxJQUFJRCxrQkFBa0I7WUFDcEIsT0FBT3ZMLGlCQUFpQnNMO1FBQzFCO1FBQ0EsT0FBT3JMLGVBQWVxTDtJQUN4QjtJQUNBLElBQUksQ0FBQy9ELFdBQVcxSixNQUFNLEVBQUU7UUFDdEIsT0FBTztJQUNUO0lBQ0EsSUFBSTBKLFdBQVcxSixNQUFNLEtBQUssR0FBRztRQUMzQixPQUFPMEosVUFBVSxDQUFDLEVBQUUsQ0FBQ3hMLFVBQVUsQ0FBQ2hGLEVBQUU7SUFDcEM7SUFDQSxPQUFPa1UsZ0JBQWdCO1FBQ3JCQztRQUNBMU87UUFDQStLO0lBQ0Y7QUFDRjtBQUVBLE1BQU1rRSx1QkFBdUIsQ0FBQ3JFLE1BQU0vTyxRQUFVL0csc0RBQU9BLENBQUNxSSxpQkFBaUJ5TixNQUFNL087QUFFN0UsSUFBSTBOLHNCQUF1QixDQUFDM0ssV0FBV3NRO0lBQ3JDLE1BQU14UyxRQUFRa0MsVUFBVWxDLEtBQUs7SUFDN0IsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBT3dTO0lBQ1Q7SUFDQSxPQUFPRCxxQkFBcUJDLE1BQU14UyxNQUFNYyxNQUFNLENBQUNDLElBQUksQ0FBQzVILEtBQUs7QUFDM0Q7QUFFQSxTQUFTc1osZUFBZS9RLElBQUk7SUFDMUIsSUFBSSxFQUNGK0MsU0FBUyxFQUNUNUcsRUFBRSxFQUNILEdBQUc2RDtJQUNKLE9BQU8rSCxRQUFRaEYsVUFBVWMsT0FBTyxDQUFDMUgsR0FBRyxJQUFJNEcsVUFBVWEsU0FBUyxDQUFDekgsR0FBRztBQUNqRTtBQUVBLFNBQVM2VSxRQUFRaFIsSUFBSTtJQUNuQixJQUFJLEVBQ0Y0QixTQUFTLEVBQ1RzSSxPQUFPLEVBQ1A3TixVQUFVLEVBQ1gsR0FBRzJEO0lBQ0osSUFBSSxDQUFDa0ssU0FBUztRQUNaLE9BQU87SUFDVDtJQUNBLElBQUksQ0FBQzdOLFlBQVk7UUFDZixPQUFPNk4sUUFBUS9JLFVBQVUsQ0FBQzNGLEtBQUs7SUFDakM7SUFDQSxJQUFJME8sUUFBUS9JLFVBQVUsQ0FBQzNGLEtBQUssR0FBR29HLFVBQVVULFVBQVUsQ0FBQzNGLEtBQUssRUFBRTtRQUN6RCxPQUFPME8sUUFBUS9JLFVBQVUsQ0FBQzNGLEtBQUssR0FBRztJQUNwQztJQUNBLE9BQU8wTyxRQUFRL0ksVUFBVSxDQUFDM0YsS0FBSztBQUNqQztBQUNBLElBQUl5VixtQkFBb0I1SixDQUFBQTtJQUN0QixJQUFJLEVBQ0Y2SixrQ0FBa0NDLFVBQVUsRUFDNUN2UCxTQUFTLEVBQ1QvRixXQUFXLEVBQ1g2RyxpQkFBaUIsRUFDakJTLElBQUksRUFDSjBDLFFBQVEsRUFDUmlDLGFBQWEsRUFDZCxHQUFHVDtJQUNKLE1BQU03SCxPQUFPM0QsWUFBWTJELElBQUk7SUFDN0IsTUFBTXVFLGNBQWMwSixlQUFlNVIsWUFBWTJELElBQUksRUFBRW9DLFVBQVVxSCxVQUFVO0lBQ3pFLE1BQU0zSixlQUFleUUsWUFBWXRNLEtBQUs7SUFDdEMsTUFBTTJaLGNBQWNELFVBQVUsQ0FBQzNSLEtBQUs5RCxLQUFLLENBQUM7SUFDMUMsTUFBTTJWLFlBQVlGLFVBQVUsQ0FBQzNSLEtBQUtHLEdBQUcsQ0FBQztJQUN0QyxNQUFNNkgsa0JBQWtCcEYsd0JBQXdCUixXQUFXYztJQUMzRCxNQUFNd0gsVUFBVTFDLGdCQUFnQkQsSUFBSSxDQUFDK0osQ0FBQUE7UUFDbkMsTUFBTW5WLEtBQUttVixNQUFNblEsVUFBVSxDQUFDaEYsRUFBRTtRQUM5QixNQUFNdVUsY0FBY1ksTUFBTXJSLElBQUksQ0FBQytJLFNBQVMsQ0FBQ0QsTUFBTSxDQUFDdkosS0FBSzdCLElBQUksQ0FBQztRQUMxRCxNQUFNNFQsMEJBQTBCMUosc0JBQXNCMUwsSUFBSTJMO1FBQzFELE1BQU1lLGNBQWNrSSxlQUFlO1lBQ2pDaE8sV0FBV0k7WUFDWGhIO1FBQ0Y7UUFDQSxJQUFJb1YseUJBQXlCO1lBQzNCLElBQUkxSSxhQUFhO2dCQUNmLE9BQU93SSxhQUFhWDtZQUN0QjtZQUNBLE9BQU9VLGNBQWNWLGNBQWNwUjtRQUNyQztRQUNBLElBQUl1SixhQUFhO1lBQ2YsT0FBT3dJLGFBQWFYLGNBQWNwUjtRQUNwQztRQUNBLE9BQU84UixjQUFjVjtJQUN2QixNQUFNO0lBQ04sTUFBTXZKLFdBQVc2SixRQUFRO1FBQ3ZCcFA7UUFDQXNJO1FBQ0E3TixZQUFZb0gsU0FBUzdCLFdBQVcvRjtJQUNsQztJQUNBLE9BQU91TCx1QkFBdUI7UUFDNUJ4RjtRQUNBYztRQUNBN0c7UUFDQWdLO1FBQ0ExQztRQUNBWTtRQUNBdkksT0FBTzJMO0lBQ1Q7QUFDRjtBQUVBLE1BQU1xSywwQkFBMEI7QUFDaEMsSUFBSUMsbUJBQW9CelIsQ0FBQUE7SUFDdEIsSUFBSSxFQUNGNEIsU0FBUyxFQUNUc1Asa0NBQWtDQyxVQUFVLEVBQzVDeE8sY0FBYyxFQUNkOUcsV0FBVyxFQUNYNkcsaUJBQWlCLEVBQ2pCb0YsYUFBYSxFQUNkLEdBQUc5SDtJQUNKLElBQUksQ0FBQ25FLFlBQVkrRyxnQkFBZ0IsRUFBRTtRQUNqQyxPQUFPO0lBQ1Q7SUFDQSxNQUFNcEQsT0FBTzNELFlBQVkyRCxJQUFJO0lBQzdCLE1BQU11RSxjQUFjMEosZUFBZTVSLFlBQVkyRCxJQUFJLEVBQUVvQyxVQUFVcUgsVUFBVTtJQUN6RSxNQUFNM0osZUFBZXlFLFlBQVl0TSxLQUFLO0lBQ3RDLE1BQU0yWixjQUFjRCxVQUFVLENBQUMzUixLQUFLOUQsS0FBSyxDQUFDO0lBQzFDLE1BQU0yVixZQUFZRixVQUFVLENBQUMzUixLQUFLRyxHQUFHLENBQUM7SUFDdEMsTUFBTTZILGtCQUFrQnBGLHdCQUF3QlIsV0FBV2M7SUFDM0QsTUFBTXlGLGNBQWNYLGdCQUFnQkQsSUFBSSxDQUFDK0osQ0FBQUE7UUFDdkMsTUFBTW5WLEtBQUttVixNQUFNblEsVUFBVSxDQUFDaEYsRUFBRTtRQUM5QixNQUFNdVYsWUFBWUosTUFBTXJSLElBQUksQ0FBQytJLFNBQVM7UUFDdEMsTUFBTTJJLFlBQVlELFNBQVMsQ0FBQ2xTLEtBQUsyRixJQUFJLENBQUM7UUFDdEMsTUFBTXlNLFlBQVlELFlBQVlIO1FBQzlCLE1BQU1ELDBCQUEwQjFKLHNCQUFzQjFMLElBQUkyTDtRQUMxRCxNQUFNZSxjQUFja0ksZUFBZTtZQUNqQ2hPLFdBQVdKLGVBQWVJLFNBQVM7WUFDbkM1RztRQUNGO1FBQ0EsSUFBSW9WLHlCQUF5QjtZQUMzQixJQUFJMUksYUFBYTtnQkFDZixPQUFPd0ksWUFBWUssU0FBUyxDQUFDbFMsS0FBSzlELEtBQUssQ0FBQyxHQUFHa1csYUFBYVAsWUFBWUssU0FBUyxDQUFDbFMsS0FBS0csR0FBRyxDQUFDLEdBQUdpUztZQUM1RjtZQUNBLE9BQU9SLGNBQWNNLFNBQVMsQ0FBQ2xTLEtBQUs5RCxLQUFLLENBQUMsR0FBRzRELGVBQWVzUyxhQUFhUixjQUFjTSxTQUFTLENBQUNsUyxLQUFLRyxHQUFHLENBQUMsR0FBR0wsZUFBZXNTO1FBQzlIO1FBQ0EsSUFBSS9JLGFBQWE7WUFDZixPQUFPd0ksWUFBWUssU0FBUyxDQUFDbFMsS0FBSzlELEtBQUssQ0FBQyxHQUFHNEQsZUFBZXNTLGFBQWFQLFlBQVlLLFNBQVMsQ0FBQ2xTLEtBQUtHLEdBQUcsQ0FBQyxHQUFHTCxlQUFlc1M7UUFDMUg7UUFDQSxPQUFPUixjQUFjTSxTQUFTLENBQUNsUyxLQUFLOUQsS0FBSyxDQUFDLEdBQUdrVyxhQUFhUixjQUFjTSxTQUFTLENBQUNsUyxLQUFLRyxHQUFHLENBQUMsR0FBR2lTO0lBQ2hHO0lBQ0EsSUFBSSxDQUFDekosYUFBYTtRQUNoQixPQUFPO0lBQ1Q7SUFDQSxNQUFNbEcsU0FBUztRQUNiOEI7UUFDQWhCLFdBQVdKLGVBQWVJLFNBQVM7UUFDbkNiLElBQUk7WUFDRmpLLE1BQU07WUFDTm1FLFNBQVM7Z0JBQ1BFLGFBQWE2TCxZQUFZaEgsVUFBVSxDQUFDaEYsRUFBRTtnQkFDdENKLGFBQWFGLFlBQVlzRixVQUFVLENBQUNoRixFQUFFO1lBQ3hDO1FBQ0Y7SUFDRjtJQUNBLE9BQU84RjtBQUNUO0FBRUEsSUFBSTRQLGdCQUFpQjdSLENBQUFBO0lBQ25CLElBQUksRUFDRjhSLFVBQVUsRUFDVmxRLFNBQVMsRUFDVFAsVUFBVSxFQUNWTCxVQUFVLEVBQ1YyQixjQUFjLEVBQ2RrRCxRQUFRLEVBQ1JpQyxhQUFhLEVBQ2QsR0FBRzlIO0lBQ0osTUFBTXNRLGdCQUFnQk8scUJBQXFCalAsVUFBVTNCLElBQUksQ0FBQytJLFNBQVMsRUFBRThJO0lBQ3JFLE1BQU1DLGdCQUFnQnRCLGlCQUFpQjtRQUNyQ0g7UUFDQTFPO1FBQ0FaO0lBQ0Y7SUFDQSxJQUFJLENBQUMrUSxlQUFlO1FBQ2xCLE9BQU8vTjtJQUNUO0lBQ0EsTUFBTW5JLGNBQWNtRixVQUFVLENBQUMrUSxjQUFjO0lBQzdDLE1BQU1yUCxvQkFBb0JoQiw2QkFBNkI3RixZQUFZc0YsVUFBVSxDQUFDaEYsRUFBRSxFQUFFa0Y7SUFDbEYsTUFBTTZQLG1DQUFtQy9GLG9CQUFvQnRQLGFBQWF5VTtJQUMxRSxPQUFPbUIsaUJBQWlCO1FBQ3RCUDtRQUNBdFA7UUFDQWU7UUFDQTlHO1FBQ0E2RztRQUNBb0Y7SUFDRixNQUFNbUosaUJBQWlCO1FBQ3JCQztRQUNBdFA7UUFDQS9GO1FBQ0E2RztRQUNBUyxNQUFNUixlQUFlSSxTQUFTO1FBQzlCOEM7UUFDQWlDO0lBQ0Y7QUFDRjtBQUVBLElBQUlrSyxvQkFBcUIsQ0FBQ2hSLFlBQVl5SixVQUFhO1FBQ2pELEdBQUd6SixVQUFVO1FBQ2IsQ0FBQ3lKLFFBQVF0SixVQUFVLENBQUNoRixFQUFFLENBQUMsRUFBRXNPO0lBQzNCO0FBRUEsTUFBTXdILHlCQUF5QmpTLENBQUFBO0lBQzdCLElBQUksRUFDRjJDLGNBQWMsRUFDZFYsTUFBTSxFQUNOakIsVUFBVSxFQUNYLEdBQUdoQjtJQUNKLE1BQU1tRCxPQUFPaU0sa0JBQWtCek07SUFDL0IsTUFBTXVQLE1BQU05QyxrQkFBa0JuTjtJQUM5QixJQUFJLENBQUNrQixNQUFNO1FBQ1QsT0FBT25DO0lBQ1Q7SUFDQSxJQUFJbUMsU0FBUytPLEtBQUs7UUFDaEIsT0FBT2xSO0lBQ1Q7SUFDQSxNQUFNbVIsZ0JBQWdCblIsVUFBVSxDQUFDbUMsS0FBSztJQUN0QyxJQUFJLENBQUNnUCxjQUFjNVQsT0FBTyxDQUFDa0IsZUFBZSxFQUFFO1FBQzFDLE9BQU91QjtJQUNUO0lBQ0EsTUFBTXlKLFVBQVVrRSxrQkFBa0J3RDtJQUNsQyxPQUFPSCxrQkFBa0JoUixZQUFZeUo7QUFDdkM7QUFDQSxJQUFJMkgsd0JBQXlCL0ssQ0FBQUE7SUFDM0IsSUFBSSxFQUNGekYsU0FBUyxFQUNUUCxVQUFVLEVBQ1ZMLFVBQVUsRUFDVjJCLGNBQWMsRUFDZFYsTUFBTSxFQUNQLEdBQUdvRjtJQUNKLE1BQU1nTCxVQUFVSix1QkFBdUI7UUFDckN0UDtRQUNBVjtRQUNBakI7SUFDRjtJQUNBLE1BQU1tTyxTQUFTQyxrQkFBa0JuTjtJQUNqQyxJQUFJLENBQUNrTixRQUFRO1FBQ1gsT0FBT2tEO0lBQ1Q7SUFDQSxNQUFNN1IsWUFBWVEsVUFBVSxDQUFDbU8sT0FBTztJQUNwQyxJQUFJMUwsU0FBUzdCLFdBQVdwQixZQUFZO1FBQ2xDLE9BQU82UjtJQUNUO0lBQ0EsSUFBSTdSLFVBQVVqQyxPQUFPLENBQUNrQixlQUFlLEVBQUU7UUFDckMsT0FBTzRTO0lBQ1Q7SUFDQSxNQUFNQyxVQUFVakUsZUFBZTdOLFdBQVdvQixXQUFXUDtJQUNyRCxPQUFPMlEsa0JBQWtCSyxTQUFTQztBQUNwQztBQUVBLElBQUk5VixTQUFVd0QsQ0FBQUE7SUFDWixJQUFJLEVBQ0Z1UCxLQUFLLEVBQ0xuRCxpQkFBaUJtRyxxQkFBcUIsRUFDdEM5QyxZQUFZK0MsZ0JBQWdCLEVBQzVCM00sVUFBVTRNLGNBQWMsRUFDeEJ4USxRQUFReVEsWUFBWSxFQUNwQnJHLGlCQUFpQixFQUNsQixHQUFHck07SUFDSixNQUFNNkYsV0FBVzRNLGtCQUFrQmxELE1BQU0xSixRQUFRO0lBQ2pELE1BQU00SixhQUFhK0Msb0JBQW9CakQsTUFBTUUsVUFBVTtJQUN2RCxNQUFNckQsa0JBQWtCbUcseUJBQXlCaEQsTUFBTXpPLE9BQU8sQ0FBQzJLLE1BQU0sQ0FBQ3NFLFNBQVM7SUFDL0UsTUFBTW5aLFNBQVMwRyxTQUFTOE8saUJBQWlCbUQsTUFBTTNPLE9BQU8sQ0FBQzZLLE1BQU0sQ0FBQ3NFLFNBQVM7SUFDdkUsTUFBTXRFLFNBQVM7UUFDYjdVO1FBQ0FtWixXQUFXM0Q7UUFDWDBELGlCQUFpQjNTLElBQUlvUyxNQUFNM08sT0FBTyxDQUFDNkssTUFBTSxDQUFDcUUsZUFBZSxFQUFFbFo7SUFDN0Q7SUFDQSxNQUFNcUosT0FBTztRQUNYOFAsV0FBVzVTLElBQUlzTyxPQUFPc0UsU0FBUyxFQUFFbEssU0FBU3pHLE1BQU0sQ0FBQzBCLE9BQU87UUFDeERnUCxpQkFBaUIzUyxJQUFJc08sT0FBT3FFLGVBQWUsRUFBRWpLLFNBQVN6RyxNQUFNLENBQUMwQixPQUFPO1FBQ3BFbEssUUFBUXVHLElBQUlzTyxPQUFPN1UsTUFBTSxFQUFFaVAsU0FBU3pHLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDNUgsS0FBSztJQUN2RDtJQUNBLE1BQU1xSixVQUFVO1FBQ2QySztRQUNBeEw7SUFDRjtJQUNBLElBQUlzUCxNQUFNVSxLQUFLLEtBQUssY0FBYztRQUNoQyxPQUFPO1lBQ0wsR0FBR1YsS0FBSztZQUNSRTtZQUNBNUo7WUFDQS9FO1FBQ0Y7SUFDRjtJQUNBLE1BQU1jLFlBQVk2TixXQUFXcE8sVUFBVSxDQUFDa08sTUFBTUssUUFBUSxDQUFDaE8sU0FBUyxDQUFDekYsRUFBRSxDQUFDO0lBQ3BFLE1BQU1pUCxZQUFZc0gsZ0JBQWdCYixjQUFjO1FBQzlDQyxZQUFZN1IsS0FBS3JKLE1BQU07UUFDdkJnTDtRQUNBUCxZQUFZb08sV0FBV3BPLFVBQVU7UUFDakNMLFlBQVl5TyxXQUFXek8sVUFBVTtRQUNqQzJCLGdCQUFnQjRNLE1BQU10TixNQUFNO1FBQzVCNEQ7UUFDQWlDLGVBQWV5SCxNQUFNekgsYUFBYTtJQUNwQztJQUNBLE1BQU02SywwQkFBMEJQLHNCQUFzQjtRQUNwRHhRO1FBQ0FLLFFBQVFtSjtRQUNSekksZ0JBQWdCNE0sTUFBTXROLE1BQU07UUFDNUJaLFlBQVlvTyxXQUFXcE8sVUFBVTtRQUNqQ0wsWUFBWXlPLFdBQVd6TyxVQUFVO0lBQ25DO0lBQ0EsTUFBTXBFLFNBQVM7UUFDYixHQUFHMlMsS0FBSztRQUNSek87UUFDQTJPLFlBQVk7WUFDVnBPLFlBQVlvTyxXQUFXcE8sVUFBVTtZQUNqQ0wsWUFBWTJSO1FBQ2Q7UUFDQTFRLFFBQVFtSjtRQUNSdkY7UUFDQXdHLG1CQUFtQkEscUJBQXFCO1FBQ3hDOUYsb0JBQW9COEYsb0JBQW9CLFFBQVE7SUFDbEQ7SUFDQSxPQUFPelA7QUFDVDtBQUVBLFNBQVNnVyxjQUFjakksR0FBRyxFQUFFdEosVUFBVTtJQUNwQyxPQUFPc0osSUFBSTNSLEdBQUcsQ0FBQ21ELENBQUFBLEtBQU1rRixVQUFVLENBQUNsRixHQUFHO0FBQ3JDO0FBQ0EsSUFBSTBXLFlBQWE3UyxDQUFBQTtJQUNmLElBQUksRUFDRmlDLE1BQU0sRUFDTjRELFFBQVEsRUFDUnhFLFVBQVUsRUFDVnhGLFdBQVcsRUFDWDBLLGtCQUFrQixFQUNuQixHQUFHdkc7SUFDSixNQUFNbUQsT0FBT2xCLE9BQU9jLFNBQVM7SUFDN0IsTUFBTTZELGdCQUFnQmdNLGNBQWN6UCxLQUFLTCxHQUFHLEVBQUV6QjtJQUM5QyxNQUFNMEIsWUFBWTRELHNCQUFzQjtRQUN0Q0M7UUFDQS9LO1FBQ0FrSSxhQUFhOUIsT0FBTzhCLFdBQVc7UUFDL0I4QixVQUFVQSxTQUFTdkgsS0FBSztRQUN4QmlJO1FBQ0FwRDtJQUNGO0lBQ0EsT0FBTztRQUNMLEdBQUdsQixNQUFNO1FBQ1RjO0lBQ0Y7QUFDRjtBQUVBLElBQUkrUCwyQkFBNEI5UyxDQUFBQTtJQUM5QixJQUFJLEVBQ0ZpQyxNQUFNLEVBQ05MLFNBQVMsRUFDVHBCLFNBQVMsRUFDVGEsVUFBVSxFQUNWd0UsUUFBUSxFQUNSaUMsYUFBYSxFQUNkLEdBQUc5SDtJQUNKLE1BQU11TCxzQkFBc0JqQixpQ0FBaUM7UUFDM0RySTtRQUNBTDtRQUNBUDtRQUNBYjtRQUNBc0g7SUFDRjtJQUNBLE9BQU93RCxpQ0FBaUM7UUFDdENDO1FBQ0EzSjtRQUNBaUU7SUFDRjtBQUNGO0FBRUEsSUFBSWtOLGNBQWUvUyxDQUFBQTtJQUNqQixJQUFJLEVBQ0Z1UCxLQUFLLEVBQ0xFLFlBQVkrQyxnQkFBZ0IsRUFDNUIzTSxVQUFVNE0sY0FBYyxFQUN6QixHQUFHelM7SUFDSixDQUFFdVAsQ0FBQUEsTUFBTXlELFlBQVksS0FBSyxNQUFLLElBQUszYixLQUFxQyxHQUFHMkMsVUFBVSxTQUFTQSxDQUFnQixHQUFHLEtBQUs7SUFDdEgsTUFBTWlaLHVCQUF1QjFELE1BQU10TixNQUFNO0lBQ3pDLE1BQU00RCxXQUFXNE0sa0JBQWtCbEQsTUFBTTFKLFFBQVE7SUFDakQsTUFBTTRKLGFBQWErQyxvQkFBb0JqRCxNQUFNRSxVQUFVO0lBQ3ZELE1BQU0sRUFDSnBPLFVBQVUsRUFDVkwsVUFBVSxFQUNYLEdBQUd5TztJQUNKLE1BQU03TixZQUFZUCxVQUFVLENBQUNrTyxNQUFNSyxRQUFRLENBQUNoTyxTQUFTLENBQUN6RixFQUFFLENBQUM7SUFDekQsTUFBTWdULFNBQVNDLGtCQUFrQjZEO0lBQ2pDLENBQUM5RCxTQUFTOVgsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxzREFBc0RBLENBQWdCLEdBQUcsS0FBSztJQUNqSixNQUFNNkIsY0FBY21GLFVBQVUsQ0FBQ21PLE9BQU87SUFDdEMsTUFBTWxOLFNBQVM0USxVQUFVO1FBQ3ZCNVEsUUFBUWdSO1FBQ1JwTjtRQUNBaEs7UUFDQXdGO0lBQ0Y7SUFDQSxNQUFNK0ssa0JBQWtCMEcseUJBQXlCO1FBQy9DN1E7UUFDQUw7UUFDQXBCLFdBQVczRTtRQUNYd0Y7UUFDQXdFO1FBQ0FpQyxlQUFleUgsTUFBTXpILGFBQWE7SUFDcEM7SUFDQSxPQUFPdEwsT0FBTztRQUNaeUY7UUFDQW1LO1FBQ0FtRDtRQUNBRTtRQUNBNUo7SUFDRjtBQUNGO0FBRUEsSUFBSXFOLGtCQUFtQi9SLENBQUFBLGFBQWU7UUFDcEMzRixPQUFPMkYsV0FBVzNGLEtBQUs7UUFDdkJPLGFBQWFvRixXQUFXcEYsV0FBVztJQUNyQztBQUVBLElBQUlvWCxnQkFBaUJuVCxDQUFBQTtJQUNuQixJQUFJLEVBQ0Y0QixTQUFTLEVBQ1QrTixJQUFJLEVBQ0p0TyxVQUFVLEVBQ1Z3RSxRQUFRLEVBQ1QsR0FBRzdGO0lBQ0osTUFBTStELGNBQWMwSixlQUFla0MsS0FBS25RLElBQUksRUFBRW9DLFVBQVVxSCxVQUFVO0lBQ2xFLE1BQU1tSyxhQUFhMVIsNkJBQTZCaU8sS0FBS3hPLFVBQVUsQ0FBQ2hGLEVBQUUsRUFBRWtGO0lBQ3BFLE1BQU1nUyxXQUFXRCxXQUFXMUwsT0FBTyxDQUFDOUY7SUFDcEMsQ0FBRXlSLENBQUFBLGFBQWEsQ0FBQyxLQUFLaGMsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywrQ0FBK0NBLENBQWdCLEdBQUcsS0FBSztJQUNySixNQUFNNE0sZ0JBQWdCd00sV0FBV3hMLEtBQUssQ0FBQ3lMLFdBQVc7SUFDbEQsTUFBTXJMLFdBQVdwQixjQUFjM0YsTUFBTSxDQUFDLENBQUNDLFVBQVVxQjtRQUMvQ3JCLFFBQVEsQ0FBQ3FCLEtBQUtwQixVQUFVLENBQUNoRixFQUFFLENBQUMsR0FBRztRQUMvQixPQUFPK0U7SUFDVCxHQUFHLENBQUM7SUFDSixNQUFNNEcsZ0JBQWdCO1FBQ3BCd0wsZUFBZTNELEtBQUt4TyxVQUFVLENBQUN5TSxJQUFJLEtBQUs7UUFDeEM3SjtRQUNBaUU7SUFDRjtJQUNBLE1BQU1qRixZQUFZNEQsc0JBQXNCO1FBQ3RDQztRQUNBL0ssYUFBYThUO1FBQ2I1TDtRQUNBWixNQUFNO1FBQ04wQyxVQUFVQSxTQUFTdkgsS0FBSztRQUN4QmlJLG9CQUFvQjtJQUN0QjtJQUNBLE1BQU10RSxTQUFTO1FBQ2JjO1FBQ0FnQjtRQUNBN0IsSUFBSTtZQUNGakssTUFBTTtZQUNONEQsYUFBYXFYLGdCQUFnQnRSLFVBQVVULFVBQVU7UUFDbkQ7SUFDRjtJQUNBLE9BQU87UUFDTGM7UUFDQTZGO0lBQ0Y7QUFDRjtBQUVBLElBQUl5TCxvQkFBcUIsQ0FBQzlELFlBQVloRixVQUFhO1FBQ2pEcEosWUFBWW9PLFdBQVdwTyxVQUFVO1FBQ2pDTCxZQUFZZ1Isa0JBQWtCdkMsV0FBV3pPLFVBQVUsRUFBRXlKO0lBQ3ZEO0FBRUEsTUFBTS9PLFFBQVE4WCxDQUFBQTtJQUNaLElBQUluYyxJQUF5QixFQUFjO1FBQ3pDO1lBQ0U7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxNQUFNb2MsU0FBU0QsQ0FBQUE7SUFDYixJQUFJbmMsSUFBeUIsRUFBYztRQUN6QztZQUNFO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsSUFBSXFjLGtCQUFtQjFULENBQUFBO0lBQ3JCLElBQUksRUFDRjRCLFNBQVMsRUFDVGhMLFFBQVErYyxRQUFRLEVBQ2hCQyxtQkFBbUIsRUFDcEIsR0FBRzVUO0lBQ0osTUFBTXlMLFNBQVM3VSxxREFBTUEsQ0FBQ2dMLFVBQVU2SixNQUFNLEVBQUVrSTtJQUN4QyxNQUFNMVQsT0FBT3BKLHlEQUFVQSxDQUFDNFUsUUFBUW1JO0lBQ2hDLE1BQU1DLFFBQVE7UUFDWixHQUFHalMsU0FBUztRQUNaa1MsYUFBYTtZQUNYLEdBQUdsUyxVQUFVa1MsV0FBVztZQUN4QnJJO1FBQ0Y7UUFDQUE7UUFDQXhMO0lBQ0Y7SUFDQSxPQUFPNFQ7QUFDVDtBQUVBLElBQUlFLFdBQVl2VCxDQUFBQTtJQUNkLE1BQU1sQyxRQUFRa0MsVUFBVWxDLEtBQUs7SUFDN0IsQ0FBQ0EsUUFBUWpILEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sd0NBQXdDQSxDQUFnQixHQUFHLEtBQUs7SUFDbEksT0FBT3NFO0FBQ1Q7QUFFQSxJQUFJMFYsa0NBQW1DaFUsQ0FBQUE7SUFDckMsSUFBSSxFQUNGaVUsU0FBUyxFQUNUQyxpQkFBaUIsRUFDakJyTyxRQUFRLEVBQ1QsR0FBRzdGO0lBQ0osTUFBTW1VLHFCQUFxQnRPLFNBQVN6RyxNQUFNLENBQUNDLElBQUksQ0FBQzVILEtBQUs7SUFDckQsT0FBT3djLFVBQVVqYixHQUFHLENBQUM0SSxDQUFBQTtRQUNuQixNQUFNN0YsY0FBYzZGLFVBQVVULFVBQVUsQ0FBQ3BGLFdBQVc7UUFDcEQsTUFBTXFZLFdBQVdGLGlCQUFpQixDQUFDblksWUFBWTtRQUMvQyxNQUFNdUMsUUFBUXlWLFNBQVNLO1FBQ3ZCLE1BQU1DLHdCQUF3Qi9WLE1BQU1jLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDNUgsS0FBSztRQUNyRCxNQUFNNmMsY0FBY25YLElBQUlnWCxvQkFBb0JFO1FBQzVDLE1BQU1SLFFBQVFILGdCQUFnQjtZQUM1QjlSO1lBQ0FoTCxRQUFRMGQ7WUFDUlYscUJBQXFCL04sU0FBU3pHLE1BQU0sQ0FBQ3dCLE9BQU87UUFDOUM7UUFDQSxPQUFPaVQ7SUFDVDtBQUNGO0FBRUEsTUFBTVUsYUFBYTtBQUNuQixJQUFJQyxnQ0FBaUN4VSxDQUFBQTtJQUNuQyxJQUFJLEVBQ0Z1UCxLQUFLLEVBQ0xrRixTQUFTLEVBQ1YsR0FBR3pVO0lBQ0p0RSxNQUFNNlk7SUFDTixNQUFNRyxtQkFBbUJELFVBQVVMLFFBQVEsQ0FBQ3BiLEdBQUcsQ0FBQ3dELENBQUFBO1FBQzlDLE1BQU1tWSxXQUFXcEYsTUFBTUUsVUFBVSxDQUFDek8sVUFBVSxDQUFDeEUsT0FBT1QsV0FBVyxDQUFDO1FBQ2hFLE1BQU1tRSxXQUFXSyxnQkFBZ0JvVSxVQUFVblksT0FBTzRDLE1BQU07UUFDeEQsT0FBT2M7SUFDVDtJQUNBLE1BQU1jLGFBQWE7UUFDakIsR0FBR3VPLE1BQU1FLFVBQVUsQ0FBQ3pPLFVBQVU7UUFDOUIsR0FBR0QsZUFBZTJULGlCQUFpQjtJQUNyQztJQUNBLE1BQU1FLG1CQUFtQnhULGVBQWU0UyxnQ0FBZ0M7UUFDdEVDLFdBQVdRLFVBQVVSLFNBQVM7UUFDOUJDLG1CQUFtQmxUO1FBQ25CNkUsVUFBVTBKLE1BQU0xSixRQUFRO0lBQzFCO0lBQ0EsTUFBTXhFLGFBQWE7UUFDakIsR0FBR2tPLE1BQU1FLFVBQVUsQ0FBQ3BPLFVBQVU7UUFDOUIsR0FBR3VULGdCQUFnQjtJQUNyQjtJQUNBSCxVQUFVSSxRQUFRLENBQUNwYixPQUFPLENBQUMwQyxDQUFBQTtRQUN6QixPQUFPa0YsVUFBVSxDQUFDbEYsR0FBRztJQUN2QjtJQUNBLE1BQU1zVCxhQUFhO1FBQ2pCek87UUFDQUs7SUFDRjtJQUNBLE1BQU15VCxZQUFZMUYsa0JBQWtCRyxNQUFNdE4sTUFBTTtJQUNoRCxNQUFNOFMsVUFBVUQsWUFBWXJGLFdBQVd6TyxVQUFVLENBQUM4VCxVQUFVLEdBQUc7SUFDL0QsTUFBTWxULFlBQVk2TixXQUFXcE8sVUFBVSxDQUFDa08sTUFBTUssUUFBUSxDQUFDaE8sU0FBUyxDQUFDekYsRUFBRSxDQUFDO0lBQ3BFLE1BQU13VCxPQUFPRixXQUFXek8sVUFBVSxDQUFDdU8sTUFBTUssUUFBUSxDQUFDcFAsU0FBUyxDQUFDckUsRUFBRSxDQUFDO0lBQy9ELE1BQU0sRUFDSjhGLFFBQVErUyxZQUFZLEVBQ3BCbE4sYUFBYSxFQUNkLEdBQUdxTCxjQUFjO1FBQ2hCdlI7UUFDQStOO1FBQ0F0TztRQUNBd0UsVUFBVTBKLE1BQU0xSixRQUFRO0lBQzFCO0lBQ0EsTUFBTWxELGlCQUFpQm9TLFdBQVdBLFFBQVFuUyxnQkFBZ0IsR0FBRzJNLE1BQU10TixNQUFNLEdBQUcrUztJQUM1RSxNQUFNL1MsU0FBUzRQLGNBQWM7UUFDM0JDLFlBQVl2QyxNQUFNek8sT0FBTyxDQUFDYixJQUFJLENBQUNySixNQUFNO1FBQ3JDZ0wsV0FBVzZOLFdBQVdwTyxVQUFVLENBQUNrTyxNQUFNSyxRQUFRLENBQUNoTyxTQUFTLENBQUN6RixFQUFFLENBQUM7UUFDN0RrRixZQUFZb08sV0FBV3BPLFVBQVU7UUFDakNMLFlBQVl5TyxXQUFXek8sVUFBVTtRQUNqQzJCO1FBQ0FrRCxVQUFVMEosTUFBTTFKLFFBQVE7UUFDeEJpQztJQUNGO0lBQ0EyTCxPQUFPYztJQUNQLE1BQU1VLGdCQUFnQjtRQUNwQixHQUFHMUYsS0FBSztRQUNSVSxPQUFPO1FBQ1BoTztRQUNBK1M7UUFDQXZGO1FBQ0EzSDtRQUNBdkIsb0JBQW9CO0lBQ3RCO0lBQ0EsSUFBSWdKLE1BQU1VLEtBQUssS0FBSyxjQUFjO1FBQ2hDLE9BQU9nRjtJQUNUO0lBQ0EsTUFBTUMsY0FBYztRQUNsQixHQUFHRCxhQUFhO1FBQ2hCaEYsT0FBTztRQUNQcFQsUUFBUTBTLE1BQU0xUyxNQUFNO1FBQ3BCc1ksV0FBVztJQUNiO0lBQ0EsT0FBT0Q7QUFDVDtBQUVBLE1BQU1FLGFBQWE3RixDQUFBQSxRQUFTQSxNQUFNeUQsWUFBWSxLQUFLO0FBQ25ELE1BQU1xQyxzQkFBc0IsQ0FBQzlGLE9BQU85RSxTQUFTNks7SUFDM0MsTUFBTTdGLGFBQWE4RCxrQkFBa0JoRSxNQUFNRSxVQUFVLEVBQUVoRjtJQUN2RCxJQUFJLENBQUMySyxXQUFXN0YsVUFBVStGLG1CQUFtQjtRQUMzQyxPQUFPOVksT0FBTztZQUNaK1M7WUFDQUU7UUFDRjtJQUNGO0lBQ0EsT0FBT3NELFlBQVk7UUFDakJ4RDtRQUNBRTtJQUNGO0FBQ0Y7QUFDQSxTQUFTOEYsd0JBQXdCaEcsS0FBSztJQUNwQyxJQUFJQSxNQUFNN1UsVUFBVSxJQUFJNlUsTUFBTXlELFlBQVksS0FBSyxRQUFRO1FBQ3JELE9BQU87WUFDTCxHQUFHekQsS0FBSztZQUNSbEQsbUJBQW1CO1FBQ3JCO0lBQ0Y7SUFDQSxPQUFPa0Q7QUFDVDtBQUNBLE1BQU1pRyxTQUFTO0lBQ2J2RixPQUFPO0lBQ1B3RixXQUFXO0lBQ1hDLGFBQWE7QUFDZjtBQUNBLElBQUlDLFVBQVcsU0FBVXBHLEtBQUssRUFBRXFHLE1BQU07SUFDcEMsSUFBSXJHLFVBQVUsS0FBSyxHQUFHO1FBQ3BCQSxRQUFRaUc7SUFDVjtJQUNBLElBQUlJLE9BQU8zZCxJQUFJLEtBQUssU0FBUztRQUMzQixPQUFPO1lBQ0wsR0FBR3VkLE1BQU07WUFDVEUsYUFBYTtRQUNmO0lBQ0Y7SUFDQSxJQUFJRSxPQUFPM2QsSUFBSSxLQUFLLG1CQUFtQjtRQUNyQyxDQUFFc1gsQ0FBQUEsTUFBTVUsS0FBSyxLQUFLLE1BQUssSUFBSzVZLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sa0RBQWtEQSxDQUFnQixHQUFHLEtBQUs7UUFDL0osTUFBTSxFQUNKNFYsUUFBUSxFQUNSeEQsZUFBZSxFQUNmdkcsUUFBUSxFQUNSNEosVUFBVSxFQUNWdUQsWUFBWSxFQUNiLEdBQUc0QyxPQUFPQyxPQUFPO1FBQ2xCLE1BQU1qVSxZQUFZNk4sV0FBV3BPLFVBQVUsQ0FBQ3VPLFNBQVNoTyxTQUFTLENBQUN6RixFQUFFLENBQUM7UUFDOUQsTUFBTXdULE9BQU9GLFdBQVd6TyxVQUFVLENBQUM0TyxTQUFTcFAsU0FBUyxDQUFDckUsRUFBRSxDQUFDO1FBQ3pELE1BQU1zUCxTQUFTO1lBQ2JzRSxXQUFXM0Q7WUFDWDBELGlCQUFpQmxPLFVBQVU2SixNQUFNLENBQUN6QyxTQUFTLENBQUNELE1BQU07WUFDbERuUyxRQUFRb0c7UUFDVjtRQUNBLE1BQU00RCxVQUFVO1lBQ2Q2SztZQUNBeEwsTUFBTTtnQkFDSjhQLFdBQVc1UyxJQUFJc08sT0FBT3NFLFNBQVMsRUFBRWxLLFNBQVN6RyxNQUFNLENBQUN3QixPQUFPO2dCQUN4RGtQLGlCQUFpQjNTLElBQUlzTyxPQUFPc0UsU0FBUyxFQUFFbEssU0FBU3pHLE1BQU0sQ0FBQ3dCLE9BQU87Z0JBQzlEaEssUUFBUXVHLElBQUlzTyxPQUFPc0UsU0FBUyxFQUFFbEssU0FBU3pHLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDNUgsS0FBSztZQUMxRDtRQUNGO1FBQ0EsTUFBTXFlLHdCQUF3QnhVLGdCQUFnQm1PLFdBQVd6TyxVQUFVLEVBQUUrVSxLQUFLLENBQUN4VCxDQUFBQSxPQUFRLENBQUNBLEtBQUt5VCxhQUFhO1FBQ3RHLE1BQU0sRUFDSi9ULE1BQU0sRUFDTjZGLGFBQWEsRUFDZCxHQUFHcUwsY0FBYztZQUNoQnZSO1lBQ0ErTjtZQUNBdE8sWUFBWW9PLFdBQVdwTyxVQUFVO1lBQ2pDd0U7UUFDRjtRQUNBLE1BQU1qSixTQUFTO1lBQ2JxVCxPQUFPO1lBQ1B2VixZQUFZO1lBQ1prVjtZQUNBb0Q7WUFDQXZEO1lBQ0E3TztZQUNBRSxTQUFTRjtZQUNUa1Y7WUFDQTdUO1lBQ0E2RjtZQUNBa04sY0FBYy9TO1lBQ2Q0RDtZQUNBd0csbUJBQW1CO1lBQ25COUYsb0JBQW9CO1FBQ3RCO1FBQ0EsT0FBTzNKO0lBQ1Q7SUFDQSxJQUFJZ1osT0FBTzNkLElBQUksS0FBSyx1QkFBdUI7UUFDekMsSUFBSXNYLE1BQU1VLEtBQUssS0FBSyxnQkFBZ0JWLE1BQU1VLEtBQUssS0FBSyxnQkFBZ0I7WUFDbEUsT0FBT1Y7UUFDVDtRQUNBLENBQUVBLENBQUFBLE1BQU1VLEtBQUssS0FBSyxVQUFTLElBQUs1WSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsbUNBQW1DLEVBQUV1VixNQUFNVSxLQUFLLENBQUMsQ0FBQyxJQUFJalcsQ0FBZ0IsR0FBRyxLQUFLO1FBQ3hLLE1BQU00QyxTQUFTO1lBQ2IsR0FBRzJTLEtBQUs7WUFDUlUsT0FBTztRQUNUO1FBQ0EsT0FBT3JUO0lBQ1Q7SUFDQSxJQUFJZ1osT0FBTzNkLElBQUksS0FBSywwQkFBMEI7UUFDNUMsQ0FBRXNYLENBQUFBLE1BQU1VLEtBQUssS0FBSyxnQkFBZ0JWLE1BQU1VLEtBQUssS0FBSyxjQUFhLElBQUs1WSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsV0FBVyxFQUFFNGIsT0FBTzNkLElBQUksQ0FBQyxtQkFBbUIsRUFBRXNYLE1BQU1VLEtBQUssQ0FBQyxDQUFDLElBQUlqVyxDQUFnQixHQUFHLEtBQUs7UUFDck4sT0FBT3dhLDhCQUE4QjtZQUNuQ2pGO1lBQ0FrRixXQUFXbUIsT0FBT0MsT0FBTztRQUMzQjtJQUNGO0lBQ0EsSUFBSUQsT0FBTzNkLElBQUksS0FBSyxRQUFRO1FBQzFCLElBQUlzWCxNQUFNVSxLQUFLLEtBQUssZ0JBQWdCO1lBQ2xDLE9BQU9WO1FBQ1Q7UUFDQSxDQUFDUyxrQkFBa0JULFNBQVNsWSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsRUFBRTRiLE9BQU8zZCxJQUFJLENBQUMsd0JBQXdCLEVBQUVzWCxNQUFNVSxLQUFLLENBQUMsQ0FBQyxJQUFJalcsQ0FBZ0IsR0FBRyxLQUFLO1FBQ3ZLLE1BQU0sRUFDSnlSLFFBQVFXLGVBQWUsRUFDeEIsR0FBR3dKLE9BQU9DLE9BQU87UUFDbEIsSUFBSXRZLFVBQVU2TyxpQkFBaUJtRCxNQUFNek8sT0FBTyxDQUFDMkssTUFBTSxDQUFDc0UsU0FBUyxHQUFHO1lBQzlELE9BQU9SO1FBQ1Q7UUFDQSxPQUFPL1MsT0FBTztZQUNaK1M7WUFDQW5EO1lBQ0FuSyxRQUFRbVQsV0FBVzdGLFNBQVNBLE1BQU10TixNQUFNLEdBQUc7UUFDN0M7SUFDRjtJQUNBLElBQUkyVCxPQUFPM2QsSUFBSSxLQUFLLDJCQUEyQjtRQUM3QyxJQUFJc1gsTUFBTVUsS0FBSyxLQUFLLGdCQUFnQjtZQUNsQyxPQUFPc0Ysd0JBQXdCaEc7UUFDakM7UUFDQSxJQUFJQSxNQUFNVSxLQUFLLEtBQUssY0FBYztZQUNoQyxPQUFPc0Ysd0JBQXdCaEc7UUFDakM7UUFDQSxDQUFDUyxrQkFBa0JULFNBQVNsWSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsRUFBRTRiLE9BQU8zZCxJQUFJLENBQUMsd0JBQXdCLEVBQUVzWCxNQUFNVSxLQUFLLENBQUMsQ0FBQyxJQUFJalcsQ0FBZ0IsR0FBRyxLQUFLO1FBQ3ZLLE1BQU0sRUFDSm1DLEVBQUUsRUFDRnNFLFNBQVMsRUFDVixHQUFHbVYsT0FBT0MsT0FBTztRQUNsQixNQUFNNVgsU0FBU3NSLE1BQU1FLFVBQVUsQ0FBQ3pPLFVBQVUsQ0FBQzdFLEdBQUc7UUFDOUMsSUFBSSxDQUFDOEIsUUFBUTtZQUNYLE9BQU9zUjtRQUNUO1FBQ0EsTUFBTXJQLFdBQVdLLGdCQUFnQnRDLFFBQVF3QztRQUN6QyxPQUFPNFUsb0JBQW9COUYsT0FBT3JQLFVBQVU7SUFDOUM7SUFDQSxJQUFJMFYsT0FBTzNkLElBQUksS0FBSywrQkFBK0I7UUFDakQsSUFBSXNYLE1BQU1VLEtBQUssS0FBSyxnQkFBZ0I7WUFDbEMsT0FBT1Y7UUFDVDtRQUNBLENBQUNTLGtCQUFrQlQsU0FBU2xZLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQywyQ0FBMkMsRUFBRXVWLE1BQU1VLEtBQUssQ0FBQyxDQUFDLElBQUlqVyxDQUFnQixHQUFHLEtBQUs7UUFDNUssTUFBTSxFQUNKbUMsRUFBRSxFQUNGK1AsU0FBUyxFQUNWLEdBQUcwSixPQUFPQyxPQUFPO1FBQ2xCLE1BQU01WCxTQUFTc1IsTUFBTUUsVUFBVSxDQUFDek8sVUFBVSxDQUFDN0UsR0FBRztRQUM5QyxDQUFDOEIsU0FBUzVHLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQywwQkFBMEIsRUFBRW1DLEdBQUcsNkJBQTZCLENBQUMsSUFBSW5DLENBQWdCLEdBQUcsS0FBSztRQUM3SixDQUFFaUUsQ0FBQUEsT0FBT2lPLFNBQVMsS0FBS0EsU0FBUSxJQUFLN1UsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLHFDQUFxQyxFQUFFaWMsT0FBTy9KLFdBQVc7d0JBQ25JLEVBQUUrSixPQUFPaFksT0FBT2lPLFNBQVMsRUFBRSxDQUFDLElBQUlsUyxDQUFnQixHQUFHLEtBQUs7UUFDNUUsTUFBTXlRLFVBQVU7WUFDZCxHQUFHeE0sTUFBTTtZQUNUaU87UUFDRjtRQUNBLE9BQU9tSixvQkFBb0I5RixPQUFPOUUsU0FBUztJQUM3QztJQUNBLElBQUltTCxPQUFPM2QsSUFBSSxLQUFLLHVDQUF1QztRQUN6RCxJQUFJc1gsTUFBTVUsS0FBSyxLQUFLLGdCQUFnQjtZQUNsQyxPQUFPVjtRQUNUO1FBQ0EsQ0FBQ1Msa0JBQWtCVCxTQUFTbFksS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLDJDQUEyQyxFQUFFdVYsTUFBTVUsS0FBSyxDQUFDLENBQUMsSUFBSWpXLENBQWdCLEdBQUcsS0FBSztRQUM1SyxNQUFNLEVBQ0ptQyxFQUFFLEVBQ0Z5RyxnQkFBZ0IsRUFDakIsR0FBR2dULE9BQU9DLE9BQU87UUFDbEIsTUFBTTVYLFNBQVNzUixNQUFNRSxVQUFVLENBQUN6TyxVQUFVLENBQUM3RSxHQUFHO1FBQzlDLENBQUM4QixTQUFTNUcsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLDBCQUEwQixFQUFFbUMsR0FBRyxzQ0FBc0MsQ0FBQyxJQUFJbkMsQ0FBZ0IsR0FBRyxLQUFLO1FBQ3RLLENBQUVpRSxDQUFBQSxPQUFPMkUsZ0JBQWdCLEtBQUtBLGdCQUFlLElBQUt2TCxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsNENBQTRDLEVBQUVpYyxPQUFPclQsa0JBQWtCO3dCQUMvSixFQUFFcVQsT0FBT2hZLE9BQU8yRSxnQkFBZ0IsRUFBRSxDQUFDLElBQUk1SSxDQUFnQixHQUFHLEtBQUs7UUFDbkYsTUFBTXlRLFVBQVU7WUFDZCxHQUFHeE0sTUFBTTtZQUNUMkU7UUFDRjtRQUNBLE9BQU95UyxvQkFBb0I5RixPQUFPOUUsU0FBUztJQUM3QztJQUNBLElBQUltTCxPQUFPM2QsSUFBSSxLQUFLLHlCQUF5QjtRQUMzQyxJQUFJc1gsTUFBTVUsS0FBSyxLQUFLLGtCQUFrQlYsTUFBTVUsS0FBSyxLQUFLLGtCQUFrQjtZQUN0RSxPQUFPVjtRQUNUO1FBQ0EsQ0FBQ1Msa0JBQWtCVCxTQUFTbFksS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLCtCQUErQixFQUFFdVYsTUFBTVUsS0FBSyxDQUFDLENBQUMsSUFBSWpXLENBQWdCLEdBQUcsS0FBSztRQUNoSyxDQUFDdVYsTUFBTXVHLHFCQUFxQixHQUFHemUsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxpRUFBaUVBLENBQWdCLEdBQUcsS0FBSztRQUNqTCxNQUFNeUcsWUFBWW1WLE9BQU9DLE9BQU8sQ0FBQ3BWLFNBQVM7UUFDMUMsSUFBSWxELFVBQVVnUyxNQUFNMUosUUFBUSxDQUFDekcsTUFBTSxDQUFDMEIsT0FBTyxFQUFFTCxZQUFZO1lBQ3ZELE9BQU84VSx3QkFBd0JoRztRQUNqQztRQUNBLE1BQU0xSixXQUFXMkUsZUFBZStFLE1BQU0xSixRQUFRLEVBQUVwRjtRQUNoRCxJQUFJMlUsV0FBVzdGLFFBQVE7WUFDckIsT0FBT3dELFlBQVk7Z0JBQ2pCeEQ7Z0JBQ0ExSjtZQUNGO1FBQ0Y7UUFDQSxPQUFPckosT0FBTztZQUNaK1M7WUFDQTFKO1FBQ0Y7SUFDRjtJQUNBLElBQUkrUCxPQUFPM2QsSUFBSSxLQUFLLDhCQUE4QjtRQUNoRCxJQUFJLENBQUMrWCxrQkFBa0JULFFBQVE7WUFDN0IsT0FBT0E7UUFDVDtRQUNBLE1BQU1kLFlBQVltSCxPQUFPQyxPQUFPLENBQUNwSCxTQUFTO1FBQzFDLElBQUlsUixVQUFVa1IsV0FBV2MsTUFBTTFKLFFBQVEsQ0FBQ3pHLE1BQU0sQ0FBQ1gsR0FBRyxHQUFHO1lBQ25ELE9BQU84UTtRQUNUO1FBQ0EsTUFBTW5CLGdCQUFnQjtZQUNwQixHQUFHbUIsTUFBTTFKLFFBQVE7WUFDakJ6RyxRQUFRO2dCQUNOLEdBQUdtUSxNQUFNMUosUUFBUSxDQUFDekcsTUFBTTtnQkFDeEJYLEtBQUtnUTtZQUNQO1FBQ0Y7UUFDQSxPQUFPO1lBQ0wsR0FBR2MsS0FBSztZQUNSMUosVUFBVXVJO1FBQ1o7SUFDRjtJQUNBLElBQUl3SCxPQUFPM2QsSUFBSSxLQUFLLGFBQWEyZCxPQUFPM2QsSUFBSSxLQUFLLGVBQWUyZCxPQUFPM2QsSUFBSSxLQUFLLGVBQWUyZCxPQUFPM2QsSUFBSSxLQUFLLGNBQWM7UUFDM0gsSUFBSXNYLE1BQU1VLEtBQUssS0FBSyxnQkFBZ0JWLE1BQU1VLEtBQUssS0FBSyxnQkFBZ0I7WUFDbEUsT0FBT1Y7UUFDVDtRQUNBLENBQUVBLENBQUFBLE1BQU1VLEtBQUssS0FBSyxVQUFTLElBQUs1WSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsRUFBRTRiLE9BQU8zZCxJQUFJLENBQUMscUNBQXFDLENBQUMsSUFBSStCLENBQWdCLEdBQUcsS0FBSztRQUMxSyxNQUFNNEMsU0FBUzBTLGdCQUFnQjtZQUM3QkM7WUFDQXRYLE1BQU0yZCxPQUFPM2QsSUFBSTtRQUNuQjtRQUNBLElBQUksQ0FBQzJFLFFBQVE7WUFDWCxPQUFPMlM7UUFDVDtRQUNBLE9BQU8vUyxPQUFPO1lBQ1orUztZQUNBdE4sUUFBUXJGLE9BQU9xRixNQUFNO1lBQ3JCbUssaUJBQWlCeFAsT0FBT3dQLGVBQWU7WUFDdkNDLG1CQUFtQnpQLE9BQU95UCxpQkFBaUI7UUFDN0M7SUFDRjtJQUNBLElBQUl1SixPQUFPM2QsSUFBSSxLQUFLLGdCQUFnQjtRQUNsQyxNQUFNNEUsU0FBUytZLE9BQU9DLE9BQU8sQ0FBQ2haLE1BQU07UUFDcEMsQ0FBRTBTLENBQUFBLE1BQU1VLEtBQUssS0FBSyxZQUFXLElBQUs1WSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHlFQUF5RUEsQ0FBZ0IsR0FBRyxLQUFLO1FBQzVMLE1BQU1rYyxXQUFXO1lBQ2YsR0FBRzNHLEtBQUs7WUFDUlUsT0FBTztZQUNQa0YsV0FBVztZQUNYdFk7UUFDRjtRQUNBLE9BQU9xWjtJQUNUO0lBQ0EsSUFBSU4sT0FBTzNkLElBQUksS0FBSyxnQkFBZ0I7UUFDbEMsTUFBTSxFQUNKd2QsU0FBUyxFQUNUVSxZQUFZLEVBQ1pDLG1CQUFtQixFQUNwQixHQUFHUixPQUFPQyxPQUFPO1FBQ2xCLENBQUV0RyxDQUFBQSxNQUFNVSxLQUFLLEtBQUssY0FBY1YsTUFBTVUsS0FBSyxLQUFLLGNBQWEsSUFBSzVZLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQywrQkFBK0IsRUFBRXVWLE1BQU1VLEtBQUssQ0FBQyxDQUFDLElBQUlqVyxDQUFnQixHQUFHLEtBQUs7UUFDdE0sTUFBTTRDLFNBQVM7WUFDYnFULE9BQU87WUFDUHdGO1lBQ0FVO1lBQ0FDO1lBQ0EzRyxZQUFZRixNQUFNRSxVQUFVO1FBQzlCO1FBQ0EsT0FBTzdTO0lBQ1Q7SUFDQSxJQUFJZ1osT0FBTzNkLElBQUksS0FBSyxpQkFBaUI7UUFDbkMsTUFBTSxFQUNKd2QsU0FBUyxFQUNWLEdBQUdHLE9BQU9DLE9BQU87UUFDbEIsT0FBTztZQUNMNUYsT0FBTztZQUNQd0Y7WUFDQUMsYUFBYTtRQUNmO0lBQ0Y7SUFDQSxPQUFPbkc7QUFDVDtBQUVBLE1BQU04Ryx1QkFBdUJsUSxDQUFBQSxPQUFTO1FBQ3BDbE8sTUFBTTtRQUNONGQsU0FBUzFQO0lBQ1g7QUFDQSxNQUFNbVEsU0FBU25RLENBQUFBLE9BQVM7UUFDdEJsTyxNQUFNO1FBQ040ZCxTQUFTMVA7SUFDWDtBQUNBLE1BQU1vUSxpQkFBaUJwUSxDQUFBQSxPQUFTO1FBQzlCbE8sTUFBTTtRQUNONGQsU0FBUzFQO0lBQ1g7QUFDQSxNQUFNcVEsdUJBQXVCclEsQ0FBQUEsT0FBUztRQUNwQ2xPLE1BQU07UUFDTjRkLFNBQVMxUDtJQUNYO0FBQ0EsTUFBTXNRLHFCQUFxQixJQUFPO1FBQ2hDeGUsTUFBTTtRQUNONGQsU0FBUztJQUNYO0FBQ0EsTUFBTWEsd0JBQXdCdlEsQ0FBQUEsT0FBUztRQUNyQ2xPLE1BQU07UUFDTjRkLFNBQVMxUDtJQUNYO0FBQ0EsTUFBTXdRLDJCQUEyQnhRLENBQUFBLE9BQVM7UUFDeENsTyxNQUFNO1FBQ040ZCxTQUFTMVA7SUFDWDtBQUNBLE1BQU15USxrQ0FBa0N6USxDQUFBQSxPQUFTO1FBQy9DbE8sTUFBTTtRQUNONGQsU0FBUzFQO0lBQ1g7QUFDQSxNQUFNMFEsT0FBTzFRLENBQUFBLE9BQVM7UUFDcEJsTyxNQUFNO1FBQ040ZCxTQUFTMVA7SUFDWDtBQUNBLE1BQU0yUSxxQkFBcUIzUSxDQUFBQSxPQUFTO1FBQ2xDbE8sTUFBTTtRQUNONGQsU0FBUzFQO0lBQ1g7QUFDQSxNQUFNNFEsMEJBQTBCNVEsQ0FBQUEsT0FBUztRQUN2Q2xPLE1BQU07UUFDTjRkLFNBQVMxUDtJQUNYO0FBQ0EsTUFBTTZRLFNBQVMsSUFBTztRQUNwQi9lLE1BQU07UUFDTjRkLFNBQVM7SUFDWDtBQUNBLE1BQU1vQixXQUFXLElBQU87UUFDdEJoZixNQUFNO1FBQ040ZCxTQUFTO0lBQ1g7QUFDQSxNQUFNcUIsWUFBWSxJQUFPO1FBQ3ZCamYsTUFBTTtRQUNONGQsU0FBUztJQUNYO0FBQ0EsTUFBTXNCLFdBQVcsSUFBTztRQUN0QmxmLE1BQU07UUFDTjRkLFNBQVM7SUFDWDtBQUNBLE1BQU11QixRQUFRLElBQU87UUFDbkJuZixNQUFNO1FBQ040ZCxTQUFTO0lBQ1g7QUFDQSxNQUFNd0IsY0FBY2xSLENBQUFBLE9BQVM7UUFDM0JsTyxNQUFNO1FBQ040ZCxTQUFTMVA7SUFDWDtBQUNBLE1BQU1tUixlQUFlblIsQ0FBQUEsT0FBUztRQUM1QmxPLE1BQU07UUFDTjRkLFNBQVMxUDtJQUNYO0FBQ0EsTUFBTW9SLFNBQVNwUixDQUFBQSxPQUFTO1FBQ3RCbE8sTUFBTTtRQUNONGQsU0FBUzFQO0lBQ1g7QUFDQSxNQUFNK08sY0FBYy9PLENBQUFBLE9BQVM7UUFDM0JsTyxNQUFNO1FBQ040ZCxTQUFTMVA7SUFDWDtBQUNBLE1BQU1xUix3QkFBd0IsSUFBTztRQUNuQ3ZmLE1BQU07UUFDTjRkLFNBQVM7SUFDWDtBQUVBLFNBQVM0QixhQUFhL1UsaUJBQWlCO0lBQ3JDLElBQUlBLGtCQUFrQk8sTUFBTSxJQUFJLEdBQUc7UUFDakM7SUFDRjtJQUNBLE1BQU15VSxVQUFVaFYsa0JBQWtCMUosR0FBRyxDQUFDc0ssQ0FBQUEsSUFBS0EsRUFBRW5DLFVBQVUsQ0FBQzNGLEtBQUs7SUFDN0QsTUFBTW1jLFNBQVMsQ0FBQztJQUNoQixJQUFLLElBQUk5TSxJQUFJLEdBQUdBLElBQUk2TSxRQUFRelUsTUFBTSxFQUFFNEgsSUFBSztRQUN2QyxNQUFNL0osVUFBVTRXLE9BQU8sQ0FBQzdNLEVBQUU7UUFDMUIsTUFBTTNKLFdBQVd3VyxPQUFPLENBQUM3TSxJQUFJLEVBQUU7UUFDL0IsSUFBSS9KLFlBQVlJLFdBQVcsR0FBRztZQUM1QnlXLE1BQU0sQ0FBQzdXLFFBQVEsR0FBRztRQUNwQjtJQUNGO0lBQ0EsSUFBSSxDQUFDUyxPQUFPcVcsSUFBSSxDQUFDRCxRQUFRMVUsTUFBTSxFQUFFO1FBQy9CO0lBQ0Y7SUFDQSxNQUFNNFUsWUFBWUgsUUFBUTFlLEdBQUcsQ0FBQ3dDLENBQUFBO1FBQzVCLE1BQU1zYyxXQUFXL1AsUUFBUTRQLE1BQU0sQ0FBQ25jLE1BQU07UUFDdEMsT0FBT3NjLFdBQVcsQ0FBQyxHQUFHLEVBQUV0YyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsTUFBTSxDQUFDO0lBQy9DLEdBQUd1YyxJQUFJLENBQUM7SUF0a0ZWLEtBdWtGdUMsR0FBRzNmLFFBQVEsQ0FBQzs7Ozs7SUFLL0MsRUFBRXlmLFVBQVU7RUFDZCxDQUFDLElBQUksQ0FBTTtBQUNiO0FBQ0EsU0FBU0csbUJBQW1CcEksUUFBUSxFQUFFSCxVQUFVO0lBQzlDLElBQUlwWSxJQUF5QixFQUFjO1FBQ3pDLE1BQU1xTCxvQkFBb0JoQiw2QkFBNkJrTyxTQUFTcFAsU0FBUyxDQUFDckUsRUFBRSxFQUFFc1QsV0FBV3BPLFVBQVU7UUFDbkdvVyxhQUFhL1U7SUFDZjtBQUNGO0FBRUEsSUFBSXVWLE9BQVFDLENBQUFBLFVBQVdsWSxDQUFBQTtRQUNyQixJQUFJLEVBQ0ZtWSxRQUFRLEVBQ1JDLFFBQVEsRUFDVCxHQUFHcFk7UUFDSixPQUFPcVksQ0FBQUEsT0FBUXpDLENBQUFBO2dCQUNiLElBQUlBLE9BQU8zZCxJQUFJLEtBQUssUUFBUTtvQkFDMUJvZ0IsS0FBS3pDO29CQUNMO2dCQUNGO2dCQUNBLE1BQU0sRUFDSnpaLEVBQUUsRUFDRmlRLGVBQWUsRUFDZjRHLFlBQVksRUFDYixHQUFHNEMsT0FBT0MsT0FBTztnQkFDbEIsTUFBTWpWLFVBQVV1WDtnQkFDaEIsSUFBSXZYLFFBQVFxUCxLQUFLLEtBQUssa0JBQWtCO29CQUN0Q21JLFNBQVNkLGFBQWE7d0JBQ3BCN0IsV0FBVzdVLFFBQVE2VSxTQUFTO29CQUM5QjtnQkFDRjtnQkFDQSxDQUFFMEMsQ0FBQUEsV0FBV2xJLEtBQUssS0FBSyxNQUFLLElBQUs1WSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHNDQUFzQ0EsQ0FBZ0IsR0FBRyxLQUFLO2dCQUN4Sm9lLFNBQVNoQjtnQkFDVGdCLFNBQVMvQixxQkFBcUI7b0JBQzVCL1osYUFBYUg7b0JBQ2I2VztnQkFDRjtnQkFDQSxNQUFNc0YsZ0JBQWdCO29CQUNwQkMsMEJBQTBCdkYsaUJBQWlCO2dCQUM3QztnQkFDQSxNQUFNd0YsVUFBVTtvQkFDZGxjLGFBQWFIO29CQUNibWM7Z0JBQ0Y7Z0JBQ0EsTUFBTSxFQUNKMUksUUFBUSxFQUNSSCxVQUFVLEVBQ1Y1SixRQUFRLEVBQ1QsR0FBR3FTLFFBQVFPLGVBQWUsQ0FBQ0Q7Z0JBQzVCUixtQkFBbUJwSSxVQUFVSDtnQkFDN0IySSxTQUFTN0IsZUFBZTtvQkFDdEIzRztvQkFDQUg7b0JBQ0FyRDtvQkFDQTRHO29CQUNBbk47Z0JBQ0Y7WUFDRjtJQUNGO0FBRUEsSUFBSTZTLFFBQVNSLENBQUFBLFVBQVcsSUFBTUcsQ0FBQUEsT0FBUXpDLENBQUFBO2dCQUNwQyxJQUFJQSxPQUFPM2QsSUFBSSxLQUFLLG1CQUFtQjtvQkFDckNpZ0IsUUFBUVMsUUFBUTtnQkFDbEI7Z0JBQ0EsSUFBSS9DLE9BQU8zZCxJQUFJLEtBQUssZ0JBQWdCO29CQUNsQ2lnQixRQUFRVSxRQUFRLENBQUNoRCxPQUFPQyxPQUFPLENBQUNKLFNBQVMsQ0FBQzdZLE1BQU0sQ0FBQ0MsTUFBTTtnQkFDekQ7Z0JBQ0EsSUFBSStZLE9BQU8zZCxJQUFJLEtBQUssV0FBVzJkLE9BQU8zZCxJQUFJLEtBQUssaUJBQWlCO29CQUM5RGlnQixRQUFRVyxPQUFPO2dCQUNqQjtnQkFDQVIsS0FBS3pDO1lBQ1A7QUFFQSxNQUFNa0QsU0FBUztJQUNiQyxhQUFhO0lBQ2JDLE1BQU07QUFDUjtBQUNBLE1BQU01YyxVQUFVO0lBQ2Q2YyxTQUFTO1FBQ1BELE1BQU07UUFDTkUsV0FBVztJQUNiO0lBQ0FDLE9BQU87UUFDTEgsTUFBTTtJQUNSO0FBQ0Y7QUFDQSxNQUFNSSxVQUFVO0lBQ2RMLGFBQWE7SUFDYk0sYUFBYTtJQUNiQyxhQUFhO0FBQ2Y7QUFDQSxNQUFNQyxvQkFBb0IsQ0FBQyxFQUFFSCxRQUFRTCxXQUFXLENBQUMsRUFBRSxFQUFFRCxPQUFPQyxXQUFXLENBQUMsQ0FBQztBQUN6RSxNQUFNUyxjQUFjO0lBQ2xCQyxPQUFPLENBQUMsUUFBUSxFQUFFRixrQkFBa0IsQ0FBQztJQUNyQ0csTUFBTSxDQUFDLFVBQVUsRUFBRUgsa0JBQWtCLFVBQVUsRUFBRUEsa0JBQWtCLENBQUM7SUFDcEVQLE1BQU1XLENBQUFBO1FBQ0osTUFBTUMsU0FBUyxDQUFDLEVBQUVELFNBQVMsRUFBRSxFQUFFYixPQUFPRSxJQUFJLENBQUMsQ0FBQztRQUM1QyxPQUFPLENBQUMsVUFBVSxFQUFFWSxPQUFPLFVBQVUsRUFBRUEsT0FBTyxDQUFDO0lBQ2pEO0lBQ0FiLGFBQWEsQ0FBQyxVQUFVLEVBQUVRLGtCQUFrQixDQUFDO0lBQzdDekYsYUFBYSxDQUFDLE9BQU8sRUFBRXlGLGtCQUFrQixRQUFRLEVBQUVBLGtCQUFrQixTQUFTLEVBQUVBLGtCQUFrQixDQUFDO0FBQ3JHO0FBQ0EsTUFBTU0sU0FBU2pqQixDQUFBQSxTQUFVMkcsVUFBVTNHLFFBQVFvRyxVQUFVOGMsWUFBWSxDQUFDLFVBQVUsRUFBRWxqQixPQUFPcUcsQ0FBQyxDQUFDLElBQUksRUFBRXJHLE9BQU9zRyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQzFHLE1BQU02YyxhQUFhO0lBQ2pCRjtJQUNBYixNQUFNLENBQUNwaUIsUUFBUW9qQjtRQUNiLE1BQU1DLFlBQVlKLE9BQU9qakI7UUFDekIsSUFBSSxDQUFDcWpCLFdBQVc7WUFDZCxPQUFPSDtRQUNUO1FBQ0EsSUFBSSxDQUFDRSxhQUFhO1lBQ2hCLE9BQU9DO1FBQ1Q7UUFDQSxPQUFPLENBQUMsRUFBRUEsVUFBVSxPQUFPLEVBQUU3ZCxRQUFRK2MsS0FBSyxDQUFDSCxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3BEO0FBQ0Y7QUFFQSxNQUFNLEVBQ0pLLFdBQVcsRUFDWEMsV0FBVyxFQUNaLEdBQUdGO0FBQ0osTUFBTWMsZ0JBQWdCWixjQUFjRDtBQUNwQyxNQUFNYyx3QkFBd0I7QUFDOUIsTUFBTUMscUJBQXFCO0FBQzNCLElBQUlDLGtCQUFtQnJhLENBQUFBO0lBQ3JCLElBQUksRUFDRmMsT0FBTyxFQUNQakYsV0FBVyxFQUNYZ0IsTUFBTSxFQUNQLEdBQUdtRDtJQUNKLE1BQU1zYSxhQUFhemMsU0FBU2lELFNBQVNqRjtJQUNyQyxJQUFJeWUsY0FBYyxHQUFHO1FBQ25CLE9BQU9qQjtJQUNUO0lBQ0EsSUFBSWlCLGNBQWNILHVCQUF1QjtRQUN2QyxPQUFPYjtJQUNUO0lBQ0EsTUFBTWlCLGFBQWFELGFBQWFIO0lBQ2hDLE1BQU1SLFdBQVdOLGNBQWNhLGdCQUFnQks7SUFDL0MsTUFBTUMsZUFBZTNkLFdBQVcsV0FBVzhjLFdBQVdTLHFCQUFxQlQ7SUFDM0UsT0FBT2MsT0FBT0QsYUFBYUUsT0FBTyxDQUFDO0FBQ3JDO0FBRUEsSUFBSUMseUJBQTBCM2EsQ0FBQUE7SUFDNUIsSUFBSSxFQUNGaUMsTUFBTSxFQUNOTCxTQUFTLEVBQ1Q2TixVQUFVLEVBQ1Y1SixRQUFRLEVBQ1JpQyxhQUFhLEVBQ2QsR0FBRzlIO0lBQ0osTUFBTSxFQUNKcUIsVUFBVSxFQUNWTCxVQUFVLEVBQ1gsR0FBR3lPO0lBQ0osTUFBTTFULGNBQWNxVCxrQkFBa0JuTjtJQUN0QyxNQUFNcEcsY0FBY0UsY0FBY2lGLFVBQVUsQ0FBQ2pGLFlBQVksR0FBRztJQUM1RCxNQUFNNFQsT0FBTzNPLFVBQVUsQ0FBQ1ksVUFBVVQsVUFBVSxDQUFDcEYsV0FBVyxDQUFDO0lBQ3pELE1BQU02ZSxrQkFBa0I5SCx5QkFBeUI7UUFDL0M3UTtRQUNBTDtRQUNBUDtRQUNBeUc7UUFDQXRILFdBQVczRSxlQUFlOFQ7UUFDMUI5SjtJQUNGO0lBQ0EsTUFBTWpQLFNBQVMwRyxTQUFTc2QsaUJBQWlCaFosVUFBVTZKLE1BQU0sQ0FBQ3pDLFNBQVMsQ0FBQ0QsTUFBTTtJQUMxRSxPQUFPblM7QUFDVDtBQUVBLElBQUlpa0IsZ0JBQWlCN2EsQ0FBQUE7SUFDbkIsSUFBSSxFQUNGcUIsVUFBVSxFQUNWeEUsTUFBTSxFQUNOaWUsVUFBVSxFQUNWbkwsSUFBSSxFQUNKOUosUUFBUSxFQUNSbVAsWUFBWSxFQUNiLEdBQUdoVjtJQUNKLElBQUksQ0FBQzhhLFdBQVc1WSxFQUFFLElBQUlyRixXQUFXLFFBQVE7UUFDdkMsTUFBTWtlLHVCQUF1QmxJLFVBQVU7WUFDckN4UjtZQUNBWSxRQUFRK1M7WUFDUm5aLGFBQWE4VDtZQUNiOUo7WUFDQVUsb0JBQW9CO1FBQ3RCO1FBQ0EsT0FBTztZQUNMdEUsUUFBUThZO1lBQ1JDLHdCQUF3QjtRQUMxQjtJQUNGO0lBQ0EsSUFBSUYsV0FBVzVZLEVBQUUsQ0FBQ2pLLElBQUksS0FBSyxXQUFXO1FBQ3BDLE9BQU87WUFDTGdLLFFBQVE2WTtZQUNSRSx3QkFBd0I7UUFDMUI7SUFDRjtJQUNBLE1BQU1DLGtCQUFrQjtRQUN0QixHQUFHSCxVQUFVO1FBQ2IvWCxXQUFXWTtJQUNiO0lBQ0EsT0FBTztRQUNMMUIsUUFBUWdaO1FBQ1JELHdCQUF3QjtJQUMxQjtBQUNGO0FBRUEsTUFBTUUsaUJBQWlCbGIsQ0FBQUE7SUFDckIsSUFBSSxFQUNGbVksUUFBUSxFQUNSQyxRQUFRLEVBQ1QsR0FBR3BZO0lBQ0osT0FBT3FZLENBQUFBLE9BQVF6QyxDQUFBQTtZQUNiLElBQUlBLE9BQU8zZCxJQUFJLEtBQUssUUFBUTtnQkFDMUJvZ0IsS0FBS3pDO2dCQUNMO1lBQ0Y7WUFDQSxNQUFNckcsUUFBUTRJO1lBQ2QsTUFBTXRiLFNBQVMrWSxPQUFPQyxPQUFPLENBQUNoWixNQUFNO1lBQ3BDLElBQUkwUyxNQUFNVSxLQUFLLEtBQUssY0FBYztnQkFDaENtSSxTQUFTbEQsWUFBWTtvQkFDbkJyWTtnQkFDRjtnQkFDQTtZQUNGO1lBQ0EsSUFBSTBTLE1BQU1VLEtBQUssS0FBSyxRQUFRO2dCQUMxQjtZQUNGO1lBQ0EsTUFBTWtMLG1CQUFtQjVMLE1BQU1VLEtBQUssS0FBSyxrQkFBa0JWLE1BQU00RixTQUFTO1lBQzFFLENBQUMsQ0FBQ2dHLG1CQUFtQjlqQixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLGlFQUFpRUEsQ0FBZ0IsR0FBRyxLQUFLO1lBQ3ZLLENBQUV1VixDQUFBQSxNQUFNVSxLQUFLLEtBQUssY0FBY1YsTUFBTVUsS0FBSyxLQUFLLGNBQWEsSUFBSzVZLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyxzQkFBc0IsRUFBRXVWLE1BQU1VLEtBQUssQ0FBQyxDQUFDLElBQUlqVyxDQUFnQixHQUFHLEtBQUs7WUFDN0wsTUFBTTRWLFdBQVdMLE1BQU1LLFFBQVE7WUFDL0IsTUFBTUgsYUFBYUYsTUFBTUUsVUFBVTtZQUNuQyxNQUFNN04sWUFBWTZOLFdBQVdwTyxVQUFVLENBQUNrTyxNQUFNSyxRQUFRLENBQUNoTyxTQUFTLENBQUN6RixFQUFFLENBQUM7WUFDcEUsTUFBTSxFQUNKOEYsTUFBTSxFQUNOK1ksc0JBQXNCLEVBQ3ZCLEdBQUdILGNBQWM7Z0JBQ2hCaGU7Z0JBQ0FpZSxZQUFZdkwsTUFBTXROLE1BQU07Z0JBQ3hCNkYsZUFBZXlILE1BQU16SCxhQUFhO2dCQUNsQ2tOLGNBQWN6RixNQUFNeUYsWUFBWTtnQkFDaENyRixNQUFNSixNQUFNRSxVQUFVLENBQUN6TyxVQUFVLENBQUN1TyxNQUFNSyxRQUFRLENBQUNwUCxTQUFTLENBQUNyRSxFQUFFLENBQUM7Z0JBQzlEMEosVUFBVTBKLE1BQU0xSixRQUFRO2dCQUN4QnhFLFlBQVlrTyxNQUFNRSxVQUFVLENBQUNwTyxVQUFVO1lBQ3pDO1lBQ0EsTUFBTXhGLGNBQWNtZix5QkFBeUJoWixrQkFBa0JDLFVBQVU7WUFDekUsTUFBTTdGLFVBQVU0ZSx5QkFBeUI3WSxjQUFjRixVQUFVO1lBQ2pFLE1BQU10RyxTQUFTO2dCQUNiSCxPQUFPb1UsU0FBU2hPLFNBQVMsQ0FBQ3BHLEtBQUs7Z0JBQy9CTyxhQUFhNlQsU0FBU3BQLFNBQVMsQ0FBQ3JFLEVBQUU7WUFDcEM7WUFDQSxNQUFNUyxTQUFTO2dCQUNiTixhQUFhc0YsVUFBVVQsVUFBVSxDQUFDaEYsRUFBRTtnQkFDcENsRSxNQUFNMkosVUFBVVQsVUFBVSxDQUFDbEosSUFBSTtnQkFDL0IwRDtnQkFDQWtCO2dCQUNBK1EsTUFBTTJCLE1BQU15RCxZQUFZO2dCQUN4Qm5YO2dCQUNBTztZQUNGO1lBQ0EsTUFBTWdhLHNCQUFzQnVFLHVCQUF1QjtnQkFDakQxWTtnQkFDQUw7Z0JBQ0E2TjtnQkFDQTVKLFVBQVUwSixNQUFNMUosUUFBUTtnQkFDeEJpQyxlQUFleUgsTUFBTXpILGFBQWE7WUFDcEM7WUFDQSxNQUFNMk4sWUFBWTtnQkFDaEI3RixVQUFVTCxNQUFNSyxRQUFRO2dCQUN4QjlILGVBQWV5SCxNQUFNekgsYUFBYTtnQkFDbENsTDtnQkFDQXFGO1lBQ0Y7WUFDQSxNQUFNbVosc0JBQXNCLENBQUM3ZCxVQUFVZ1MsTUFBTXpPLE9BQU8sQ0FBQzJLLE1BQU0sQ0FBQzdVLE1BQU0sRUFBRXdmLHdCQUF3QnJPLFFBQVFuTCxPQUFPUixPQUFPO1lBQ2xILElBQUksQ0FBQ2dmLHFCQUFxQjtnQkFDeEJoRCxTQUFTZCxhQUFhO29CQUNwQjdCO2dCQUNGO2dCQUNBO1lBQ0Y7WUFDQSxNQUFNVSxlQUFla0UsZ0JBQWdCO2dCQUNuQ3ZaLFNBQVN5TyxNQUFNek8sT0FBTyxDQUFDMkssTUFBTSxDQUFDN1UsTUFBTTtnQkFDcENpRixhQUFhdWE7Z0JBQ2J2WjtZQUNGO1lBQ0EsTUFBTXNKLE9BQU87Z0JBQ1hpUTtnQkFDQUQ7Z0JBQ0FWO1lBQ0Y7WUFDQTJDLFNBQVNmLFlBQVlsUjtRQUN2QjtBQUNGO0FBQ0EsSUFBSTZTLE9BQU9rQztBQUVYLElBQUlHLGtCQUFtQixJQUFPO1FBQzVCcGUsR0FBRy9FLE9BQU9vakIsV0FBVztRQUNyQnBlLEdBQUdoRixPQUFPcWpCLFdBQVc7SUFDdkI7QUFFQSxTQUFTQyx1QkFBdUJoZixNQUFNO0lBQ3BDLE9BQU87UUFDTHBELFdBQVc7UUFDWEYsU0FBUztZQUNQdWlCLFNBQVM7WUFDVEMsU0FBUztRQUNYO1FBQ0FyaUIsSUFBSW1CLENBQUFBO1lBQ0YsSUFBSUEsTUFBTXlELE1BQU0sS0FBSy9GLFVBQVVzQyxNQUFNeUQsTUFBTSxLQUFLL0YsT0FBT3lqQixRQUFRLEVBQUU7Z0JBQy9EO1lBQ0Y7WUFDQW5mO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU29mLGtCQUFrQjViLElBQUk7SUFDN0IsSUFBSSxFQUNGNmIsY0FBYyxFQUNmLEdBQUc3YjtJQUNKLFNBQVM4YjtRQUNQRCxlQUFlUjtJQUNqQjtJQUNBLE1BQU1VLFlBQVk3a0Isb0RBQU9BLENBQUM0a0I7SUFDMUIsTUFBTTdpQixVQUFVdWlCLHVCQUF1Qk87SUFDdkMsSUFBSXppQixTQUFTZjtJQUNiLFNBQVN5akI7UUFDUCxPQUFPMWlCLFdBQVdmO0lBQ3BCO0lBQ0EsU0FBU21EO1FBQ1AsQ0FBQyxDQUFDc2dCLGFBQWEza0IsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxzREFBc0RBLENBQWdCLEdBQUcsS0FBSztRQUN0SlYsU0FBU1gsV0FBV1QsUUFBUTtZQUFDZTtTQUFRO0lBQ3ZDO0lBQ0EsU0FBU2dqQjtRQUNQLENBQUNELGFBQWEza0IsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxpREFBaURBLENBQWdCLEdBQUcsS0FBSztRQUNoSitoQixVQUFVRyxNQUFNO1FBQ2hCNWlCO1FBQ0FBLFNBQVNmO0lBQ1g7SUFDQSxPQUFPO1FBQ0xtRDtRQUNBdWdCO1FBQ0FEO0lBQ0Y7QUFDRjtBQUVBLE1BQU1HLFlBQVl2RyxDQUFBQSxTQUFVQSxPQUFPM2QsSUFBSSxLQUFLLG1CQUFtQjJkLE9BQU8zZCxJQUFJLEtBQUssa0JBQWtCMmQsT0FBTzNkLElBQUksS0FBSztBQUNqSCxNQUFNbWtCLGlCQUFpQkMsQ0FBQUE7SUFDckIsTUFBTUMsV0FBV1Ysa0JBQWtCO1FBQ2pDQyxnQkFBZ0JwYixDQUFBQTtZQUNkNGIsTUFBTWpFLFFBQVEsQ0FBQ3RCLG1CQUFtQjtnQkFDaENyVztZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU80WCxDQUFBQSxPQUFRekMsQ0FBQUE7WUFDYixJQUFJLENBQUMwRyxTQUFTTixRQUFRLE1BQU1wRyxPQUFPM2QsSUFBSSxLQUFLLG1CQUFtQjtnQkFDN0Rxa0IsU0FBUzVnQixLQUFLO1lBQ2hCO1lBQ0EsSUFBSTRnQixTQUFTTixRQUFRLE1BQU1HLFVBQVV2RyxTQUFTO2dCQUM1QzBHLFNBQVNMLElBQUk7WUFDZjtZQUNBNUQsS0FBS3pDO1FBQ1A7QUFDRjtBQUNBLElBQUkyRyxtQkFBbUJIO0FBRXZCLElBQUlJLHNCQUF1QkMsQ0FBQUE7SUFDekIsSUFBSUMsWUFBWTtJQUNoQixJQUFJQyxZQUFZO0lBQ2hCLE1BQU1DLFlBQVlDLFdBQVc7UUFDM0JGLFlBQVk7SUFDZDtJQUNBLE1BQU0vZixTQUFTL0UsQ0FBQUE7UUFDYixJQUFJNmtCLFdBQVc7WUFuOEZuQixLQW84RjJDLEdBQUd0a0IsUUFBUSxpRUFBaUUsQ0FBTTtZQUN2SDtRQUNGO1FBQ0EsSUFBSXVrQixXQUFXO1lBdjhGbkIsS0F3OEYyQyxHQUFHdmtCLFFBQVEsQ0FBQzs7O01BR2pELENBQUMsSUFBSSxDQUFNO1lBQ1g7UUFDRjtRQUNBc2tCLFlBQVk7UUFDWkQsU0FBUzVrQjtRQUNUaWxCLGFBQWFGO0lBQ2Y7SUFDQWhnQixPQUFPOGYsU0FBUyxHQUFHLElBQU1BO0lBQ3pCLE9BQU85ZjtBQUNUO0FBRUEsSUFBSW1nQixrQkFBbUI7SUFDckIsTUFBTUMsVUFBVSxFQUFFO0lBQ2xCLE1BQU1DLFVBQVVDLENBQUFBO1FBQ2QsTUFBTTFoQixRQUFRd2hCLFFBQVEzWixTQUFTLENBQUNkLENBQUFBLE9BQVFBLEtBQUsyYSxPQUFPLEtBQUtBO1FBQ3pELENBQUUxaEIsQ0FBQUEsVUFBVSxDQUFDLEtBQUtuRSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLDBCQUEwQkEsQ0FBZ0IsR0FBRyxLQUFLO1FBQzdILE1BQU0sQ0FBQ21qQixNQUFNLEdBQUdILFFBQVFJLE1BQU0sQ0FBQzVoQixPQUFPO1FBQ3RDMmhCLE1BQU1FLFFBQVE7SUFDaEI7SUFDQSxNQUFNbGdCLE1BQU05RCxDQUFBQTtRQUNWLE1BQU02akIsVUFBVUwsV0FBVyxJQUFNSSxRQUFRQztRQUN6QyxNQUFNQyxRQUFRO1lBQ1pEO1lBQ0FHLFVBQVVoa0I7UUFDWjtRQUNBMmpCLFFBQVFsVyxJQUFJLENBQUNxVztJQUNmO0lBQ0EsTUFBTS9GLFFBQVE7UUFDWixJQUFJLENBQUM0RixRQUFRL1osTUFBTSxFQUFFO1lBQ25CO1FBQ0Y7UUFDQSxNQUFNcWEsVUFBVTtlQUFJTjtTQUFRO1FBQzVCQSxRQUFRL1osTUFBTSxHQUFHO1FBQ2pCcWEsUUFBUTdqQixPQUFPLENBQUMwakIsQ0FBQUE7WUFDZEwsYUFBYUssTUFBTUQsT0FBTztZQUMxQkMsTUFBTUUsUUFBUTtRQUNoQjtJQUNGO0lBQ0EsT0FBTztRQUNMbGdCO1FBQ0FpYTtJQUNGO0FBQ0Y7QUFFQSxNQUFNbUcsb0JBQW9CLENBQUN6USxPQUFPQztJQUNoQyxJQUFJRCxTQUFTLFFBQVFDLFVBQVUsTUFBTTtRQUNuQyxPQUFPO0lBQ1Q7SUFDQSxJQUFJRCxTQUFTLFFBQVFDLFVBQVUsTUFBTTtRQUNuQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPRCxNQUFNL1EsV0FBVyxLQUFLZ1IsT0FBT2hSLFdBQVcsSUFBSStRLE1BQU10UixLQUFLLEtBQUt1UixPQUFPdlIsS0FBSztBQUNqRjtBQUNBLE1BQU1naUIsaUJBQWlCLENBQUMxUSxPQUFPQztJQUM3QixJQUFJRCxTQUFTLFFBQVFDLFVBQVUsTUFBTTtRQUNuQyxPQUFPO0lBQ1Q7SUFDQSxJQUFJRCxTQUFTLFFBQVFDLFVBQVUsTUFBTTtRQUNuQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPRCxNQUFNeFEsV0FBVyxLQUFLeVEsT0FBT3pRLFdBQVcsSUFBSXdRLE1BQU0vUSxXQUFXLEtBQUtnUixPQUFPaFIsV0FBVztBQUM3RjtBQUNBLE1BQU0waEIsa0JBQWtCLENBQUMzUSxPQUFPQztJQUM5QixJQUFJRCxVQUFVQyxRQUFRO1FBQ3BCLE9BQU87SUFDVDtJQUNBLE1BQU0yUSxtQkFBbUI1USxNQUFNbEwsU0FBUyxDQUFDekYsRUFBRSxLQUFLNFEsT0FBT25MLFNBQVMsQ0FBQ3pGLEVBQUUsSUFBSTJRLE1BQU1sTCxTQUFTLENBQUM3RixXQUFXLEtBQUtnUixPQUFPbkwsU0FBUyxDQUFDN0YsV0FBVyxJQUFJK1EsTUFBTWxMLFNBQVMsQ0FBQzNKLElBQUksS0FBSzhVLE9BQU9uTCxTQUFTLENBQUMzSixJQUFJLElBQUk2VSxNQUFNbEwsU0FBUyxDQUFDcEcsS0FBSyxLQUFLdVIsT0FBT25MLFNBQVMsQ0FBQ3BHLEtBQUs7SUFDek8sTUFBTW1pQixtQkFBbUI3USxNQUFNdE0sU0FBUyxDQUFDckUsRUFBRSxLQUFLNFEsT0FBT3ZNLFNBQVMsQ0FBQ3JFLEVBQUUsSUFBSTJRLE1BQU10TSxTQUFTLENBQUN2SSxJQUFJLEtBQUs4VSxPQUFPdk0sU0FBUyxDQUFDdkksSUFBSTtJQUNySCxPQUFPeWxCLG9CQUFvQkM7QUFDN0I7QUFFQSxNQUFNQyxjQUFjLENBQUNwSyxLQUFLbmE7SUFDeEJxQztJQUNBckM7SUFDQW9hO0FBQ0Y7QUFDQSxNQUFNb0ssZUFBZSxDQUFDak8sVUFBVWhDLE9BQVU7UUFDeEN0UixhQUFhc1QsU0FBU2hPLFNBQVMsQ0FBQ3pGLEVBQUU7UUFDbENsRSxNQUFNMlgsU0FBU3BQLFNBQVMsQ0FBQ3ZJLElBQUk7UUFDN0IwRCxRQUFRO1lBQ05JLGFBQWE2VCxTQUFTcFAsU0FBUyxDQUFDckUsRUFBRTtZQUNsQ1gsT0FBT29VLFNBQVNoTyxTQUFTLENBQUNwRyxLQUFLO1FBQ2pDO1FBQ0FvUztJQUNGO0FBQ0EsU0FBU3FQLFFBQVFhLFNBQVMsRUFBRUMsSUFBSSxFQUFFdEIsUUFBUSxFQUFFdUIsaUJBQWlCO0lBQzNELElBQUksQ0FBQ0YsV0FBVztRQUNkckIsU0FBU3VCLGtCQUFrQkQ7UUFDM0I7SUFDRjtJQUNBLE1BQU1FLGFBQWF6QixvQkFBb0JDO0lBQ3ZDLE1BQU15QixXQUFXO1FBQ2Z6QixVQUFVd0I7SUFDWjtJQUNBSCxVQUFVQyxNQUFNRztJQUNoQixJQUFJLENBQUNELFdBQVd2QixTQUFTLElBQUk7UUFDM0JELFNBQVN1QixrQkFBa0JEO0lBQzdCO0FBQ0Y7QUFDQSxJQUFJSSxlQUFnQixDQUFDQyxlQUFlM0I7SUFDbEMsTUFBTTRCLGVBQWV0QjtJQUNyQixJQUFJcEUsV0FBVztJQUNmLE1BQU0yRixnQkFBZ0IsQ0FBQ2hpQixhQUFhc1I7UUFDbEMsQ0FBQyxDQUFDK0ssV0FBV3RoQixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLDRFQUE0RUEsQ0FBZ0IsR0FBRyxLQUFLO1FBQzFLNGpCLFlBQVksbUJBQW1CO1lBQzdCLE1BQU12a0IsS0FBSytrQixnQkFBZ0JHLGVBQWU7WUFDMUMsSUFBSWxsQixJQUFJO2dCQUNOLE1BQU1tSyxTQUFTO29CQUNibEg7b0JBQ0FzUjtnQkFDRjtnQkFDQXZVLEdBQUdtSztZQUNMO1FBQ0Y7SUFDRjtJQUNBLE1BQU1nYixjQUFjLENBQUM1TyxVQUFVaEM7UUFDN0IsQ0FBQyxDQUFDK0ssV0FBV3RoQixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLDhFQUE4RUEsQ0FBZ0IsR0FBRyxLQUFLO1FBQzVLNGpCLFlBQVkscUJBQXFCO1lBQy9CLE1BQU12a0IsS0FBSytrQixnQkFBZ0JLLGlCQUFpQjtZQUM1QyxJQUFJcGxCLElBQUk7Z0JBQ05BLEdBQUd3a0IsYUFBYWpPLFVBQVVoQztZQUM1QjtRQUNGO0lBQ0Y7SUFDQSxNQUFNbFMsUUFBUSxDQUFDa1UsVUFBVWhDO1FBQ3ZCLENBQUMsQ0FBQytLLFdBQVd0aEIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyw4RUFBOEVBLENBQWdCLEdBQUcsS0FBSztRQUM1SyxNQUFNK2pCLE9BQU9GLGFBQWFqTyxVQUFVaEM7UUFDcEMrSyxXQUFXO1lBQ1QvSztZQUNBOFEsY0FBYzlPO1lBQ2QrTyxjQUFjWixLQUFLcGlCLE1BQU07WUFDekJpakIsYUFBYTtRQUNmO1FBQ0FQLGFBQWFsaEIsR0FBRyxDQUFDO1lBQ2Z5Z0IsWUFBWSxlQUFlLElBQU1YLFFBQVFtQixnQkFBZ0IzaUIsV0FBVyxFQUFFc2lCLE1BQU10QixVQUFVMWYsU0FBU3RCLFdBQVc7UUFDNUc7SUFDRjtJQUNBLE1BQU1lLFNBQVMsQ0FBQ29ULFVBQVUzTjtRQUN4QixNQUFNeEYsV0FBV3VGLGtCQUFrQkM7UUFDbkMsTUFBTTdGLFVBQVUrRixjQUFjRjtRQUM5QixDQUFDMFcsV0FBV3RoQixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLGlFQUFpRUEsQ0FBZ0IsR0FBRyxLQUFLO1FBQzlKLE1BQU02a0IscUJBQXFCLENBQUNwQixnQkFBZ0I3TixVQUFVK0ksU0FBUytGLFlBQVk7UUFDM0UsSUFBSUcsb0JBQW9CO1lBQ3RCbEcsU0FBUytGLFlBQVksR0FBRzlPO1FBQzFCO1FBQ0EsTUFBTWtQLHFCQUFxQixDQUFDdkIsa0JBQWtCNUUsU0FBU2dHLFlBQVksRUFBRWxpQjtRQUNyRSxJQUFJcWlCLG9CQUFvQjtZQUN0Qm5HLFNBQVNnRyxZQUFZLEdBQUdsaUI7UUFDMUI7UUFDQSxNQUFNc2lCLHFCQUFxQixDQUFDdkIsZUFBZTdFLFNBQVNpRyxXQUFXLEVBQUV4aUI7UUFDakUsSUFBSTJpQixvQkFBb0I7WUFDdEJwRyxTQUFTaUcsV0FBVyxHQUFHeGlCO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDeWlCLHNCQUFzQixDQUFDQyxzQkFBc0IsQ0FBQ0Msb0JBQW9CO1lBQ3JFO1FBQ0Y7UUFDQSxNQUFNaEIsT0FBTztZQUNYLEdBQUdGLGFBQWFqTyxVQUFVK0ksU0FBUy9LLElBQUksQ0FBQztZQUN4Q3hSO1lBQ0FQLGFBQWFZO1FBQ2Y7UUFDQTRoQixhQUFhbGhCLEdBQUcsQ0FBQztZQUNmeWdCLFlBQVksZ0JBQWdCLElBQU1YLFFBQVFtQixnQkFBZ0I3aEIsWUFBWSxFQUFFd2hCLE1BQU10QixVQUFVMWYsU0FBU1IsWUFBWTtRQUMvRztJQUNGO0lBQ0EsTUFBTTZhLFFBQVE7UUFDWixDQUFDdUIsV0FBV3RoQixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLDhDQUE4Q0EsQ0FBZ0IsR0FBRyxLQUFLO1FBQzNJcWtCLGFBQWFqSCxLQUFLO0lBQ3BCO0lBQ0EsTUFBTTRCLE9BQU9wYyxDQUFBQTtRQUNYLENBQUMrYixXQUFXdGhCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8saUVBQWlFQSxDQUFnQixHQUFHLEtBQUs7UUFDOUoyZSxXQUFXO1FBQ1hpRixZQUFZLGFBQWEsSUFBTVgsUUFBUW1CLGdCQUFnQnpoQixTQUFTLEVBQUVDLFFBQVE2ZixVQUFVMWYsU0FBU0osU0FBUztJQUN4RztJQUNBLE1BQU1xaUIsUUFBUTtRQUNaLElBQUksQ0FBQ3JHLFVBQVU7WUFDYjtRQUNGO1FBQ0EsTUFBTS9iLFNBQVM7WUFDYixHQUFHaWhCLGFBQWFsRixTQUFTK0YsWUFBWSxFQUFFL0YsU0FBUy9LLElBQUksQ0FBQztZQUNyRHhSLFNBQVM7WUFDVFAsYUFBYTtZQUNiZ0IsUUFBUTtRQUNWO1FBQ0FtYyxLQUFLcGM7SUFDUDtJQUNBLE9BQU87UUFDTDBoQjtRQUNBRTtRQUNBOWlCO1FBQ0FjO1FBQ0E0YTtRQUNBNEI7UUFDQWdHO0lBQ0Y7QUFDRjtBQUVBLElBQUlDLGFBQWMsQ0FBQ2IsZUFBZTNCO0lBQ2hDLE1BQU15QyxZQUFZZixhQUFhQyxlQUFlM0I7SUFDOUMsT0FBT0osQ0FBQUEsUUFBU2hFLENBQUFBLE9BQVF6QyxDQUFBQTtnQkFDdEIsSUFBSUEsT0FBTzNkLElBQUksS0FBSywwQkFBMEI7b0JBQzVDaW5CLFVBQVVaLGFBQWEsQ0FBQzFJLE9BQU9DLE9BQU8sQ0FBQ3ZaLFdBQVcsRUFBRXNaLE9BQU9DLE9BQU8sQ0FBQzdDLFlBQVk7b0JBQy9FO2dCQUNGO2dCQUNBLElBQUk0QyxPQUFPM2QsSUFBSSxLQUFLLG1CQUFtQjtvQkFDckMsTUFBTTJYLFdBQVdnRyxPQUFPQyxPQUFPLENBQUNqRyxRQUFRO29CQUN4Q3NQLFVBQVVWLFdBQVcsQ0FBQzVPLFVBQVVnRyxPQUFPQyxPQUFPLENBQUM3QyxZQUFZO29CQUMzRHFGLEtBQUt6QztvQkFDTHNKLFVBQVV4akIsS0FBSyxDQUFDa1UsVUFBVWdHLE9BQU9DLE9BQU8sQ0FBQzdDLFlBQVk7b0JBQ3JEO2dCQUNGO2dCQUNBLElBQUk0QyxPQUFPM2QsSUFBSSxLQUFLLGlCQUFpQjtvQkFDbkMsTUFBTTJFLFNBQVNnWixPQUFPQyxPQUFPLENBQUNKLFNBQVMsQ0FBQzdZLE1BQU07b0JBQzlDc2lCLFVBQVU5SCxLQUFLO29CQUNmaUIsS0FBS3pDO29CQUNMc0osVUFBVWxHLElBQUksQ0FBQ3BjO29CQUNmO2dCQUNGO2dCQUNBeWIsS0FBS3pDO2dCQUNMLElBQUlBLE9BQU8zZCxJQUFJLEtBQUssU0FBUztvQkFDM0JpbkIsVUFBVUYsS0FBSztvQkFDZjtnQkFDRjtnQkFDQSxNQUFNelAsUUFBUThNLE1BQU1sRSxRQUFRO2dCQUM1QixJQUFJNUksTUFBTVUsS0FBSyxLQUFLLFlBQVk7b0JBQzlCaVAsVUFBVTFpQixNQUFNLENBQUMrUyxNQUFNSyxRQUFRLEVBQUVMLE1BQU10TixNQUFNO2dCQUMvQztZQUNGO0FBQ0Y7QUFFQSxNQUFNa2QsZ0NBQWdDOUMsQ0FBQUEsUUFBU2hFLENBQUFBLE9BQVF6QyxDQUFBQTtZQUNyRCxJQUFJQSxPQUFPM2QsSUFBSSxLQUFLLDJCQUEyQjtnQkFDN0NvZ0IsS0FBS3pDO2dCQUNMO1lBQ0Y7WUFDQSxNQUFNckcsUUFBUThNLE1BQU1sRSxRQUFRO1lBQzVCLENBQUU1SSxDQUFBQSxNQUFNVSxLQUFLLEtBQUssZ0JBQWUsSUFBSzVZLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sOERBQThEQSxDQUFnQixHQUFHLEtBQUs7WUFDckxxaUIsTUFBTWpFLFFBQVEsQ0FBQ2QsYUFBYTtnQkFDMUI3QixXQUFXbEcsTUFBTWtHLFNBQVM7WUFDNUI7UUFDRjtBQUNBLElBQUkySixzQkFBc0JEO0FBRTFCLE1BQU1FLHVDQUF1Q2hELENBQUFBO0lBQzNDLElBQUkvaUIsU0FBUztJQUNiLElBQUlnbUIsVUFBVTtJQUNkLFNBQVNDO1FBQ1AsSUFBSUQsU0FBUztZQUNYRSxxQkFBcUJGO1lBQ3JCQSxVQUFVO1FBQ1o7UUFDQSxJQUFJaG1CLFFBQVE7WUFDVkE7WUFDQUEsU0FBUztRQUNYO0lBQ0Y7SUFDQSxPQUFPK2UsQ0FBQUEsT0FBUXpDLENBQUFBO1lBQ2IsSUFBSUEsT0FBTzNkLElBQUksS0FBSyxXQUFXMmQsT0FBTzNkLElBQUksS0FBSyxtQkFBbUIyZCxPQUFPM2QsSUFBSSxLQUFLLDJCQUEyQjtnQkFDM0dzbkI7WUFDRjtZQUNBbEgsS0FBS3pDO1lBQ0wsSUFBSUEsT0FBTzNkLElBQUksS0FBSyxnQkFBZ0I7Z0JBQ2xDO1lBQ0Y7WUFDQSxNQUFNZ0IsVUFBVTtnQkFDZEcsV0FBVztnQkFDWEYsU0FBUztvQkFDUHdpQixTQUFTO29CQUNURCxTQUFTO29CQUNUZ0UsTUFBTTtnQkFDUjtnQkFDQXBtQixJQUFJLFNBQVNxbUI7b0JBQ1gsTUFBTW5RLFFBQVE4TSxNQUFNbEUsUUFBUTtvQkFDNUIsSUFBSTVJLE1BQU1VLEtBQUssS0FBSyxrQkFBa0I7d0JBQ3BDb00sTUFBTWpFLFFBQVEsQ0FBQ1o7b0JBQ2pCO2dCQUNGO1lBQ0Y7WUFDQThILFVBQVVLLHNCQUFzQjtnQkFDOUJMLFVBQVU7Z0JBQ1ZobUIsU0FBU1gsV0FBV1QsUUFBUTtvQkFBQ2U7aUJBQVE7WUFDdkM7UUFDRjtBQUNGO0FBQ0EsSUFBSTJtQiw2QkFBNkJQO0FBRWpDLElBQUlRLDBCQUEyQjNILENBQUFBLFVBQVcsSUFBTUcsQ0FBQUEsT0FBUXpDLENBQUFBO2dCQUN0RCxJQUFJQSxPQUFPM2QsSUFBSSxLQUFLLG1CQUFtQjJkLE9BQU8zZCxJQUFJLEtBQUssV0FBVzJkLE9BQU8zZCxJQUFJLEtBQUssZ0JBQWdCO29CQUNoR2lnQixRQUFRNEgsY0FBYztnQkFDeEI7Z0JBQ0F6SCxLQUFLekM7WUFDUDtBQUVBLElBQUltSyxRQUFTN0gsQ0FBQUE7SUFDWCxJQUFJOEgsYUFBYTtJQUNqQixPQUFPLElBQU0zSCxDQUFBQSxPQUFRekMsQ0FBQUE7Z0JBQ25CLElBQUlBLE9BQU8zZCxJQUFJLEtBQUssbUJBQW1CO29CQUNyQytuQixhQUFhO29CQUNiOUgsUUFBUStILGNBQWMsQ0FBQ3JLLE9BQU9DLE9BQU8sQ0FBQ2pHLFFBQVEsQ0FBQ2hPLFNBQVMsQ0FBQ3pGLEVBQUU7b0JBQzNEa2MsS0FBS3pDO29CQUNMc0MsUUFBUWdJLHVCQUF1QjtvQkFDL0I7Z0JBQ0Y7Z0JBQ0E3SCxLQUFLekM7Z0JBQ0wsSUFBSSxDQUFDb0ssWUFBWTtvQkFDZjtnQkFDRjtnQkFDQSxJQUFJcEssT0FBTzNkLElBQUksS0FBSyxTQUFTO29CQUMzQituQixhQUFhO29CQUNiOUgsUUFBUWdJLHVCQUF1QjtvQkFDL0I7Z0JBQ0Y7Z0JBQ0EsSUFBSXRLLE9BQU8zZCxJQUFJLEtBQUssaUJBQWlCO29CQUNuQytuQixhQUFhO29CQUNiLE1BQU1wakIsU0FBU2daLE9BQU9DLE9BQU8sQ0FBQ0osU0FBUyxDQUFDN1ksTUFBTTtvQkFDOUMsSUFBSUEsT0FBT1IsT0FBTyxFQUFFO3dCQUNsQjhiLFFBQVFpSSxjQUFjLENBQUN2akIsT0FBT04sV0FBVyxFQUFFTSxPQUFPUixPQUFPLENBQUNFLFdBQVc7b0JBQ3ZFO29CQUNBNGIsUUFBUWdJLHVCQUF1QjtnQkFDakM7WUFDRjtBQUNGO0FBRUEsTUFBTUUsYUFBYXhLLENBQUFBLFNBQVVBLE9BQU8zZCxJQUFJLEtBQUssbUJBQW1CMmQsT0FBTzNkLElBQUksS0FBSyxrQkFBa0IyZCxPQUFPM2QsSUFBSSxLQUFLO0FBQ2xILElBQUlvb0IsYUFBY0MsQ0FBQUEsZUFBZ0JqRSxDQUFBQSxRQUFTaEUsQ0FBQUEsT0FBUXpDLENBQUFBO2dCQUNqRCxJQUFJd0ssV0FBV3hLLFNBQVM7b0JBQ3RCMEssYUFBYXJFLElBQUk7b0JBQ2pCNUQsS0FBS3pDO29CQUNMO2dCQUNGO2dCQUNBLElBQUlBLE9BQU8zZCxJQUFJLEtBQUssbUJBQW1CO29CQUNyQ29nQixLQUFLekM7b0JBQ0wsTUFBTXJHLFFBQVE4TSxNQUFNbEUsUUFBUTtvQkFDNUIsQ0FBRTVJLENBQUFBLE1BQU1VLEtBQUssS0FBSyxVQUFTLElBQUs1WSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHlEQUF5REEsQ0FBZ0IsR0FBRyxLQUFLO29CQUMxS3NtQixhQUFhNWtCLEtBQUssQ0FBQzZUO29CQUNuQjtnQkFDRjtnQkFDQThJLEtBQUt6QztnQkFDTDBLLGFBQWFsaEIsTUFBTSxDQUFDaWQsTUFBTWxFLFFBQVE7WUFDcEM7QUFFQSxNQUFNb0ksY0FBY2xFLENBQUFBLFFBQVNoRSxDQUFBQSxPQUFRekMsQ0FBQUE7WUFDbkN5QyxLQUFLekM7WUFDTCxJQUFJQSxPQUFPM2QsSUFBSSxLQUFLLDBCQUEwQjtnQkFDNUM7WUFDRjtZQUNBLE1BQU11b0Isa0JBQWtCbkUsTUFBTWxFLFFBQVE7WUFDdEMsSUFBSXFJLGdCQUFnQnZRLEtBQUssS0FBSyxnQkFBZ0I7Z0JBQzVDO1lBQ0Y7WUFDQSxJQUFJdVEsZ0JBQWdCckwsU0FBUyxFQUFFO2dCQUM3QjtZQUNGO1lBQ0FrSCxNQUFNakUsUUFBUSxDQUFDYixPQUFPO2dCQUNwQjFhLFFBQVEyakIsZ0JBQWdCM2pCLE1BQU07WUFDaEM7UUFDRjtBQUNBLElBQUk0akIsZ0JBQWdCRjtBQUVwQixNQUFNRyxtQkFBbUJycEIsTUFBcUgsR0FBR2EsQ0FFL0ksR0FBRzlCLDBDQUFPQTtBQUNaLElBQUlILGNBQWUrSixDQUFBQTtJQUNqQixJQUFJLEVBQ0Y2Z0IsZ0JBQWdCLEVBQ2hCQyxZQUFZLEVBQ1pDLFlBQVksRUFDWjNDLGFBQWEsRUFDYjNCLFFBQVEsRUFDUjZELFlBQVksRUFDYixHQUFHdGdCO0lBQ0osT0FBTzlKLGtEQUFhQSxDQUFDeWYsU0FBUytLLGlCQUFpQnZxQixzREFBZUEsQ0FBQ3VpQixNQUFNcUksZUFBZWxCLHdCQUF3QmdCLG1CQUFtQjVJLEtBQUs0SSxtQkFBbUI3SCxNQUFNb0cscUJBQXFCUSw0QkFBNEJhLGVBQWVKLFdBQVdDLGVBQWUvRCxrQkFBa0J3RCxNQUFNZSxlQUFlN0IsV0FBV2IsZUFBZTNCO0FBQzFUO0FBRUEsTUFBTXVFLFVBQVUsSUFBTztRQUNyQi9NLFdBQVcsQ0FBQztRQUNaWSxVQUFVLENBQUM7UUFDWFQsVUFBVSxDQUFDO0lBQ2I7QUFDQSxTQUFTNk0sZ0JBQWdCamhCLElBQUk7SUFDM0IsSUFBSSxFQUNGa2hCLFFBQVEsRUFDUjVtQixTQUFTLEVBQ1YsR0FBRzBGO0lBQ0osSUFBSW1oQixVQUFVSDtJQUNkLElBQUkxQixVQUFVO0lBQ2QsTUFBTThCLFVBQVU7UUFDZCxJQUFJOUIsU0FBUztZQUNYO1FBQ0Y7UUFDQWhsQixVQUFVbWMsa0JBQWtCO1FBQzVCNkksVUFBVUssc0JBQXNCO1lBQzlCTCxVQUFVO1lBQ1Y1akI7WUFDQSxNQUFNLEVBQ0p1WSxTQUFTLEVBQ1RZLFFBQVEsRUFDUlQsUUFBUSxFQUNULEdBQUcrTTtZQUNKLE1BQU01UyxRQUFRaE4sT0FBT3FXLElBQUksQ0FBQzNELFdBQVdqYixHQUFHLENBQUNtRCxDQUFBQSxLQUFNK2tCLFNBQVN0ZixTQUFTLENBQUN5ZixPQUFPLENBQUNsbEIsSUFBSW1sQixZQUFZLENBQUN0a0IsU0FBUzZFLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFWCxVQUFVLENBQUMzRixLQUFLLEdBQUd1RyxFQUFFWixVQUFVLENBQUMzRixLQUFLO1lBQzFKLE1BQU1pUCxVQUFVbEosT0FBT3FXLElBQUksQ0FBQ3hELFVBQVVwYixHQUFHLENBQUNtRCxDQUFBQTtnQkFDeEMsTUFBTWdoQixRQUFRK0QsU0FBUzFnQixTQUFTLENBQUM2Z0IsT0FBTyxDQUFDbGxCO2dCQUN6QyxNQUFNaUQsU0FBUytkLE1BQU03aUIsU0FBUyxDQUFDaW5CLHNCQUFzQjtnQkFDckQsT0FBTztvQkFDTHhsQixhQUFhSTtvQkFDYmlEO2dCQUNGO1lBQ0Y7WUFDQSxNQUFNeEMsU0FBUztnQkFDYnFYLFdBQVcxRjtnQkFDWHNHLFVBQVV0VCxPQUFPcVcsSUFBSSxDQUFDL0M7Z0JBQ3RCVCxVQUFVM0o7WUFDWjtZQUNBMFcsVUFBVUg7WUFDVnZOO1lBQ0FuWixVQUFVa25CLE9BQU8sQ0FBQzVrQjtRQUNwQjtJQUNGO0lBQ0EsTUFBTU8sTUFBTWdnQixDQUFBQTtRQUNWLE1BQU1oaEIsS0FBS2doQixNQUFNaGMsVUFBVSxDQUFDaEYsRUFBRTtRQUM5QmdsQixRQUFRbE4sU0FBUyxDQUFDOVgsR0FBRyxHQUFHZ2hCO1FBQ3hCZ0UsUUFBUS9NLFFBQVEsQ0FBQytJLE1BQU1oYyxVQUFVLENBQUNwRixXQUFXLENBQUMsR0FBRztRQUNqRCxJQUFJb2xCLFFBQVF0TSxRQUFRLENBQUMxWSxHQUFHLEVBQUU7WUFDeEIsT0FBT2dsQixRQUFRdE0sUUFBUSxDQUFDMVksR0FBRztRQUM3QjtRQUNBaWxCO0lBQ0Y7SUFDQSxNQUFNL2UsU0FBUzhhLENBQUFBO1FBQ2IsTUFBTWhjLGFBQWFnYyxNQUFNaGMsVUFBVTtRQUNuQ2dnQixRQUFRdE0sUUFBUSxDQUFDMVQsV0FBV2hGLEVBQUUsQ0FBQyxHQUFHO1FBQ2xDZ2xCLFFBQVEvTSxRQUFRLENBQUNqVCxXQUFXcEYsV0FBVyxDQUFDLEdBQUc7UUFDM0MsSUFBSW9sQixRQUFRbE4sU0FBUyxDQUFDOVMsV0FBV2hGLEVBQUUsQ0FBQyxFQUFFO1lBQ3BDLE9BQU9nbEIsUUFBUWxOLFNBQVMsQ0FBQzlTLFdBQVdoRixFQUFFLENBQUM7UUFDekM7UUFDQWlsQjtJQUNGO0lBQ0EsTUFBTW5GLE9BQU87UUFDWCxJQUFJLENBQUNxRCxTQUFTO1lBQ1o7UUFDRjtRQUNBRSxxQkFBcUJGO1FBQ3JCQSxVQUFVO1FBQ1Y2QixVQUFVSDtJQUNaO0lBQ0EsT0FBTztRQUNMN2pCO1FBQ0FrRjtRQUNBNFo7SUFDRjtBQUNGO0FBRUEsSUFBSXdGLGVBQWdCemhCLENBQUFBO0lBQ2xCLElBQUksRUFDRjBoQixZQUFZLEVBQ1pDLFdBQVcsRUFDWDdpQixNQUFNLEVBQ05ELEtBQUssRUFDTixHQUFHbUI7SUFDSixNQUFNeU8sWUFBWW5SLFNBQVM7UUFDekJMLEdBQUcwa0I7UUFDSHprQixHQUFHd2tCO0lBQ0wsR0FBRztRQUNEemtCLEdBQUc0QjtRQUNIM0IsR0FBRzRCO0lBQ0w7SUFDQSxNQUFNOGlCLG9CQUFvQjtRQUN4QjNrQixHQUFHYSxLQUFLVyxHQUFHLENBQUMsR0FBR2dRLFVBQVV4UixDQUFDO1FBQzFCQyxHQUFHWSxLQUFLVyxHQUFHLENBQUMsR0FBR2dRLFVBQVV2UixDQUFDO0lBQzVCO0lBQ0EsT0FBTzBrQjtBQUNUO0FBRUEsSUFBSUMscUJBQXNCO0lBQ3hCLE1BQU1DLE1BQU1uRyxTQUFTb0csZUFBZTtJQUNwQyxDQUFDRCxNQUFNenFCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sMENBQTBDQSxDQUFnQixHQUFHLEtBQUs7SUFDbEksT0FBTzhuQjtBQUNUO0FBRUEsSUFBSUUscUJBQXNCO0lBQ3hCLE1BQU1GLE1BQU1EO0lBQ1osTUFBTXBULFlBQVlnVCxhQUFhO1FBQzdCQyxjQUFjSSxJQUFJSixZQUFZO1FBQzlCQyxhQUFhRyxJQUFJSCxXQUFXO1FBQzVCOWlCLE9BQU9pakIsSUFBSUcsV0FBVztRQUN0Qm5qQixRQUFRZ2pCLElBQUlJLFlBQVk7SUFDMUI7SUFDQSxPQUFPelQ7QUFDVDtBQUVBLElBQUkwVCxjQUFlO0lBQ2pCLE1BQU0vaUIsU0FBU2ljO0lBQ2YsTUFBTTVNLFlBQVl1VDtJQUNsQixNQUFNeGpCLE1BQU1ZLE9BQU9sQyxDQUFDO0lBQ3BCLE1BQU0wQixPQUFPUSxPQUFPbkMsQ0FBQztJQUNyQixNQUFNNmtCLE1BQU1EO0lBQ1osTUFBTWhqQixRQUFRaWpCLElBQUlHLFdBQVc7SUFDN0IsTUFBTW5qQixTQUFTZ2pCLElBQUlJLFlBQVk7SUFDL0IsTUFBTXhqQixRQUFRRSxPQUFPQztJQUNyQixNQUFNRixTQUFTSCxNQUFNTTtJQUNyQixNQUFNUixRQUFRNUgsc0RBQU9BLENBQUM7UUFDcEI4SDtRQUNBSTtRQUNBRjtRQUNBQztJQUNGO0lBQ0EsTUFBTWtILFdBQVc7UUFDZnZIO1FBQ0FjLFFBQVE7WUFDTndCLFNBQVN4QjtZQUNUMEIsU0FBUzFCO1lBQ1RYLEtBQUtnUTtZQUNMcFAsTUFBTTtnQkFDSjVILE9BQU91RjtnQkFDUHNDLGNBQWN0QztZQUNoQjtRQUNGO0lBQ0Y7SUFDQSxPQUFPNkk7QUFDVDtBQUVBLElBQUl1YyxvQkFBcUJwaUIsQ0FBQUE7SUFDdkIsSUFBSSxFQUNGNFAsUUFBUSxFQUNSMEksYUFBYSxFQUNiNEksUUFBUSxFQUNULEdBQUdsaEI7SUFDSnRFO0lBQ0EsTUFBTW1LLFdBQVdzYztJQUNqQixNQUFNRSxlQUFleGMsU0FBU3pHLE1BQU0sQ0FBQzBCLE9BQU87SUFDNUMsTUFBTTZPLE9BQU9DLFNBQVNwUCxTQUFTO0lBQy9CLE1BQU1RLGFBQWFrZ0IsU0FBUzFnQixTQUFTLENBQUM4aEIsWUFBWSxDQUFDM1MsS0FBSzFYLElBQUksRUFBRWUsR0FBRyxDQUFDbWtCLENBQUFBLFFBQVNBLE1BQU03aUIsU0FBUyxDQUFDaW9CLDBCQUEwQixDQUFDRixjQUFjL0o7SUFDcEksTUFBTWpYLGFBQWE2ZixTQUFTdGYsU0FBUyxDQUFDMGdCLFlBQVksQ0FBQzFTLFNBQVNoTyxTQUFTLENBQUMzSixJQUFJLEVBQUVlLEdBQUcsQ0FBQ21rQixDQUFBQSxRQUFTQSxNQUFNbUUsWUFBWSxDQUFDZTtJQUM1RyxNQUFNNVMsYUFBYTtRQUNqQnBPLFlBQVlELGVBQWVDO1FBQzNCTCxZQUFZRCxlQUFlQztJQUM3QjtJQUNBeVM7SUFDQSxNQUFNN1csU0FBUztRQUNiNlM7UUFDQUc7UUFDQS9KO0lBQ0Y7SUFDQSxPQUFPako7QUFDVDtBQUVBLFNBQVM0bEIsb0JBQW9CdEIsUUFBUSxFQUFFdkksUUFBUSxFQUFFd0UsS0FBSztJQUNwRCxJQUFJQSxNQUFNaGMsVUFBVSxDQUFDaEYsRUFBRSxLQUFLd2MsU0FBU3hjLEVBQUUsRUFBRTtRQUN2QyxPQUFPO0lBQ1Q7SUFDQSxJQUFJZ2hCLE1BQU1oYyxVQUFVLENBQUNsSixJQUFJLEtBQUswZ0IsU0FBUzFnQixJQUFJLEVBQUU7UUFDM0MsT0FBTztJQUNUO0lBQ0EsTUFBTTBYLE9BQU91UixTQUFTMWdCLFNBQVMsQ0FBQzZnQixPQUFPLENBQUNsRSxNQUFNaGMsVUFBVSxDQUFDcEYsV0FBVztJQUNwRSxJQUFJNFQsS0FBS3hPLFVBQVUsQ0FBQ3lNLElBQUksS0FBSyxXQUFXO1FBcC9HMUMsS0FxL0d5QyxHQUFHeFYsUUFBUSxDQUFDOzJEQUNNLEVBQUUra0IsTUFBTWhjLFVBQVUsQ0FBQ2hGLEVBQUUsQ0FBQzs7OztJQUk3RSxDQUFDLElBQUksQ0FBTTtRQUNYLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLElBQUlzbUIseUJBQTBCLENBQUN2QixVQUFVNW1CO0lBQ3ZDLElBQUlvb0IsYUFBYTtJQUNqQixNQUFNeEQsWUFBWStCLGdCQUFnQjtRQUNoQzNtQixXQUFXO1lBQ1RrbkIsU0FBU2xuQixVQUFVa2Msb0JBQW9CO1lBQ3ZDQyxvQkFBb0JuYyxVQUFVbWMsa0JBQWtCO1FBQ2xEO1FBQ0F5SztJQUNGO0lBQ0EsTUFBTXZLLDJCQUEyQixDQUFDeGEsSUFBSStQO1FBQ3BDLENBQUNnVixTQUFTMWdCLFNBQVMsQ0FBQ21pQixNQUFNLENBQUN4bUIsTUFBTTlFLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQywyQ0FBMkMsRUFBRW1DLEdBQUcsd0JBQXdCLENBQUMsSUFBSW5DLENBQWdCLEdBQUcsS0FBSztRQUNoTSxJQUFJLENBQUMwb0IsWUFBWTtZQUNmO1FBQ0Y7UUFDQXBvQixVQUFVcWMsd0JBQXdCLENBQUM7WUFDakN4YTtZQUNBK1A7UUFDRjtJQUNGO0lBQ0EsTUFBTTBLLGtDQUFrQyxDQUFDemEsSUFBSXlHO1FBQzNDLElBQUksQ0FBQzhmLFlBQVk7WUFDZjtRQUNGO1FBQ0EsQ0FBQ3hCLFNBQVMxZ0IsU0FBUyxDQUFDbWlCLE1BQU0sQ0FBQ3htQixNQUFNOUUsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLGlEQUFpRCxFQUFFbUMsR0FBRyx3QkFBd0IsQ0FBQyxJQUFJbkMsQ0FBZ0IsR0FBRyxLQUFLO1FBQ3RNTSxVQUFVc2MsK0JBQStCLENBQUM7WUFDeEN6YTtZQUNBeUc7UUFDRjtJQUNGO0lBQ0EsTUFBTThULHdCQUF3QixDQUFDdmEsSUFBSXNFO1FBQ2pDLElBQUksQ0FBQ2lpQixZQUFZO1lBQ2Y7UUFDRjtRQUNBLENBQUN4QixTQUFTMWdCLFNBQVMsQ0FBQ21pQixNQUFNLENBQUN4bUIsTUFBTTlFLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyxzQ0FBc0MsRUFBRW1DLEdBQUcsd0JBQXdCLENBQUMsSUFBSW5DLENBQWdCLEdBQUcsS0FBSztRQUMzTE0sVUFBVW9jLHFCQUFxQixDQUFDO1lBQzlCdmE7WUFDQXNFO1FBQ0Y7SUFDRjtJQUNBLE1BQU1GLGtCQUFrQixDQUFDcEUsSUFBSXltQjtRQUMzQixJQUFJLENBQUNGLFlBQVk7WUFDZjtRQUNGO1FBQ0F4QixTQUFTMWdCLFNBQVMsQ0FBQzZnQixPQUFPLENBQUNsbEIsSUFBSTdCLFNBQVMsQ0FBQzhFLE1BQU0sQ0FBQ3dqQjtJQUNsRDtJQUNBLE1BQU05QyxpQkFBaUI7UUFDckIsSUFBSSxDQUFDNEMsWUFBWTtZQUNmO1FBQ0Y7UUFDQXhELFVBQVVqRCxJQUFJO1FBQ2QsTUFBTXRNLE9BQU8rUyxXQUFXOVMsUUFBUSxDQUFDcFAsU0FBUztRQUMxQzBnQixTQUFTMWdCLFNBQVMsQ0FBQzhoQixZQUFZLENBQUMzUyxLQUFLMVgsSUFBSSxFQUFFd0IsT0FBTyxDQUFDMGpCLENBQUFBLFFBQVNBLE1BQU03aUIsU0FBUyxDQUFDdW9CLFdBQVc7UUFDdkZILFdBQVdJLFdBQVc7UUFDdEJKLGFBQWE7SUFDZjtJQUNBLE1BQU1LLGFBQWF2b0IsQ0FBQUE7UUFDakIsQ0FBQ2tvQixhQUFhcnJCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sOERBQThEQSxDQUFnQixHQUFHLEtBQUs7UUFDN0osTUFBTTJlLFdBQVcrSixXQUFXOVMsUUFBUSxDQUFDaE8sU0FBUztRQUM5QyxJQUFJcEgsTUFBTXZDLElBQUksS0FBSyxZQUFZO1lBQzdCLElBQUl1cUIsb0JBQW9CdEIsVUFBVXZJLFVBQVVuZSxNQUFNL0MsS0FBSyxHQUFHO2dCQUN4RHluQixVQUFVL2hCLEdBQUcsQ0FBQzNDLE1BQU0vQyxLQUFLO1lBQzNCO1FBQ0Y7UUFDQSxJQUFJK0MsTUFBTXZDLElBQUksS0FBSyxXQUFXO1lBQzVCLElBQUl1cUIsb0JBQW9CdEIsVUFBVXZJLFVBQVVuZSxNQUFNL0MsS0FBSyxHQUFHO2dCQUN4RHluQixVQUFVN2MsTUFBTSxDQUFDN0gsTUFBTS9DLEtBQUs7WUFDOUI7UUFDRjtJQUNGO0lBQ0EsTUFBTWdoQixrQkFBa0JELENBQUFBO1FBQ3RCLENBQUMsQ0FBQ2tLLGFBQWFyckIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxpRkFBaUZBLENBQWdCLEdBQUcsS0FBSztRQUNqTCxNQUFNbWpCLFFBQVErRCxTQUFTdGYsU0FBUyxDQUFDeWYsT0FBTyxDQUFDN0ksUUFBUWxjLFdBQVc7UUFDNUQsTUFBTXFULE9BQU91UixTQUFTMWdCLFNBQVMsQ0FBQzZnQixPQUFPLENBQUNsRSxNQUFNaGMsVUFBVSxDQUFDcEYsV0FBVztRQUNwRSxNQUFNNlQsV0FBVztZQUNmaE8sV0FBV3ViLE1BQU1oYyxVQUFVO1lBQzNCWCxXQUFXbVAsS0FBS3hPLFVBQVU7UUFDNUI7UUFDQSxNQUFNMmhCLGNBQWM1QixTQUFTOEIsU0FBUyxDQUFDRDtRQUN2Q0wsYUFBYTtZQUNYOVM7WUFDQWtUO1FBQ0Y7UUFDQSxPQUFPVixrQkFBa0I7WUFDdkJ4UztZQUNBc1I7WUFDQTVJLGVBQWVFLFFBQVFGLGFBQWE7UUFDdEM7SUFDRjtJQUNBLE1BQU1KLFVBQVU7UUFDZHZCO1FBQ0FDO1FBQ0FyVztRQUNBbVc7UUFDQStCO1FBQ0FxSDtJQUNGO0lBQ0EsT0FBTzVIO0FBQ1Q7QUFFQSxJQUFJK0ssZUFBZ0IsQ0FBQzFULE9BQU9wVDtJQUMxQixJQUFJb1QsTUFBTVUsS0FBSyxLQUFLLFFBQVE7UUFDMUIsT0FBTztJQUNUO0lBQ0EsSUFBSVYsTUFBTVUsS0FBSyxLQUFLLGtCQUFrQjtRQUNwQyxPQUFPO0lBQ1Q7SUFDQSxJQUFJVixNQUFNa0csU0FBUyxDQUFDN1ksTUFBTSxDQUFDTixXQUFXLEtBQUtILElBQUk7UUFDN0MsT0FBTztJQUNUO0lBQ0EsT0FBT29ULE1BQU1rRyxTQUFTLENBQUM3WSxNQUFNLENBQUNDLE1BQU0sS0FBSztBQUMzQztBQUVBLElBQUlxbUIsZUFBZ0JOLENBQUFBO0lBQ2xCMXFCLE9BQU9pckIsUUFBUSxDQUFDUCxPQUFPM2xCLENBQUMsRUFBRTJsQixPQUFPMWxCLENBQUM7QUFDcEM7QUFFQSxNQUFNa21CLDBCQUEwQm5zQix1REFBVUEsQ0FBQytKLENBQUFBLGFBQWNNLGdCQUFnQk4sWUFBWVcsTUFBTSxDQUFDbkIsQ0FBQUE7UUFDMUYsSUFBSSxDQUFDQSxVQUFVMEwsU0FBUyxFQUFFO1lBQ3hCLE9BQU87UUFDVDtRQUNBLElBQUksQ0FBQzFMLFVBQVVsQyxLQUFLLEVBQUU7WUFDcEIsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0FBQ0EsTUFBTStrQiw2QkFBNkIsQ0FBQ3BsQixRQUFRK0M7SUFDMUMsTUFBTXNpQixRQUFRRix3QkFBd0JwaUIsWUFBWXVHLElBQUksQ0FBQy9HLENBQUFBO1FBQ3JELENBQUNBLFVBQVVsQyxLQUFLLEdBQUdqSCxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLG9CQUFvQkEsQ0FBZ0IsR0FBRyxLQUFLO1FBQ3hILE9BQU9rVyxrQkFBa0IxUCxVQUFVbEMsS0FBSyxDQUFDd0IsYUFBYSxFQUFFN0I7SUFDMUQsTUFBTTtJQUNOLE9BQU9xbEI7QUFDVDtBQUNBLElBQUlDLDZCQUE4QnZqQixDQUFBQTtJQUNoQyxJQUFJLEVBQ0YrSSxNQUFNLEVBQ05sTixXQUFXLEVBQ1htRixVQUFVLEVBQ1gsR0FBR2hCO0lBQ0osSUFBSW5FLGFBQWE7UUFDZixNQUFNb1MsWUFBWWpOLFVBQVUsQ0FBQ25GLFlBQVk7UUFDekMsSUFBSSxDQUFDb1MsVUFBVTNQLEtBQUssRUFBRTtZQUNwQixPQUFPO1FBQ1Q7UUFDQSxPQUFPMlA7SUFDVDtJQUNBLE1BQU1BLFlBQVlvViwyQkFBMkJ0YSxRQUFRL0g7SUFDckQsT0FBT2lOO0FBQ1Q7QUFFQSxNQUFNdVYsNkJBQTZCO0lBQ2pDQyxxQkFBcUI7SUFDckJDLHVCQUF1QjtJQUN2QkMsZ0JBQWdCO0lBQ2hCQyxNQUFNckosQ0FBQUEsYUFBY0EsY0FBYztJQUNsQ3NKLG1CQUFtQjtRQUNqQkMsaUJBQWlCO1FBQ2pCQyxjQUFjO0lBQ2hCO0lBQ0FDLFVBQVU7QUFDWjtBQUVBLElBQUlDLHdCQUF5QixTQUFVQyxTQUFTLEVBQUUxa0IsSUFBSSxFQUFFMmtCLHNCQUFzQjtJQUM1RSxJQUFJQSwyQkFBMkIsS0FBSyxHQUFHO1FBQ3JDQSx5QkFBeUIsSUFBTVg7SUFDakM7SUFDQSxNQUFNWSxzQkFBc0JEO0lBQzVCLE1BQU1FLHFCQUFxQkgsU0FBUyxDQUFDMWtCLEtBQUsyRixJQUFJLENBQUMsR0FBR2lmLG9CQUFvQlgsbUJBQW1CO0lBQ3pGLE1BQU1hLG1CQUFtQkosU0FBUyxDQUFDMWtCLEtBQUsyRixJQUFJLENBQUMsR0FBR2lmLG9CQUFvQlYscUJBQXFCO0lBQ3pGLE1BQU1hLGFBQWE7UUFDakJGO1FBQ0FDO0lBQ0Y7SUFDQSxPQUFPQztBQUNUO0FBRUEsSUFBSUMsZ0JBQWlCeGtCLENBQUFBO0lBQ25CLElBQUksRUFDRnlrQixZQUFZLEVBQ1pDLFVBQVUsRUFDVjVqQixPQUFPLEVBQ1IsR0FBR2Q7SUFDSixNQUFNMmtCLFFBQVFELGFBQWFEO0lBQzNCLElBQUlFLFVBQVUsR0FBRztRQXJySG5CLEtBc3JIeUMsR0FBR3ZzQixRQUFRLENBQUM7Ozs7SUFJakQsQ0FBQyxJQUFJLENBQU07UUFDWCxPQUFPO0lBQ1Q7SUFDQSxNQUFNd3NCLGlCQUFpQjlqQixVQUFVMmpCO0lBQ2pDLE1BQU1sSyxhQUFhcUssaUJBQWlCRDtJQUNwQyxPQUFPcEs7QUFDVDtBQUVBLElBQUlzSyxZQUFZO0FBRWhCLElBQUlDLHVCQUF3QixTQUFVQyxjQUFjLEVBQUVSLFVBQVUsRUFBRUosc0JBQXNCO0lBQ3RGLElBQUlBLDJCQUEyQixLQUFLLEdBQUc7UUFDckNBLHlCQUF5QixJQUFNWDtJQUNqQztJQUNBLE1BQU1ZLHNCQUFzQkQ7SUFDNUIsSUFBSVksaUJBQWlCUixXQUFXRixrQkFBa0IsRUFBRTtRQUNsRCxPQUFPO0lBQ1Q7SUFDQSxJQUFJVSxrQkFBa0JSLFdBQVdELGdCQUFnQixFQUFFO1FBQ2pELE9BQU9GLG9CQUFvQlQsY0FBYztJQUMzQztJQUNBLElBQUlvQixtQkFBbUJSLFdBQVdGLGtCQUFrQixFQUFFO1FBQ3BELE9BQU9RO0lBQ1Q7SUFDQSxNQUFNRyxpQ0FBaUNSLGNBQWM7UUFDbkRDLGNBQWNGLFdBQVdELGdCQUFnQjtRQUN6Q0ksWUFBWUgsV0FBV0Ysa0JBQWtCO1FBQ3pDdmpCLFNBQVNpa0I7SUFDWDtJQUNBLE1BQU1FLG1DQUFtQyxJQUFJRDtJQUM3QyxNQUFNNWxCLFNBQVNnbEIsb0JBQW9CVCxjQUFjLEdBQUdTLG9CQUFvQlIsSUFBSSxDQUFDcUI7SUFDN0UsT0FBT25uQixLQUFLb25CLElBQUksQ0FBQzlsQjtBQUNuQjtBQUVBLElBQUkrbEIsb0JBQXFCLENBQUNDLGdCQUFnQkMsZUFBZWxCO0lBQ3ZELE1BQU1DLHNCQUFzQkQ7SUFDNUIsTUFBTUosZUFBZUssb0JBQW9CUCxpQkFBaUIsQ0FBQ0UsWUFBWTtJQUN2RSxNQUFNdUIsU0FBU2xCLG9CQUFvQlAsaUJBQWlCLENBQUNDLGVBQWU7SUFDcEUsTUFBTVcsZUFBZVk7SUFDckIsTUFBTVgsYUFBYVk7SUFDbkIsTUFBTXBULE1BQU1xVCxLQUFLclQsR0FBRztJQUNwQixNQUFNc1QsVUFBVXRULE1BQU11UztJQUN0QixJQUFJZSxXQUFXRixRQUFRO1FBQ3JCLE9BQU9GO0lBQ1Q7SUFDQSxJQUFJSSxVQUFVekIsY0FBYztRQUMxQixPQUFPYztJQUNUO0lBQ0EsTUFBTVkseUNBQXlDakIsY0FBYztRQUMzREMsY0FBY1Y7UUFDZFc7UUFDQTVqQixTQUFTMGtCO0lBQ1g7SUFDQSxNQUFNcG1CLFNBQVNnbUIsaUJBQWlCaEIsb0JBQW9CUixJQUFJLENBQUM2QjtJQUN6RCxPQUFPM25CLEtBQUtvbkIsSUFBSSxDQUFDOWxCO0FBQ25CO0FBRUEsSUFBSXNtQixXQUFZMWxCLENBQUFBO0lBQ2QsSUFBSSxFQUNGK2tCLGNBQWMsRUFDZFIsVUFBVSxFQUNWYyxhQUFhLEVBQ2JNLHNCQUFzQixFQUN0QnhCLHNCQUFzQixFQUN2QixHQUFHbmtCO0lBQ0osTUFBTVosU0FBUzBsQixxQkFBcUJDLGdCQUFnQlIsWUFBWUo7SUFDaEUsSUFBSS9rQixXQUFXLEdBQUc7UUFDaEIsT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDdW1CLHdCQUF3QjtRQUMzQixPQUFPdm1CO0lBQ1Q7SUFDQSxPQUFPdEIsS0FBS1csR0FBRyxDQUFDMG1CLGtCQUFrQi9sQixRQUFRaW1CLGVBQWVsQix5QkFBeUJVO0FBQ3BGO0FBRUEsSUFBSWUsa0JBQW1CNWxCLENBQUFBO0lBQ3JCLElBQUksRUFDRmtrQixTQUFTLEVBQ1QyQixlQUFlLEVBQ2ZSLGFBQWEsRUFDYjdsQixJQUFJLEVBQ0ptbUIsc0JBQXNCLEVBQ3RCeEIsc0JBQXNCLEVBQ3ZCLEdBQUdua0I7SUFDSixNQUFNdWtCLGFBQWFOLHNCQUFzQkMsV0FBVzFrQixNQUFNMmtCO0lBQzFELE1BQU0yQixnQkFBZ0JELGVBQWUsQ0FBQ3JtQixLQUFLRyxHQUFHLENBQUMsR0FBR2ttQixlQUFlLENBQUNybUIsS0FBSzlELEtBQUssQ0FBQztJQUM3RSxJQUFJb3FCLGVBQWU7UUFDakIsT0FBT0osU0FBUztZQUNkWCxnQkFBZ0JjLGVBQWUsQ0FBQ3JtQixLQUFLRyxHQUFHLENBQUM7WUFDekM0a0I7WUFDQWM7WUFDQU07WUFDQXhCO1FBQ0Y7SUFDRjtJQUNBLE9BQU8sQ0FBQyxJQUFJdUIsU0FBUztRQUNuQlgsZ0JBQWdCYyxlQUFlLENBQUNybUIsS0FBSzlELEtBQUssQ0FBQztRQUMzQzZvQjtRQUNBYztRQUNBTTtRQUNBeEI7SUFDRjtBQUNGO0FBRUEsSUFBSTRCLHNCQUF1Qi9sQixDQUFBQTtJQUN6QixJQUFJLEVBQ0Zra0IsU0FBUyxFQUNUM2xCLE9BQU8sRUFDUDZtQixjQUFjLEVBQ2YsR0FBR3BsQjtJQUNKLE1BQU1nbUIscUJBQXFCem5CLFFBQVFPLE1BQU0sR0FBR29sQixVQUFVcGxCLE1BQU07SUFDNUQsTUFBTW1uQix1QkFBdUIxbkIsUUFBUU0sS0FBSyxHQUFHcWxCLFVBQVVybEIsS0FBSztJQUM1RCxJQUFJLENBQUNvbkIsd0JBQXdCLENBQUNELG9CQUFvQjtRQUNoRCxPQUFPWjtJQUNUO0lBQ0EsSUFBSWEsd0JBQXdCRCxvQkFBb0I7UUFDOUMsT0FBTztJQUNUO0lBQ0EsT0FBTztRQUNML29CLEdBQUdncEIsdUJBQXVCLElBQUliLGVBQWVub0IsQ0FBQztRQUM5Q0MsR0FBRzhvQixxQkFBcUIsSUFBSVosZUFBZWxvQixDQUFDO0lBQzlDO0FBQ0Y7QUFFQSxNQUFNZ3BCLFFBQVE5bkIsTUFBTTNHLENBQUFBLFFBQVNBLFVBQVUsSUFBSSxJQUFJQTtBQUMvQyxJQUFJMHVCLGNBQWVubUIsQ0FBQUE7SUFDakIsSUFBSSxFQUNGcWxCLGFBQWEsRUFDYm5CLFNBQVMsRUFDVDNsQixPQUFPLEVBQ1B3SyxNQUFNLEVBQ040YyxzQkFBc0IsRUFDdEJ4QixzQkFBc0IsRUFDdkIsR0FBR25rQjtJQUNKLE1BQU02bEIsa0JBQWtCO1FBQ3RCcm5CLEtBQUt1SyxPQUFPN0wsQ0FBQyxHQUFHZ25CLFVBQVUxbEIsR0FBRztRQUM3QkUsT0FBT3dsQixVQUFVeGxCLEtBQUssR0FBR3FLLE9BQU85TCxDQUFDO1FBQ2pDMEIsUUFBUXVsQixVQUFVdmxCLE1BQU0sR0FBR29LLE9BQU83TCxDQUFDO1FBQ25DMEIsTUFBTW1LLE9BQU85TCxDQUFDLEdBQUdpbkIsVUFBVXRsQixJQUFJO0lBQ2pDO0lBQ0EsTUFBTTFCLElBQUkwb0IsZ0JBQWdCO1FBQ3hCMUI7UUFDQTJCO1FBQ0FSO1FBQ0E3bEIsTUFBTXdGO1FBQ04yZ0I7UUFDQXhCO0lBQ0Y7SUFDQSxNQUFNbG5CLElBQUkyb0IsZ0JBQWdCO1FBQ3hCMUI7UUFDQTJCO1FBQ0FSO1FBQ0E3bEIsTUFBTStGO1FBQ05vZ0I7UUFDQXhCO0lBQ0Y7SUFDQSxNQUFNaUMsV0FBV0YsTUFBTTtRQUNyQmpwQjtRQUNBQztJQUNGO0lBQ0EsSUFBSUssVUFBVTZvQixVQUFVcHBCLFNBQVM7UUFDL0IsT0FBTztJQUNUO0lBQ0EsTUFBTXFwQixVQUFVTixvQkFBb0I7UUFDbEM3QjtRQUNBM2xCO1FBQ0E2bUIsZ0JBQWdCZ0I7SUFDbEI7SUFDQSxJQUFJLENBQUNDLFNBQVM7UUFDWixPQUFPO0lBQ1Q7SUFDQSxPQUFPOW9CLFVBQVU4b0IsU0FBU3JwQixVQUFVLE9BQU9xcEI7QUFDN0M7QUFFQSxNQUFNQyxpQkFBaUJsb0IsTUFBTTNHLENBQUFBO0lBQzNCLElBQUlBLFVBQVUsR0FBRztRQUNmLE9BQU87SUFDVDtJQUNBLE9BQU9BLFFBQVEsSUFBSSxJQUFJLENBQUM7QUFDMUI7QUFDQSxNQUFNOHVCLGFBQWEsQ0FBQztJQUNsQixNQUFNQyxlQUFlLENBQUN2b0IsUUFBUVE7UUFDNUIsSUFBSVIsU0FBUyxHQUFHO1lBQ2QsT0FBT0E7UUFDVDtRQUNBLElBQUlBLFNBQVNRLEtBQUs7WUFDaEIsT0FBT1IsU0FBU1E7UUFDbEI7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxPQUFPdUIsQ0FBQUE7UUFDTCxJQUFJLEVBQ0ZjLE9BQU8sRUFDUHJDLEdBQUcsRUFDSG1rQixNQUFNLEVBQ1AsR0FBRzVpQjtRQUNKLE1BQU15bUIsZUFBZXRwQixJQUFJMkQsU0FBUzhoQjtRQUNsQyxNQUFNOEQsVUFBVTtZQUNkenBCLEdBQUd1cEIsYUFBYUMsYUFBYXhwQixDQUFDLEVBQUV3QixJQUFJeEIsQ0FBQztZQUNyQ0MsR0FBR3NwQixhQUFhQyxhQUFhdnBCLENBQUMsRUFBRXVCLElBQUl2QixDQUFDO1FBQ3ZDO1FBQ0EsSUFBSUssVUFBVW1wQixTQUFTMXBCLFNBQVM7WUFDOUIsT0FBTztRQUNUO1FBQ0EsT0FBTzBwQjtJQUNUO0FBQ0Y7QUFDQSxNQUFNQyxxQkFBcUJ0ZixDQUFBQTtJQUN6QixJQUFJLEVBQ0Y1SSxLQUFLbW9CLE1BQU0sRUFDWDlsQixPQUFPLEVBQ1A4aEIsTUFBTSxFQUNQLEdBQUd2YjtJQUNKLE1BQU01SSxNQUFNO1FBQ1Z4QixHQUFHYSxLQUFLVyxHQUFHLENBQUNxQyxRQUFRN0QsQ0FBQyxFQUFFMnBCLE9BQU8zcEIsQ0FBQztRQUMvQkMsR0FBR1ksS0FBS1csR0FBRyxDQUFDcUMsUUFBUTVELENBQUMsRUFBRTBwQixPQUFPMXBCLENBQUM7SUFDakM7SUFDQSxNQUFNMnBCLGlCQUFpQlAsZUFBZTFEO0lBQ3RDLE1BQU04RCxVQUFVSCxXQUFXO1FBQ3pCOW5CO1FBQ0FxQztRQUNBOGhCLFFBQVFpRTtJQUNWO0lBQ0EsSUFBSSxDQUFDSCxTQUFTO1FBQ1osT0FBTztJQUNUO0lBQ0EsSUFBSUcsZUFBZTVwQixDQUFDLEtBQUssS0FBS3lwQixRQUFRenBCLENBQUMsS0FBSyxHQUFHO1FBQzdDLE9BQU87SUFDVDtJQUNBLElBQUk0cEIsZUFBZTNwQixDQUFDLEtBQUssS0FBS3dwQixRQUFReHBCLENBQUMsS0FBSyxHQUFHO1FBQzdDLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLE1BQU00cEIsa0JBQWtCLENBQUNqaEIsVUFBVStjLFNBQVcrRCxtQkFBbUI7UUFDL0Q3bEIsU0FBUytFLFNBQVN6RyxNQUFNLENBQUMwQixPQUFPO1FBQ2hDckMsS0FBS29ILFNBQVN6RyxNQUFNLENBQUNYLEdBQUc7UUFDeEJta0I7SUFDRjtBQUNBLE1BQU1tRSxtQkFBbUIsQ0FBQ2xoQixVQUFVK2M7SUFDbEMsSUFBSSxDQUFDa0UsZ0JBQWdCamhCLFVBQVUrYyxTQUFTO1FBQ3RDLE9BQU87SUFDVDtJQUNBLE1BQU1ua0IsTUFBTW9ILFNBQVN6RyxNQUFNLENBQUNYLEdBQUc7SUFDL0IsTUFBTXFDLFVBQVUrRSxTQUFTekcsTUFBTSxDQUFDMEIsT0FBTztJQUN2QyxPQUFPeWxCLFdBQVc7UUFDaEJ6bEI7UUFDQXJDO1FBQ0Fta0I7SUFDRjtBQUNGO0FBQ0EsTUFBTW9FLHFCQUFxQixDQUFDeG1CLFdBQVdvaUI7SUFDckMsTUFBTXRrQixRQUFRa0MsVUFBVWxDLEtBQUs7SUFDN0IsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBQ0EsT0FBT3FvQixtQkFBbUI7UUFDeEI3bEIsU0FBU3hDLE1BQU1jLE1BQU0sQ0FBQzBCLE9BQU87UUFDN0JyQyxLQUFLSCxNQUFNYyxNQUFNLENBQUNYLEdBQUc7UUFDckJta0I7SUFDRjtBQUNGO0FBQ0EsTUFBTXFFLHNCQUFzQixDQUFDem1CLFdBQVdvaUI7SUFDdEMsTUFBTXRrQixRQUFRa0MsVUFBVWxDLEtBQUs7SUFDN0IsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDMG9CLG1CQUFtQnhtQixXQUFXb2lCLFNBQVM7UUFDMUMsT0FBTztJQUNUO0lBQ0EsT0FBTzJELFdBQVc7UUFDaEJ6bEIsU0FBU3hDLE1BQU1jLE1BQU0sQ0FBQzBCLE9BQU87UUFDN0JyQyxLQUFLSCxNQUFNYyxNQUFNLENBQUNYLEdBQUc7UUFDckJta0I7SUFDRjtBQUNGO0FBRUEsSUFBSXNFLHdCQUF5QmxuQixDQUFBQTtJQUMzQixJQUFJLEVBQ0Y2RixRQUFRLEVBQ1J0SCxPQUFPLEVBQ1B3SyxNQUFNLEVBQ05zYyxhQUFhLEVBQ2JNLHNCQUFzQixFQUN0QnhCLHNCQUFzQixFQUN2QixHQUFHbmtCO0lBQ0osTUFBTVosU0FBUyttQixZQUFZO1FBQ3pCZDtRQUNBbkIsV0FBV3JlLFNBQVN2SCxLQUFLO1FBQ3pCQztRQUNBd0s7UUFDQTRjO1FBQ0F4QjtJQUNGO0lBQ0EsT0FBTy9rQixVQUFVMG5CLGdCQUFnQmpoQixVQUFVekcsVUFBVUEsU0FBUztBQUNoRTtBQUVBLElBQUkrbkIsMkJBQTRCbm5CLENBQUFBO0lBQzlCLElBQUksRUFDRlEsU0FBUyxFQUNUakMsT0FBTyxFQUNQd0ssTUFBTSxFQUNOc2MsYUFBYSxFQUNiTSxzQkFBc0IsRUFDdEJ4QixzQkFBc0IsRUFDdkIsR0FBR25rQjtJQUNKLE1BQU0xQixRQUFRa0MsVUFBVWxDLEtBQUs7SUFDN0IsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBQ0EsTUFBTWMsU0FBUyttQixZQUFZO1FBQ3pCZDtRQUNBbkIsV0FBVzVsQixNQUFNd0IsYUFBYTtRQUM5QnZCO1FBQ0F3SztRQUNBNGM7UUFDQXhCO0lBQ0Y7SUFDQSxPQUFPL2tCLFVBQVU0bkIsbUJBQW1CeG1CLFdBQVdwQixVQUFVQSxTQUFTO0FBQ3BFO0FBRUEsSUFBSUEsU0FBVVksQ0FBQUE7SUFDWixJQUFJLEVBQ0Z1UCxLQUFLLEVBQ0w4VixhQUFhLEVBQ2JNLHNCQUFzQixFQUN0QnpDLFlBQVksRUFDWjNpQixlQUFlLEVBQ2Y0akIsc0JBQXNCLEVBQ3ZCLEdBQUdua0I7SUFDSixNQUFNK0ksU0FBU3dHLE1BQU16TyxPQUFPLENBQUNiLElBQUksQ0FBQzZQLGVBQWU7SUFDakQsTUFBTWxPLFlBQVkyTixNQUFNRSxVQUFVLENBQUNwTyxVQUFVLENBQUNrTyxNQUFNSyxRQUFRLENBQUNoTyxTQUFTLENBQUN6RixFQUFFLENBQUM7SUFDMUUsTUFBTW9DLFVBQVVxRCxVQUFVM0IsSUFBSSxDQUFDRSxTQUFTO0lBQ3hDLElBQUlvUCxNQUFNdUcscUJBQXFCLEVBQUU7UUFDL0IsTUFBTWpRLFdBQVcwSixNQUFNMUosUUFBUTtRQUMvQixNQUFNK2MsU0FBU3NFLHNCQUFzQjtZQUNuQzdCO1lBQ0F4ZjtZQUNBdEg7WUFDQXdLO1lBQ0E0YztZQUNBeEI7UUFDRjtRQUNBLElBQUl2QixRQUFRO1lBQ1ZNLGFBQWFOO1lBQ2I7UUFDRjtJQUNGO0lBQ0EsTUFBTXBpQixZQUFZK2lCLDJCQUEyQjtRQUMzQ3hhO1FBQ0FsTixhQUFhdVQsa0JBQWtCRyxNQUFNdE4sTUFBTTtRQUMzQ2pCLFlBQVl1TyxNQUFNRSxVQUFVLENBQUN6TyxVQUFVO0lBQ3pDO0lBQ0EsSUFBSSxDQUFDUixXQUFXO1FBQ2Q7SUFDRjtJQUNBLE1BQU1vaUIsU0FBU3VFLHlCQUF5QjtRQUN0QzlCO1FBQ0E3a0I7UUFDQWpDO1FBQ0F3SztRQUNBNGM7UUFDQXhCO0lBQ0Y7SUFDQSxJQUFJdkIsUUFBUTtRQUNWcmlCLGdCQUFnQkMsVUFBVVcsVUFBVSxDQUFDaEYsRUFBRSxFQUFFeW1CO0lBQzNDO0FBQ0Y7QUFFQSxJQUFJd0Usc0JBQXVCcG5CLENBQUFBO0lBQ3pCLElBQUksRUFDRmtqQixZQUFZLEVBQ1ozaUIsZUFBZSxFQUNmNGpCLHlCQUF5QixJQUFNWCwwQkFBMEIsRUFDMUQsR0FBR3hqQjtJQUNKLE1BQU1xbkIsdUJBQXVCbndCLG9EQUFPQSxDQUFDZ3NCO0lBQ3JDLE1BQU1vRSwwQkFBMEJwd0Isb0RBQU9BLENBQUNxSjtJQUN4QyxJQUFJb1ksV0FBVztJQUNmLE1BQU00TyxZQUFZaFksQ0FBQUE7UUFDaEIsQ0FBQ29KLFdBQVd0aEIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyx5Q0FBeUNBLENBQWdCLEdBQUcsS0FBSztRQUN0SSxNQUFNLEVBQ0oyckIsc0JBQXNCLEVBQ3RCTixhQUFhLEVBQ2QsR0FBRzFNO1FBQ0p2WixPQUFPO1lBQ0xtUTtZQUNBMlQsY0FBY21FO1lBQ2Q5bUIsaUJBQWlCK21CO1lBQ2pCakM7WUFDQU07WUFDQXhCO1FBQ0Y7SUFDRjtJQUNBLE1BQU1xRCxVQUFValksQ0FBQUE7UUFDZDdUO1FBQ0EsQ0FBQyxDQUFDaWQsV0FBV3RoQixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHNEQUFzREEsQ0FBZ0IsR0FBRyxLQUFLO1FBQ3BKLE1BQU1xckIsZ0JBQWdCRSxLQUFLclQsR0FBRztRQUM5QixJQUFJdVYsa0JBQWtCO1FBQ3RCLE1BQU1DLHFCQUFxQjtZQUN6QkQsa0JBQWtCO1FBQ3BCO1FBQ0Fyb0IsT0FBTztZQUNMbVE7WUFDQThWLGVBQWU7WUFDZk0sd0JBQXdCO1lBQ3hCekMsY0FBY3dFO1lBQ2RubkIsaUJBQWlCbW5CO1lBQ2pCdkQ7UUFDRjtRQUNBeEwsV0FBVztZQUNUME07WUFDQU0sd0JBQXdCOEI7UUFDMUI7UUFDQWhVO1FBQ0EsSUFBSWdVLGlCQUFpQjtZQUNuQkYsVUFBVWhZO1FBQ1o7SUFDRjtJQUNBLE1BQU0wTSxPQUFPO1FBQ1gsSUFBSSxDQUFDdEQsVUFBVTtZQUNiO1FBQ0Y7UUFDQTBPLHFCQUFxQm5MLE1BQU07UUFDM0JvTCx3QkFBd0JwTCxNQUFNO1FBQzlCdkQsV0FBVztJQUNiO0lBQ0EsT0FBTztRQUNMamQsT0FBTzhyQjtRQUNQdkw7UUFDQTdjLFFBQVFtb0I7SUFDVjtBQUNGO0FBRUEsSUFBSUkscUJBQXNCM25CLENBQUFBO0lBQ3hCLElBQUksRUFDRjZXLElBQUksRUFDSnRXLGVBQWUsRUFDZjJpQixZQUFZLEVBQ2IsR0FBR2xqQjtJQUNKLE1BQU00bkIsZUFBZSxDQUFDclksT0FBTzNZO1FBQzNCLE1BQU02VSxTQUFTdE8sSUFBSW9TLE1BQU16TyxPQUFPLENBQUMySyxNQUFNLENBQUNzRSxTQUFTLEVBQUVuWjtRQUNuRGlnQixLQUFLO1lBQ0hwTDtRQUNGO0lBQ0Y7SUFDQSxNQUFNb2MsK0JBQStCLENBQUNybkIsV0FBV29pQjtRQUMvQyxJQUFJLENBQUNvRSxtQkFBbUJ4bUIsV0FBV29pQixTQUFTO1lBQzFDLE9BQU9BO1FBQ1Q7UUFDQSxNQUFNOEQsVUFBVU8sb0JBQW9Cem1CLFdBQVdvaUI7UUFDL0MsSUFBSSxDQUFDOEQsU0FBUztZQUNabm1CLGdCQUFnQkMsVUFBVVcsVUFBVSxDQUFDaEYsRUFBRSxFQUFFeW1CO1lBQ3pDLE9BQU87UUFDVDtRQUNBLE1BQU1rRiw0QkFBNEJ4cUIsU0FBU3NsQixRQUFROEQ7UUFDbkRubUIsZ0JBQWdCQyxVQUFVVyxVQUFVLENBQUNoRixFQUFFLEVBQUUyckI7UUFDekMsTUFBTUMsWUFBWXpxQixTQUFTc2xCLFFBQVFrRjtRQUNuQyxPQUFPQztJQUNUO0lBQ0EsTUFBTUMsNEJBQTRCLENBQUNsUyx1QkFBdUJqUSxVQUFVK2M7UUFDbEUsSUFBSSxDQUFDOU0sdUJBQXVCO1lBQzFCLE9BQU84TTtRQUNUO1FBQ0EsSUFBSSxDQUFDa0UsZ0JBQWdCamhCLFVBQVUrYyxTQUFTO1lBQ3RDLE9BQU9BO1FBQ1Q7UUFDQSxNQUFNOEQsVUFBVUssaUJBQWlCbGhCLFVBQVUrYztRQUMzQyxJQUFJLENBQUM4RCxTQUFTO1lBQ1p4RCxhQUFhTjtZQUNiLE9BQU87UUFDVDtRQUNBLE1BQU1xRix5QkFBeUIzcUIsU0FBU3NsQixRQUFROEQ7UUFDaER4RCxhQUFhK0U7UUFDYixNQUFNRixZQUFZenFCLFNBQVNzbEIsUUFBUXFGO1FBQ25DLE9BQU9GO0lBQ1Q7SUFDQSxNQUFNRyxlQUFlM1ksQ0FBQUE7UUFDbkIsTUFBTWlKLFVBQVVqSixNQUFNbEQsaUJBQWlCO1FBQ3ZDLElBQUksQ0FBQ21NLFNBQVM7WUFDWjtRQUNGO1FBQ0EsTUFBTTNjLGNBQWN1VCxrQkFBa0JHLE1BQU10TixNQUFNO1FBQ2xELENBQUNwRyxjQUFjeEUsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywrREFBK0RBLENBQWdCLEdBQUcsS0FBSztRQUMvSixNQUFNbXVCLHFCQUFxQk4sNkJBQTZCdFksTUFBTUUsVUFBVSxDQUFDek8sVUFBVSxDQUFDbkYsWUFBWSxFQUFFMmM7UUFDbEcsSUFBSSxDQUFDMlAsb0JBQW9CO1lBQ3ZCO1FBQ0Y7UUFDQSxNQUFNdGlCLFdBQVcwSixNQUFNMUosUUFBUTtRQUMvQixNQUFNdWlCLGtCQUFrQkosMEJBQTBCelksTUFBTXVHLHFCQUFxQixFQUFFalEsVUFBVXNpQjtRQUN6RixJQUFJLENBQUNDLGlCQUFpQjtZQUNwQjtRQUNGO1FBQ0FSLGFBQWFyWSxPQUFPNlk7SUFDdEI7SUFDQSxPQUFPRjtBQUNUO0FBRUEsSUFBSUcscUJBQXNCcm9CLENBQUFBO0lBQ3hCLElBQUksRUFDRk8sZUFBZSxFQUNmMmlCLFlBQVksRUFDWnJNLElBQUksRUFDSnNOLHNCQUFzQixFQUN2QixHQUFHbmtCO0lBQ0osTUFBTXNvQixnQkFBZ0JsQixvQkFBb0I7UUFDeENsRTtRQUNBM2lCO1FBQ0E0akI7SUFDRjtJQUNBLE1BQU1vRSxhQUFhWixtQkFBbUI7UUFDcEM5UTtRQUNBcU07UUFDQTNpQjtJQUNGO0lBQ0EsTUFBTW5CLFNBQVNtUSxDQUFBQTtRQUNiLE1BQU02VSxzQkFBc0JEO1FBQzVCLElBQUlDLG9CQUFvQkosUUFBUSxJQUFJelUsTUFBTVUsS0FBSyxLQUFLLFlBQVk7WUFDOUQ7UUFDRjtRQUNBLElBQUlWLE1BQU15RCxZQUFZLEtBQUssU0FBUztZQUNsQ3NWLGNBQWNscEIsTUFBTSxDQUFDbVE7WUFDckI7UUFDRjtRQUNBLElBQUksQ0FBQ0EsTUFBTWxELGlCQUFpQixFQUFFO1lBQzVCO1FBQ0Y7UUFDQWtjLFdBQVdoWjtJQUNiO0lBQ0EsTUFBTWlaLFdBQVc7UUFDZnBwQjtRQUNBMUQsT0FBTzRzQixjQUFjNXNCLEtBQUs7UUFDMUJ1Z0IsTUFBTXFNLGNBQWNyTSxJQUFJO0lBQzFCO0lBQ0EsT0FBT3VNO0FBQ1Q7QUFFQSxNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsYUFBYSxDQUFDO0lBQ2xCLE1BQU1DLE9BQU8sQ0FBQyxFQUFFRixPQUFPLFlBQVksQ0FBQztJQUNwQyxPQUFPO1FBQ0xFO1FBQ0Fyc0IsYUFBYSxDQUFDLEVBQUVxc0IsS0FBSyxhQUFhLENBQUM7UUFDbkNDLFdBQVcsQ0FBQyxFQUFFRCxLQUFLLFdBQVcsQ0FBQztJQUNqQztBQUNGO0FBQ0EsTUFBTS9tQixZQUFZLENBQUM7SUFDakIsTUFBTSttQixPQUFPLENBQUMsRUFBRUYsT0FBTyxVQUFVLENBQUM7SUFDbEMsT0FBTztRQUNMRTtRQUNBQyxXQUFXLENBQUMsRUFBRUQsS0FBSyxXQUFXLENBQUM7UUFDL0J4c0IsSUFBSSxDQUFDLEVBQUV3c0IsS0FBSyxHQUFHLENBQUM7SUFDbEI7QUFDRjtBQUNBLE1BQU1ub0IsWUFBWSxDQUFDO0lBQ2pCLE1BQU1tb0IsT0FBTyxDQUFDLEVBQUVGLE9BQU8sVUFBVSxDQUFDO0lBQ2xDLE9BQU87UUFDTEU7UUFDQUMsV0FBVyxDQUFDLEVBQUVELEtBQUssV0FBVyxDQUFDO1FBQy9CeHNCLElBQUksQ0FBQyxFQUFFd3NCLEtBQUssR0FBRyxDQUFDO0lBQ2xCO0FBQ0Y7QUFDQSxNQUFNRSxrQkFBa0I7SUFDdEJELFdBQVcsQ0FBQyxFQUFFSCxPQUFPLDRCQUE0QixDQUFDO0FBQ3BEO0FBRUEsTUFBTUssa0JBQWtCQyxDQUFBQSxVQUFXQyxDQUFBQSxZQUFhLENBQUMsQ0FBQyxFQUFFQSxVQUFVLEVBQUUsRUFBRUQsUUFBUSxFQUFFLENBQUM7QUFDN0UsTUFBTUUsWUFBWSxDQUFDQyxPQUFPQyxXQUFhRCxNQUFNbHdCLEdBQUcsQ0FBQ293QixDQUFBQTtRQUMvQyxNQUFNM3hCLFFBQVEyeEIsS0FBS0MsTUFBTSxDQUFDRixTQUFTO1FBQ25DLElBQUksQ0FBQzF4QixPQUFPO1lBQ1YsT0FBTztRQUNUO1FBQ0EsT0FBTyxDQUFDLEVBQUUyeEIsS0FBS0UsUUFBUSxDQUFDLEdBQUcsRUFBRTd4QixNQUFNLEVBQUUsQ0FBQztJQUN4QyxHQUFHc2dCLElBQUksQ0FBQztBQUNSLE1BQU13UixrQkFBa0I7QUFDeEIsSUFBSUMsY0FBZVosQ0FBQUE7SUFDakIsTUFBTWEsY0FBY1gsZ0JBQWdCRjtJQUNwQyxNQUFNYyxlQUFlLENBQUM7UUFDcEIsTUFBTUMsYUFBYSxDQUFDOzs7SUFHcEIsQ0FBQztRQUNELE9BQU87WUFDTEwsVUFBVUcsWUFBWWYsV0FBV0UsU0FBUztZQUMxQ1MsUUFBUTtnQkFDTk8sUUFBUSxDQUFDOzs7O1FBSVQsQ0FBQztnQkFDRC9RLFNBQVM4UTtnQkFDVGhSLFVBQVU0UTtnQkFDVk0sZUFBZUY7WUFDakI7UUFDRjtJQUNGO0lBQ0EsTUFBTUcsY0FBYyxDQUFDO1FBQ25CLE1BQU1DLGFBQWEsQ0FBQztrQkFDTixFQUFFdlEsWUFBWVQsV0FBVyxDQUFDO0lBQ3hDLENBQUM7UUFDRCxPQUFPO1lBQ0x1USxVQUFVRyxZQUFZN25CLFVBQVVnbkIsU0FBUztZQUN6Q1MsUUFBUTtnQkFDTjFRLFVBQVVvUjtnQkFDVkYsZUFBZUU7Z0JBQ2ZDLFlBQVlEO1lBQ2Q7UUFDRjtJQUNGO0lBQ0EsTUFBTUUsY0FBYztRQUNsQlgsVUFBVUcsWUFBWWpwQixVQUFVb29CLFNBQVM7UUFDekNTLFFBQVE7WUFDTk8sUUFBUSxDQUFDLHNCQUFzQixDQUFDO1FBQ2xDO0lBQ0Y7SUFDQSxNQUFNTSxPQUFPO1FBQ1haLFVBQVU7UUFDVkQsUUFBUTtZQUNOMVEsVUFBVSxDQUFDOzs7Ozs7OztNQVFYLENBQUM7UUFDSDtJQUNGO0lBQ0EsTUFBTXVRLFFBQVE7UUFBQ1k7UUFBYUo7UUFBY087UUFBYUM7S0FBSztJQUM1RCxPQUFPO1FBQ0xOLFFBQVFYLFVBQVVDLE9BQU87UUFDekJyUSxTQUFTb1EsVUFBVUMsT0FBTztRQUMxQnZRLFVBQVVzUSxVQUFVQyxPQUFPO1FBQzNCVyxlQUFlWixVQUFVQyxPQUFPO1FBQ2hDYyxZQUFZZixVQUFVQyxPQUFPO0lBQy9CO0FBQ0Y7QUFFQSxNQUFNaUIsNEJBQTRCLE1BQW9ILEdBQWN6MEIsQ0FBaUJBLEdBQUdDLDRDQUFTQTtBQUNqTSxJQUFJRixrQkFBa0IwMEI7QUFFdEIsTUFBTUUsVUFBVTtJQUNkLE1BQU1DLE9BQU8zTyxTQUFTNE8sYUFBYSxDQUFDO0lBQ3BDLENBQUNELE9BQU9qekIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywrQ0FBK0NBLENBQWdCLEdBQUcsS0FBSztJQUN4SSxPQUFPc3dCO0FBQ1Q7QUFDQSxNQUFNRSxnQkFBZ0JDLENBQUFBO0lBQ3BCLE1BQU03eEIsS0FBSytpQixTQUFTeU8sYUFBYSxDQUFDO0lBQ2xDLElBQUlLLE9BQU87UUFDVDd4QixHQUFHOHhCLFlBQVksQ0FBQyxTQUFTRDtJQUMzQjtJQUNBN3hCLEdBQUdYLElBQUksR0FBRztJQUNWLE9BQU9XO0FBQ1Q7QUFDQSxTQUFTK3hCLGdCQUFnQi9CLFNBQVMsRUFBRTZCLEtBQUs7SUFDdkMsTUFBTXBCLFNBQVM3eUIscURBQU9BLENBQUMsSUFBTWd6QixZQUFZWixZQUFZO1FBQUNBO0tBQVU7SUFDaEUsTUFBTWdDLFlBQVloMUIsNkNBQU1BLENBQUM7SUFDekIsTUFBTWkxQixhQUFhajFCLDZDQUFNQSxDQUFDO0lBQzFCLE1BQU1rMUIsa0JBQWtCcjBCLHlEQUFXQSxDQUFDUSx1REFBVUEsQ0FBQzZYLENBQUFBO1FBQzdDLE1BQU1sVyxLQUFLaXlCLFdBQVcvcEIsT0FBTztRQUM3QixDQUFDbEksS0FBS3ZCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sdURBQXVEQSxDQUFnQixHQUFHLEtBQUs7UUFDOUlwQixHQUFHbXlCLFdBQVcsR0FBR2pjO0lBQ25CLElBQUksRUFBRTtJQUNOLE1BQU1rYyxpQkFBaUJ2MEIseURBQVdBLENBQUNxWSxDQUFBQTtRQUNqQyxNQUFNbFcsS0FBS2d5QixVQUFVOXBCLE9BQU87UUFDNUIsQ0FBQ2xJLEtBQUt2QixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHVEQUF1REEsQ0FBZ0IsR0FBRyxLQUFLO1FBQzlJcEIsR0FBR215QixXQUFXLEdBQUdqYztJQUNuQixHQUFHLEVBQUU7SUFDTHJaLGdCQUFnQjtRQUNkLENBQUUsRUFBQ20xQixVQUFVOXBCLE9BQU8sSUFBSSxDQUFDK3BCLFdBQVcvcEIsT0FBTyxJQUFJekosS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxvQ0FBb0NBLENBQWdCLEdBQUcsS0FBSztRQUNwSyxNQUFNNHZCLFNBQVNZLGNBQWNDO1FBQzdCLE1BQU1RLFVBQVVULGNBQWNDO1FBQzlCRyxVQUFVOXBCLE9BQU8sR0FBRzhvQjtRQUNwQmlCLFdBQVcvcEIsT0FBTyxHQUFHbXFCO1FBQ3JCckIsT0FBT2MsWUFBWSxDQUFDLENBQUMsRUFBRWpDLE9BQU8sT0FBTyxDQUFDLEVBQUVHO1FBQ3hDcUMsUUFBUVAsWUFBWSxDQUFDLENBQUMsRUFBRWpDLE9BQU8sUUFBUSxDQUFDLEVBQUVHO1FBQzFDeUIsVUFBVWEsV0FBVyxDQUFDdEI7UUFDdEJTLFVBQVVhLFdBQVcsQ0FBQ0Q7UUFDdEJELGVBQWUzQixPQUFPTyxNQUFNO1FBQzVCa0IsZ0JBQWdCekIsT0FBT3hRLE9BQU87UUFDOUIsT0FBTztZQUNMLE1BQU14VyxTQUFTOG9CLENBQUFBO2dCQUNiLE1BQU1ycUIsVUFBVXFxQixJQUFJcnFCLE9BQU87Z0JBQzNCLENBQUNBLFVBQVV6SixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHlDQUF5Q0EsQ0FBZ0IsR0FBRyxLQUFLO2dCQUNySXF3QixVQUFVZSxXQUFXLENBQUN0cUI7Z0JBQ3RCcXFCLElBQUlycUIsT0FBTyxHQUFHO1lBQ2hCO1lBQ0F1QixPQUFPdW9CO1lBQ1B2b0IsT0FBT3dvQjtRQUNUO0lBQ0YsR0FBRztRQUFDSjtRQUFPTztRQUFnQkY7UUFBaUJ6QixPQUFPTyxNQUFNO1FBQUVQLE9BQU94USxPQUFPO1FBQUUrUDtLQUFVO0lBQ3JGLE1BQU1qUSxXQUFXbGlCLHlEQUFXQSxDQUFDLElBQU1xMEIsZ0JBQWdCekIsT0FBTzFRLFFBQVEsR0FBRztRQUFDbVM7UUFBaUJ6QixPQUFPMVEsUUFBUTtLQUFDO0lBQ3ZHLE1BQU1DLFdBQVduaUIseURBQVdBLENBQUNvRyxDQUFBQTtRQUMzQixJQUFJQSxXQUFXLFFBQVE7WUFDckJpdUIsZ0JBQWdCekIsT0FBT1EsYUFBYTtZQUNwQztRQUNGO1FBQ0FpQixnQkFBZ0J6QixPQUFPVyxVQUFVO0lBQ25DLEdBQUc7UUFBQ2M7UUFBaUJ6QixPQUFPUSxhQUFhO1FBQUVSLE9BQU9XLFVBQVU7S0FBQztJQUM3RCxNQUFNblIsVUFBVXBpQix5REFBV0EsQ0FBQztRQUMxQixJQUFJLENBQUNvMEIsV0FBVy9wQixPQUFPLEVBQUU7WUFDdkI7UUFDRjtRQUNBZ3FCLGdCQUFnQnpCLE9BQU94USxPQUFPO0lBQ2hDLEdBQUc7UUFBQ2lTO1FBQWlCekIsT0FBT3hRLE9BQU87S0FBQztJQUNwQyxNQUFNWCxVQUFVMWhCLHFEQUFPQSxDQUFDLElBQU87WUFDN0JtaUI7WUFDQUM7WUFDQUM7UUFDRixJQUFJO1FBQUNGO1FBQVVDO1FBQVVDO0tBQVE7SUFDakMsT0FBT1g7QUFDVDtBQUVBLFNBQVNtVCxpQkFBaUJDLFVBQVUsRUFBRWhDLFFBQVE7SUFDNUMsT0FBT2lDLE1BQU1DLElBQUksQ0FBQ0YsV0FBV0QsZ0JBQWdCLENBQUMvQjtBQUNoRDtBQUVBLElBQUltQyxrQkFBbUI3eUIsQ0FBQUEsS0FBTUEsSUFBSTh5QixlQUFlQyxlQUFlenpCO0FBRS9ELFNBQVMwekIsY0FBY2h6QixFQUFFO0lBQ3ZCLE9BQU9BLGNBQWM2eUIsZ0JBQWdCN3lCLElBQUlpekIsV0FBVztBQUN0RDtBQUVBLFNBQVNDLGVBQWVsRCxTQUFTLEVBQUV0c0IsV0FBVztJQUM1QyxNQUFNZ3RCLFdBQVcsQ0FBQyxDQUFDLEVBQUVaLFdBQVdFLFNBQVMsQ0FBQyxFQUFFLEVBQUVBLFVBQVUsRUFBRSxDQUFDO0lBQzNELE1BQU1tRCxXQUFXVixpQkFBaUIxUCxVQUFVMk47SUFDNUMsSUFBSSxDQUFDeUMsU0FBUzlvQixNQUFNLEVBQUU7UUFoNUl4QixLQWk1SXlDLEdBQUc3SyxRQUFRLENBQUMsZ0RBQWdELEVBQUV3d0IsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFNO1FBQ3pILE9BQU87SUFDVDtJQUNBLE1BQU1vRCxTQUFTRCxTQUFTeGtCLElBQUksQ0FBQzNPLENBQUFBO1FBQzNCLE9BQU9BLEdBQUdxekIsWUFBWSxDQUFDdkQsV0FBV3BzQixXQUFXLE1BQU1BO0lBQ3JEO0lBQ0EsSUFBSSxDQUFDMHZCLFFBQVE7UUF2NUlmLEtBdzVJeUMsR0FBRzV6QixRQUFRLENBQUMsb0NBQW9DLEVBQUVrRSxZQUFZLDJDQUEyQyxDQUFDLElBQUksQ0FBTTtRQUN6SixPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUNzdkIsY0FBY0ksU0FBUztRQTM1STlCLEtBNDVJeUMsR0FBRzV6QixRQUFRLDJDQUEyQyxDQUFNO1FBQ2pHLE9BQU87SUFDVDtJQUNBLE9BQU80ekI7QUFDVDtBQUVBLFNBQVNFLGdCQUFnQnRELFNBQVM7SUFDaEMsTUFBTXVELGFBQWF2MkIsNkNBQU1BLENBQUMsQ0FBQztJQUMzQixNQUFNdzJCLFlBQVl4MkIsNkNBQU1BLENBQUM7SUFDekIsTUFBTXkyQix1QkFBdUJ6MkIsNkNBQU1BLENBQUM7SUFDcEMsTUFBTTAyQixlQUFlMTJCLDZDQUFNQSxDQUFDO0lBQzVCLE1BQU0yMkIsV0FBVzkxQix5REFBV0EsQ0FBQyxTQUFTODFCLFNBQVNwd0IsRUFBRSxFQUFFNGpCLEtBQUs7UUFDdEQsTUFBTTVDLFFBQVE7WUFDWmhoQjtZQUNBNGpCO1FBQ0Y7UUFDQW9NLFdBQVdyckIsT0FBTyxDQUFDM0UsR0FBRyxHQUFHZ2hCO1FBQ3pCLE9BQU8sU0FBU3FQO1lBQ2QsTUFBTXhQLFVBQVVtUCxXQUFXcnJCLE9BQU87WUFDbEMsTUFBTUEsVUFBVWtjLE9BQU8sQ0FBQzdnQixHQUFHO1lBQzNCLElBQUkyRSxZQUFZcWMsT0FBTztnQkFDckIsT0FBT0gsT0FBTyxDQUFDN2dCLEdBQUc7WUFDcEI7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUNMLE1BQU1zd0IsZUFBZWgyQix5REFBV0EsQ0FBQyxTQUFTZzJCLGFBQWFDLGNBQWM7UUFDbkUsTUFBTVYsU0FBU0YsZUFBZWxELFdBQVc4RDtRQUN6QyxJQUFJVixVQUFVQSxXQUFXclEsU0FBU2dSLGFBQWEsRUFBRTtZQUMvQ1gsT0FBT2pNLEtBQUs7UUFDZDtJQUNGLEdBQUc7UUFBQzZJO0tBQVU7SUFDZCxNQUFNekksaUJBQWlCMXBCLHlEQUFXQSxDQUFDLFNBQVMwcEIsZUFBZWpmLFFBQVEsRUFBRTByQixVQUFVO1FBQzdFLElBQUlSLFVBQVV0ckIsT0FBTyxLQUFLSSxVQUFVO1lBQ2xDa3JCLFVBQVV0ckIsT0FBTyxHQUFHOHJCO1FBQ3RCO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsTUFBTTFNLDBCQUEwQnpwQix5REFBV0EsQ0FBQyxTQUFTeXBCO1FBQ25ELElBQUltTSxxQkFBcUJ2ckIsT0FBTyxFQUFFO1lBQ2hDO1FBQ0Y7UUFDQSxJQUFJLENBQUN3ckIsYUFBYXhyQixPQUFPLEVBQUU7WUFDekI7UUFDRjtRQUNBdXJCLHFCQUFxQnZyQixPQUFPLEdBQUc2ZSxzQkFBc0I7WUFDbkQwTSxxQkFBcUJ2ckIsT0FBTyxHQUFHO1lBQy9CLE1BQU0rckIsU0FBU1QsVUFBVXRyQixPQUFPO1lBQ2hDLElBQUkrckIsUUFBUTtnQkFDVkosYUFBYUk7WUFDZjtRQUNGO0lBQ0YsR0FBRztRQUFDSjtLQUFhO0lBQ2pCLE1BQU14TSxpQkFBaUJ4cEIseURBQVdBLENBQUMsU0FBU3dwQixlQUFlOWpCLEVBQUU7UUFDM0Rpd0IsVUFBVXRyQixPQUFPLEdBQUc7UUFDcEIsTUFBTWdzQixVQUFVblIsU0FBU2dSLGFBQWE7UUFDdEMsSUFBSSxDQUFDRyxTQUFTO1lBQ1o7UUFDRjtRQUNBLElBQUlBLFFBQVFiLFlBQVksQ0FBQ3ZELFdBQVdwc0IsV0FBVyxNQUFNSCxJQUFJO1lBQ3ZEO1FBQ0Y7UUFDQWl3QixVQUFVdHJCLE9BQU8sR0FBRzNFO0lBQ3RCLEdBQUcsRUFBRTtJQUNMMUcsZ0JBQWdCO1FBQ2Q2MkIsYUFBYXhyQixPQUFPLEdBQUc7UUFDdkIsT0FBTyxTQUFTaXNCO1lBQ2RULGFBQWF4ckIsT0FBTyxHQUFHO1lBQ3ZCLE1BQU13ZSxVQUFVK00scUJBQXFCdnJCLE9BQU87WUFDNUMsSUFBSXdlLFNBQVM7Z0JBQ1hFLHFCQUFxQkY7WUFDdkI7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUNMLE1BQU1wSCxVQUFVMWhCLHFEQUFPQSxDQUFDLElBQU87WUFDN0IrMUI7WUFDQXRNO1lBQ0FDO1lBQ0FDO1FBQ0YsSUFBSTtRQUFDb007UUFBVXRNO1FBQWdCQztRQUF5QkM7S0FBZTtJQUN2RSxPQUFPakk7QUFDVDtBQUVBLFNBQVM4VTtJQUNQLE1BQU1oUSxVQUFVO1FBQ2QzYixZQUFZLENBQUM7UUFDYkwsWUFBWSxDQUFDO0lBQ2Y7SUFDQSxNQUFNaXNCLGNBQWMsRUFBRTtJQUN0QixTQUFTakssVUFBVWtLLEVBQUU7UUFDbkJELFlBQVlubUIsSUFBSSxDQUFDb21CO1FBQ2pCLE9BQU8sU0FBU3BLO1lBQ2QsTUFBTXRuQixRQUFReXhCLFlBQVl2bEIsT0FBTyxDQUFDd2xCO1lBQ2xDLElBQUkxeEIsVUFBVSxDQUFDLEdBQUc7Z0JBQ2hCO1lBQ0Y7WUFDQXl4QixZQUFZN1AsTUFBTSxDQUFDNWhCLE9BQU87UUFDNUI7SUFDRjtJQUNBLFNBQVMyeEIsT0FBTzN5QixLQUFLO1FBQ25CLElBQUl5eUIsWUFBWWhxQixNQUFNLEVBQUU7WUFDdEJncUIsWUFBWXh6QixPQUFPLENBQUN5ekIsQ0FBQUEsS0FBTUEsR0FBRzF5QjtRQUMvQjtJQUNGO0lBQ0EsU0FBUzR5QixrQkFBa0JqeEIsRUFBRTtRQUMzQixPQUFPNmdCLFFBQVEzYixVQUFVLENBQUNsRixHQUFHLElBQUk7SUFDbkM7SUFDQSxTQUFTa3hCLGlCQUFpQmx4QixFQUFFO1FBQzFCLE1BQU1naEIsUUFBUWlRLGtCQUFrQmp4QjtRQUNoQyxDQUFDZ2hCLFFBQVE5bEIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLHFDQUFxQyxFQUFFbUMsR0FBRyxDQUFDLENBQUMsSUFBSW5DLENBQWdCLEdBQUcsS0FBSztRQUMzSSxPQUFPbWpCO0lBQ1Q7SUFDQSxNQUFNbVEsZUFBZTtRQUNuQmYsVUFBVXBQLENBQUFBO1lBQ1JILFFBQVEzYixVQUFVLENBQUM4YixNQUFNaGMsVUFBVSxDQUFDaEYsRUFBRSxDQUFDLEdBQUdnaEI7WUFDMUNnUSxPQUFPO2dCQUNMbDFCLE1BQU07Z0JBQ05SLE9BQU8wbEI7WUFDVDtRQUNGO1FBQ0EzZ0IsUUFBUSxDQUFDMmdCLE9BQU9oYTtZQUNkLE1BQU1yQyxVQUFVa2MsUUFBUTNiLFVBQVUsQ0FBQzhCLEtBQUtoQyxVQUFVLENBQUNoRixFQUFFLENBQUM7WUFDdEQsSUFBSSxDQUFDMkUsU0FBUztnQkFDWjtZQUNGO1lBQ0EsSUFBSUEsUUFBUXlzQixRQUFRLEtBQUtwUSxNQUFNb1EsUUFBUSxFQUFFO2dCQUN2QztZQUNGO1lBQ0EsT0FBT3ZRLFFBQVEzYixVQUFVLENBQUM4QixLQUFLaEMsVUFBVSxDQUFDaEYsRUFBRSxDQUFDO1lBQzdDNmdCLFFBQVEzYixVQUFVLENBQUM4YixNQUFNaGMsVUFBVSxDQUFDaEYsRUFBRSxDQUFDLEdBQUdnaEI7UUFDNUM7UUFDQXFQLFlBQVlyUCxDQUFBQTtZQUNWLE1BQU03Z0IsY0FBYzZnQixNQUFNaGMsVUFBVSxDQUFDaEYsRUFBRTtZQUN2QyxNQUFNMkUsVUFBVXNzQixrQkFBa0I5d0I7WUFDbEMsSUFBSSxDQUFDd0UsU0FBUztnQkFDWjtZQUNGO1lBQ0EsSUFBSXFjLE1BQU1vUSxRQUFRLEtBQUt6c0IsUUFBUXlzQixRQUFRLEVBQUU7Z0JBQ3ZDO1lBQ0Y7WUFDQSxPQUFPdlEsUUFBUTNiLFVBQVUsQ0FBQy9FLFlBQVk7WUFDdEMsSUFBSTBnQixRQUFRaGMsVUFBVSxDQUFDbWMsTUFBTWhjLFVBQVUsQ0FBQ3BGLFdBQVcsQ0FBQyxFQUFFO2dCQUNwRG94QixPQUFPO29CQUNMbDFCLE1BQU07b0JBQ05SLE9BQU8wbEI7Z0JBQ1Q7WUFDRjtRQUNGO1FBQ0FrRSxTQUFTZ007UUFDVEcsVUFBVUo7UUFDVnpLLFFBQVF4bUIsQ0FBQUEsS0FBTTRMLFFBQVFxbEIsa0JBQWtCanhCO1FBQ3hDbW1CLGNBQWNycUIsQ0FBQUEsT0FBUXNKLE9BQU9DLE1BQU0sQ0FBQ3diLFFBQVEzYixVQUFVLEVBQUVNLE1BQU0sQ0FBQ3diLENBQUFBLFFBQVNBLE1BQU1oYyxVQUFVLENBQUNsSixJQUFJLEtBQUtBO0lBQ3BHO0lBQ0EsU0FBU3cxQixrQkFBa0J0eEIsRUFBRTtRQUMzQixPQUFPNmdCLFFBQVFoYyxVQUFVLENBQUM3RSxHQUFHLElBQUk7SUFDbkM7SUFDQSxTQUFTdXhCLGlCQUFpQnZ4QixFQUFFO1FBQzFCLE1BQU1naEIsUUFBUXNRLGtCQUFrQnR4QjtRQUNoQyxDQUFDZ2hCLFFBQVE5bEIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLHFDQUFxQyxFQUFFbUMsR0FBRyxDQUFDLENBQUMsSUFBSW5DLENBQWdCLEdBQUcsS0FBSztRQUMzSSxPQUFPbWpCO0lBQ1Q7SUFDQSxNQUFNd1EsZUFBZTtRQUNuQnBCLFVBQVVwUCxDQUFBQTtZQUNSSCxRQUFRaGMsVUFBVSxDQUFDbWMsTUFBTWhjLFVBQVUsQ0FBQ2hGLEVBQUUsQ0FBQyxHQUFHZ2hCO1FBQzVDO1FBQ0FxUCxZQUFZclAsQ0FBQUE7WUFDVixNQUFNcmMsVUFBVTJzQixrQkFBa0J0USxNQUFNaGMsVUFBVSxDQUFDaEYsRUFBRTtZQUNyRCxJQUFJLENBQUMyRSxTQUFTO2dCQUNaO1lBQ0Y7WUFDQSxJQUFJcWMsTUFBTW9RLFFBQVEsS0FBS3pzQixRQUFReXNCLFFBQVEsRUFBRTtnQkFDdkM7WUFDRjtZQUNBLE9BQU92USxRQUFRaGMsVUFBVSxDQUFDbWMsTUFBTWhjLFVBQVUsQ0FBQ2hGLEVBQUUsQ0FBQztRQUNoRDtRQUNBa2xCLFNBQVNxTTtRQUNURixVQUFVQztRQUNWOUssUUFBUXhtQixDQUFBQSxLQUFNNEwsUUFBUTBsQixrQkFBa0J0eEI7UUFDeENtbUIsY0FBY3JxQixDQUFBQSxPQUFRc0osT0FBT0MsTUFBTSxDQUFDd2IsUUFBUWhjLFVBQVUsRUFBRVcsTUFBTSxDQUFDd2IsQ0FBQUEsUUFBU0EsTUFBTWhjLFVBQVUsQ0FBQ2xKLElBQUksS0FBS0E7SUFDcEc7SUFDQSxTQUFTaXVCO1FBQ1BsSixRQUFRM2IsVUFBVSxHQUFHLENBQUM7UUFDdEIyYixRQUFRaGMsVUFBVSxHQUFHLENBQUM7UUFDdEJpc0IsWUFBWWhxQixNQUFNLEdBQUc7SUFDdkI7SUFDQSxPQUFPO1FBQ0xyQixXQUFXMHJCO1FBQ1g5c0IsV0FBV210QjtRQUNYM0s7UUFDQWtEO0lBQ0Y7QUFDRjtBQUVBLFNBQVMwSDtJQUNQLE1BQU0xTSxXQUFXMXFCLHFEQUFPQSxDQUFDdzJCLGdCQUFnQixFQUFFO0lBQzNDcjNCLGdEQUFTQSxDQUFDO1FBQ1IsT0FBTyxTQUFTazRCO1lBQ2QsSUFBSXI0QixvREFBYSxDQUFDdTRCLFVBQVUsQ0FBQyxTQUFTdjRCLG9EQUFhLENBQUN1NEIsVUFBVSxDQUFDLE9BQU87Z0JBQ3BFcE8sc0JBQXNCdUIsU0FBU2dGLEtBQUs7WUFDdEMsT0FBTztnQkFDTGhGLFNBQVNnRixLQUFLO1lBQ2hCO1FBQ0Y7SUFDRixHQUFHO1FBQUNoRjtLQUFTO0lBQ2IsT0FBT0E7QUFDVDtBQUVBLElBQUk4TSw2QkFBZXg0QiwwREFBbUIsQ0FBQztBQUV2QyxJQUFJMDRCLGlCQUFrQjtJQUNwQixNQUFNaEUsT0FBT3ZPLFNBQVN1TyxJQUFJO0lBQzFCLENBQUNBLE9BQU83eUIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywrQkFBK0JBLENBQWdCLEdBQUcsS0FBSztJQUN4SCxPQUFPa3dCO0FBQ1Q7QUFFQSxNQUFNaUUsaUJBQWlCO0lBQ3JCNXlCLFVBQVU7SUFDVnNELE9BQU87SUFDUEMsUUFBUTtJQUNSc0ssUUFBUTtJQUNSZ2xCLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxVQUFVO0lBQ1YxdUIsTUFBTTtJQUNOLGFBQWE7QUFDZjtBQUNBLElBQUkydUIsbUJBQW1CSjtBQUV2QixNQUFNSyxRQUFRNUYsQ0FBQUEsWUFBYSxDQUFDLGlCQUFpQixFQUFFQSxVQUFVLENBQUM7QUFDMUQsU0FBUzZGLGFBQWE3RixTQUFTO0lBQzdCLE1BQU16c0IsS0FBSzNGLHFEQUFPQSxDQUFDLElBQU1nNEIsTUFBTTVGLFlBQVk7UUFBQ0E7S0FBVTtJQUN0RCxNQUFNdUMsTUFBTXYxQiw2Q0FBTUEsQ0FBQztJQUNuQkQsZ0RBQVNBLENBQUMsU0FBUys0QjtRQUNqQixNQUFNOTFCLEtBQUsraUIsU0FBU3lPLGFBQWEsQ0FBQztRQUNsQ2UsSUFBSXJxQixPQUFPLEdBQUdsSTtRQUNkQSxHQUFHdUQsRUFBRSxHQUFHQTtRQUNSdkQsR0FBRzh4QixZQUFZLENBQUMsYUFBYTtRQUM3Qjl4QixHQUFHOHhCLFlBQVksQ0FBQyxlQUFlO1FBQy9CdnpCLDhFQUFRQSxDQUFDeUIsR0FBRzhmLEtBQUssRUFBRTZWO1FBQ25CTCxpQkFBaUJoRCxXQUFXLENBQUN0eUI7UUFDN0IsT0FBTyxTQUFTKzFCO1lBQ2Q5UixXQUFXLFNBQVN4YTtnQkFDbEIsTUFBTTZuQixPQUFPZ0U7Z0JBQ2IsSUFBSWhFLEtBQUtqZCxRQUFRLENBQUNyVSxLQUFLO29CQUNyQnN4QixLQUFLa0IsV0FBVyxDQUFDeHlCO2dCQUNuQjtnQkFDQSxJQUFJQSxPQUFPdXlCLElBQUlycUIsT0FBTyxFQUFFO29CQUN0QnFxQixJQUFJcnFCLE9BQU8sR0FBRztnQkFDaEI7WUFDRjtRQUNGO0lBQ0YsR0FBRztRQUFDM0U7S0FBRztJQUNQLE1BQU1zZ0IsV0FBV2htQix5REFBV0EsQ0FBQ29CLENBQUFBO1FBQzNCLE1BQU1lLEtBQUt1eUIsSUFBSXJxQixPQUFPO1FBQ3RCLElBQUlsSSxJQUFJO1lBQ05BLEdBQUdteUIsV0FBVyxHQUFHbHpCO1lBQ2pCO1FBQ0Y7UUEzcEpKLEtBNHBKeUMsR0FBR08sUUFBUSxDQUFDOzs7Ozs7OztPQVE5QyxFQUFFUCxRQUFRO0lBQ2IsQ0FBQyxJQUFJLENBQU07SUFDYixHQUFHLEVBQUU7SUFDTCxPQUFPNGtCO0FBQ1Q7QUFFQSxJQUFJbVMsVUFBVTtBQUNkLE1BQU1DLFdBQVc7SUFDZkMsV0FBVztBQUNiO0FBQ0EsU0FBU0M7SUFDUEgsVUFBVTtBQUNaO0FBQ0EsU0FBU0ksc0JBQXNCdkcsTUFBTSxFQUFFdnZCLE9BQU87SUFDNUMsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUyMUI7SUFDWjtJQUNBLE9BQU9yNEIscURBQU9BLENBQUMsSUFBTSxDQUFDLEVBQUVpeUIsT0FBTyxFQUFFdnZCLFFBQVE0MUIsU0FBUyxDQUFDLEVBQUVGLFVBQVUsQ0FBQyxFQUFFO1FBQUMxMUIsUUFBUTQxQixTQUFTO1FBQUVyRztLQUFPO0FBQy9GO0FBQ0EsU0FBU3dHLFlBQVl4RyxNQUFNLEVBQUV2dkIsT0FBTztJQUNsQyxJQUFJQSxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVTIxQjtJQUNaO0lBQ0EsTUFBTTF5QixLQUFLM0csa0RBQVc7SUFDdEIsT0FBT2dCLHFEQUFPQSxDQUFDLElBQU0sQ0FBQyxFQUFFaXlCLE9BQU8sRUFBRXZ2QixRQUFRNDFCLFNBQVMsQ0FBQyxFQUFFM3lCLEdBQUcsQ0FBQyxFQUFFO1FBQUNqRCxRQUFRNDFCLFNBQVM7UUFBRXJHO1FBQVF0c0I7S0FBRztBQUM1RjtBQUNBLElBQUlnekIsZ0JBQWdCLHlEQUFnQjM1QixHQUFHeTVCLGNBQWNEO0FBRXJELFNBQVNJLGFBQWFwdkIsSUFBSTtJQUN4QixJQUFJLEVBQ0Y0b0IsU0FBUyxFQUNUMkUsUUFBUSxFQUNULEdBQUd2dEI7SUFDSixPQUFPLENBQUMsZ0JBQWdCLEVBQUU0b0IsVUFBVSxDQUFDLEVBQUUyRSxTQUFTLENBQUM7QUFDbkQ7QUFDQSxTQUFTOEIscUJBQXFCaG9CLEtBQUs7SUFDakMsSUFBSSxFQUNGdWhCLFNBQVMsRUFDVDBHLElBQUksRUFDTCxHQUFHam9CO0lBQ0osTUFBTWttQixXQUFXNEIsY0FBYyxlQUFlO1FBQzVDTCxXQUFXO0lBQ2I7SUFDQSxNQUFNM3lCLEtBQUszRixxREFBT0EsQ0FBQyxJQUFNNDRCLGFBQWE7WUFDcEN4RztZQUNBMkU7UUFDRixJQUFJO1FBQUNBO1FBQVUzRTtLQUFVO0lBQ3pCanpCLGdEQUFTQSxDQUFDLFNBQVM0NUI7UUFDakIsTUFBTTMyQixLQUFLK2lCLFNBQVN5TyxhQUFhLENBQUM7UUFDbEN4eEIsR0FBR3VELEVBQUUsR0FBR0E7UUFDUnZELEdBQUdteUIsV0FBVyxHQUFHdUU7UUFDakIxMkIsR0FBRzhmLEtBQUssQ0FBQzhXLE9BQU8sR0FBRztRQUNuQnRCLGlCQUFpQmhELFdBQVcsQ0FBQ3R5QjtRQUM3QixPQUFPLFNBQVNpMUI7WUFDZCxNQUFNM0QsT0FBT2dFO1lBQ2IsSUFBSWhFLEtBQUtqZCxRQUFRLENBQUNyVSxLQUFLO2dCQUNyQnN4QixLQUFLa0IsV0FBVyxDQUFDeHlCO1lBQ25CO1FBQ0Y7SUFDRixHQUFHO1FBQUN1RDtRQUFJbXpCO0tBQUs7SUFDYixPQUFPbnpCO0FBQ1Q7QUFFQSxJQUFJc3pCLDJCQUFhajZCLDBEQUFtQixDQUFDO0FBRXJDLElBQUlrNkIsbUJBQW1CO0lBQ3RCQyxPQUFPO0lBQ1AsYUFBYTtBQUNkO0FBRUEsTUFBTUMsU0FBUztBQUNmLE1BQU1DLGFBQWFwNEIsQ0FBQUE7SUFDakIsTUFBTW1GLFNBQVNnekIsT0FBT0UsSUFBSSxDQUFDcjRCO0lBQzNCLENBQUVtRixDQUFBQSxVQUFVLElBQUcsSUFBS3ZGLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyw4QkFBOEIsRUFBRXZDLE1BQU0sQ0FBQyxJQUFJdUMsQ0FBZ0IsR0FBRyxLQUFLO0lBQ2pKLE1BQU0rMUIsUUFBUXRWLE9BQU83ZCxNQUFNLENBQUMsRUFBRTtJQUM5QixNQUFNb3pCLFFBQVF2VixPQUFPN2QsTUFBTSxDQUFDLEVBQUU7SUFDOUIsTUFBTWMsUUFBUStjLE9BQU83ZCxNQUFNLENBQUMsRUFBRTtJQUM5QixPQUFPO1FBQ0xtekI7UUFDQUM7UUFDQXR5QjtRQUNBdXlCLEtBQUt4NEI7SUFDUDtBQUNGO0FBQ0EsTUFBTXk0QixjQUFjLENBQUNDLFVBQVVDO0lBQzdCLElBQUlBLE9BQU9MLEtBQUssR0FBR0ksU0FBU0osS0FBSyxFQUFFO1FBQ2pDLE9BQU87SUFDVDtJQUNBLElBQUlLLE9BQU9MLEtBQUssR0FBR0ksU0FBU0osS0FBSyxFQUFFO1FBQ2pDLE9BQU87SUFDVDtJQUNBLElBQUlLLE9BQU9KLEtBQUssR0FBR0csU0FBU0gsS0FBSyxFQUFFO1FBQ2pDLE9BQU87SUFDVDtJQUNBLElBQUlJLE9BQU9KLEtBQUssR0FBR0csU0FBU0gsS0FBSyxFQUFFO1FBQ2pDLE9BQU87SUFDVDtJQUNBLE9BQU9JLE9BQU8xeUIsS0FBSyxJQUFJeXlCLFNBQVN6eUIsS0FBSztBQUN2QztBQUNBLElBQUkyeUIsb0JBQXFCLENBQUNDLGNBQWNDO0lBQ3RDLE1BQU1DLFVBQVVYLFdBQVdTO0lBQzNCLE1BQU1GLFNBQVNQLFdBQVdVO0lBQzFCLElBQUlMLFlBQVlNLFNBQVNKLFNBQVM7UUFDaEM7SUFDRjtJQTV3SkYsS0E2d0p1QyxHQUFHaDRCLFFBQVEsQ0FBQztvQkFDL0IsRUFBRWc0QixPQUFPSCxHQUFHLENBQUM7d0RBQ3VCLEVBQUVPLFFBQVFQLEdBQUcsQ0FBQzs7O0VBR3BFLENBQUMsSUFBSSxDQUFNO0FBQ2I7QUFFQSxNQUFNUSxTQUFTLENBQUM7Ozs7O0FBS2hCLENBQUM7QUFDRCxJQUFJQyxlQUFnQjVPLENBQUFBO0lBQ2xCLE1BQU02TyxVQUFVN08sSUFBSTZPLE9BQU87SUFDM0IsSUFBSSxDQUFDQSxTQUFTO1FBN3hKaEIsS0E4eEp5QyxHQUFHdjRCLFFBQVEsQ0FBQzs7O01BRy9DLEVBQUVxNEIsT0FBTztJQUNYLENBQUMsSUFBSSxDQUFNO1FBQ1g7SUFDRjtJQUNBLElBQUlFLFFBQVEvUCxJQUFJLENBQUNnUSxXQUFXLE9BQU8sUUFBUTtRQXJ5SjdDLEtBc3lKeUMsR0FBR3g0QixRQUFRLENBQUM7b0NBQ2pCLEVBQUV1NEIsUUFBUS9QLElBQUksQ0FBQzs7TUFFN0MsRUFBRTZQLE9BQU87SUFDWCxDQUFDLElBQUksQ0FBTTtJQUNiO0lBQ0EsSUFBSUUsUUFBUUUsUUFBUSxLQUFLLElBQUk7UUE1eUovQixLQTZ5SnlDLEdBQUd6NEIsUUFBUSxDQUFDOzZDQUNSLEVBQUV1NEIsUUFBUUUsUUFBUSxDQUFDOzs7TUFHMUQsRUFBRUosT0FBTztJQUNYLENBQUMsSUFBSSxDQUFNO0lBQ2I7QUFDRjtBQUVBLFNBQVNLLE9BQU9DLE9BQU87SUFDckIsSUFBSTE1QixJQUF5QixFQUFjO1FBQ3pDMDVCO0lBQ0Y7QUFDRjtBQUVBLFNBQVNDLG1CQUFtQjMzQixFQUFFLEVBQUU0M0IsTUFBTTtJQUNwQ0gsT0FBTztRQUNMbjdCLGdEQUFTQSxDQUFDO1lBQ1IsSUFBSTtnQkFDRjBEO1lBQ0YsRUFBRSxPQUFPNjNCLEdBQUc7Z0JBQ1Y1NEIsTUFBTSxDQUFDOzs7WUFHSCxFQUFFNDRCLEVBQUVyNUIsT0FBTyxDQUFDO1FBQ2hCLENBQUM7WUFDSDtRQUNGLEdBQUdvNUI7SUFDTDtBQUNGO0FBRUEsU0FBU0U7SUFDUEgsbUJBQW1CO1FBQ2pCWCxrQkFBa0JYLGlCQUFpQkMsS0FBSyxFQUFFbjZCLHNEQUFhO1FBQ3ZEazdCLGFBQWEvVTtJQUNmLEdBQUcsRUFBRTtBQUNQO0FBRUEsU0FBU3lWLFlBQVl0d0IsT0FBTztJQUMxQixNQUFNcXFCLE1BQU12MUIsNkNBQU1BLENBQUNrTDtJQUNuQm5MLGdEQUFTQSxDQUFDO1FBQ1J3MUIsSUFBSXJxQixPQUFPLEdBQUdBO0lBQ2hCO0lBQ0EsT0FBT3FxQjtBQUNUO0FBRUEsU0FBU2tHO0lBQ1AsSUFBSUMsT0FBTztJQUNYLFNBQVNDO1FBQ1AsT0FBT3hwQixRQUFRdXBCO0lBQ2pCO0lBQ0EsU0FBU3RWLFNBQVN2a0IsS0FBSztRQUNyQixPQUFPQSxVQUFVNjVCO0lBQ25CO0lBQ0EsU0FBU0UsTUFBTUMsT0FBTztRQUNwQixDQUFDLENBQUNILE9BQU9qNkIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxnREFBZ0RBLENBQWdCLEdBQUcsS0FBSztRQUMxSSxNQUFNMDNCLFVBQVU7WUFDZEQ7UUFDRjtRQUNBSCxPQUFPSTtRQUNQLE9BQU9BO0lBQ1Q7SUFDQSxTQUFTQztRQUNQLENBQUNMLE9BQU9qNkIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywrQ0FBK0NBLENBQWdCLEdBQUcsS0FBSztRQUN4SXMzQixPQUFPO0lBQ1Q7SUFDQSxTQUFTTTtRQUNQLElBQUlOLE1BQU07WUFDUkEsS0FBS0csT0FBTztZQUNaRTtRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xKO1FBQ0F2VjtRQUNBd1Y7UUFDQUc7UUFDQUM7SUFDRjtBQUNGO0FBRUEsU0FBU2wzQixXQUFXNlUsS0FBSztJQUN2QixJQUFJQSxNQUFNVSxLQUFLLEtBQUssVUFBVVYsTUFBTVUsS0FBSyxLQUFLLGtCQUFrQjtRQUM5RCxPQUFPO0lBQ1Q7SUFDQSxPQUFPVixNQUFNN1UsVUFBVTtBQUN6QjtBQUVBLE1BQU1tM0IsTUFBTTtBQUNaLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLFNBQVM7QUFDZixNQUFNQyxXQUFXO0FBQ2pCLE1BQU12eUIsTUFBTTtBQUNaLE1BQU1nUSxPQUFPO0FBQ2IsTUFBTXdpQixZQUFZO0FBQ2xCLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxZQUFZO0FBRWxCLE1BQU1DLGdCQUFnQjtJQUNwQixDQUFDVCxNQUFNLEVBQUU7SUFDVCxDQUFDRCxJQUFJLEVBQUU7QUFDVDtBQUNBLElBQUlXLDJCQUE0Qmg0QixDQUFBQTtJQUM5QixJQUFJKzNCLGFBQWEsQ0FBQy8zQixNQUFNaTRCLE9BQU8sQ0FBQyxFQUFFO1FBQ2hDajRCLE1BQU1LLGNBQWM7SUFDdEI7QUFDRjtBQUVBLE1BQU02M0IscUJBQXFCLENBQUM7SUFDMUIsTUFBTS9KLE9BQU87SUFDYixJQUFJLE9BQU9oTixhQUFhLGFBQWE7UUFDbkMsT0FBT2dOO0lBQ1Q7SUFDQSxNQUFNaGMsYUFBYTtRQUFDZ2M7UUFBTSxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDO1FBQUUsQ0FBQyxNQUFNLEVBQUVBLEtBQUssQ0FBQztRQUFFLENBQUMsR0FBRyxFQUFFQSxLQUFLLENBQUM7UUFBRSxDQUFDLENBQUMsRUFBRUEsS0FBSyxDQUFDO0tBQUM7SUFDakYsTUFBTWdLLFlBQVlobUIsV0FBV3BGLElBQUksQ0FBQ25PLENBQUFBLFlBQWEsQ0FBQyxFQUFFLEVBQUVBLFVBQVUsQ0FBQyxJQUFJdWlCO0lBQ25FLE9BQU9nWCxhQUFhaEs7QUFDdEI7QUFDQSxJQUFJaUssbUNBQW1DRjtBQUV2QyxNQUFNRyxnQkFBZ0I7QUFDdEIsTUFBTUMsdUJBQXVCO0FBQzdCLFNBQVNDLCtCQUErQjFvQixRQUFRLEVBQUV2SixPQUFPO0lBQ3ZELE9BQU9oRCxLQUFLazFCLEdBQUcsQ0FBQ2x5QixRQUFRN0QsQ0FBQyxHQUFHb04sU0FBU3BOLENBQUMsS0FBSzYxQix3QkFBd0JoMUIsS0FBS2sxQixHQUFHLENBQUNseUIsUUFBUTVELENBQUMsR0FBR21OLFNBQVNuTixDQUFDLEtBQUs0MUI7QUFDekc7QUFDQSxNQUFNRyxTQUFTO0lBQ2JoN0IsTUFBTTtBQUNSO0FBQ0EsU0FBU2k3QixtQkFBbUJsekIsSUFBSTtJQUM5QixJQUFJLEVBQ0ZrYyxNQUFNLEVBQ056RyxTQUFTLEVBQ1QwZCxRQUFRLEVBQ1JDLFFBQVEsRUFDVCxHQUFHcHpCO0lBQ0osT0FBTztRQUFDO1lBQ041RyxXQUFXO1lBQ1hDLElBQUltQixDQUFBQTtnQkFDRixNQUFNLEVBQ0o2NEIsTUFBTSxFQUNOQyxPQUFPLEVBQ1BDLE9BQU8sRUFDUixHQUFHLzRCO2dCQUNKLElBQUk2NEIsV0FBV1IsZUFBZTtvQkFDNUI7Z0JBQ0Y7Z0JBQ0EsTUFBTXAxQixRQUFRO29CQUNaUixHQUFHcTJCO29CQUNIcDJCLEdBQUdxMkI7Z0JBQ0w7Z0JBQ0EsTUFBTXRqQixRQUFRa2pCO2dCQUNkLElBQUlsakIsTUFBTWhZLElBQUksS0FBSyxZQUFZO29CQUM3QnVDLE1BQU1LLGNBQWM7b0JBQ3BCb1YsTUFBTXVqQixPQUFPLENBQUMzYyxJQUFJLENBQUNwWjtvQkFDbkI7Z0JBQ0Y7Z0JBQ0EsQ0FBRXdTLENBQUFBLE1BQU1oWSxJQUFJLEtBQUssU0FBUSxJQUFLWixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLG9CQUFvQkEsQ0FBZ0IsR0FBRyxLQUFLO2dCQUNuSSxNQUFNeTVCLFVBQVV4akIsTUFBTXhTLEtBQUs7Z0JBQzNCLElBQUksQ0FBQ3MxQiwrQkFBK0JVLFNBQVNoMkIsUUFBUTtvQkFDbkQ7Z0JBQ0Y7Z0JBQ0FqRCxNQUFNSyxjQUFjO2dCQUNwQixNQUFNMjRCLFVBQVV2akIsTUFBTXVqQixPQUFPLENBQUNFLFNBQVMsQ0FBQ2oyQjtnQkFDeEMyMUIsU0FBUztvQkFDUG43QixNQUFNO29CQUNOdTdCO2dCQUNGO1lBQ0Y7UUFDRjtRQUFHO1lBQ0RwNkIsV0FBVztZQUNYQyxJQUFJbUIsQ0FBQUE7Z0JBQ0YsTUFBTXlWLFFBQVFrakI7Z0JBQ2QsSUFBSWxqQixNQUFNaFksSUFBSSxLQUFLLFlBQVk7b0JBQzdCaWtCO29CQUNBO2dCQUNGO2dCQUNBMWhCLE1BQU1LLGNBQWM7Z0JBQ3BCb1YsTUFBTXVqQixPQUFPLENBQUN4YSxJQUFJLENBQUM7b0JBQ2pCMmEsc0JBQXNCO2dCQUN4QjtnQkFDQWxlO1lBQ0Y7UUFDRjtRQUFHO1lBQ0RyYyxXQUFXO1lBQ1hDLElBQUltQixDQUFBQTtnQkFDRixJQUFJMjRCLFdBQVdsN0IsSUFBSSxLQUFLLFlBQVk7b0JBQ2xDdUMsTUFBTUssY0FBYztnQkFDdEI7Z0JBQ0FxaEI7WUFDRjtRQUNGO1FBQUc7WUFDRDlpQixXQUFXO1lBQ1hDLElBQUltQixDQUFBQTtnQkFDRixNQUFNeVYsUUFBUWtqQjtnQkFDZCxJQUFJbGpCLE1BQU1oWSxJQUFJLEtBQUssV0FBVztvQkFDNUJpa0I7b0JBQ0E7Z0JBQ0Y7Z0JBQ0EsSUFBSTFoQixNQUFNaTRCLE9BQU8sS0FBS1YsUUFBUTtvQkFDNUJ2M0IsTUFBTUssY0FBYztvQkFDcEJxaEI7b0JBQ0E7Z0JBQ0Y7Z0JBQ0FzVyx5QkFBeUJoNEI7WUFDM0I7UUFDRjtRQUFHO1lBQ0RwQixXQUFXO1lBQ1hDLElBQUk2aUI7UUFDTjtRQUFHO1lBQ0Q5aUIsV0FBVztZQUNYRixTQUFTO2dCQUNQdWlCLFNBQVM7Z0JBQ1RDLFNBQVM7WUFDWDtZQUNBcmlCLElBQUk7Z0JBQ0YsSUFBSTg1QixXQUFXbDdCLElBQUksS0FBSyxXQUFXO29CQUNqQ2lrQjtnQkFDRjtZQUNGO1FBQ0Y7UUFBRztZQUNEOWlCLFdBQVc7WUFDWEMsSUFBSW1CLENBQUFBO2dCQUNGLE1BQU15VixRQUFRa2pCO2dCQUNkLENBQUVsakIsQ0FBQUEsTUFBTWhZLElBQUksS0FBSyxNQUFLLElBQUtaLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sc0JBQXNCQSxDQUFnQixHQUFHLEtBQUs7Z0JBQ2xJLElBQUlpVyxNQUFNdWpCLE9BQU8sQ0FBQ0ksdUJBQXVCLElBQUk7b0JBQzNDMVg7b0JBQ0E7Z0JBQ0Y7Z0JBQ0ExaEIsTUFBTUssY0FBYztZQUN0QjtRQUNGO1FBQUc7WUFDRHpCLFdBQVd3NUI7WUFDWHY1QixJQUFJNmlCO1FBQ047S0FBRTtBQUNKO0FBQ0EsU0FBUzJYLGVBQWVDLEdBQUc7SUFDekIsTUFBTUMsV0FBV24rQiw2Q0FBTUEsQ0FBQ3E5QjtJQUN4QixNQUFNZSxrQkFBa0JwK0IsNkNBQU1BLENBQUMyQztJQUMvQixNQUFNMDdCLHNCQUFzQno5QixxREFBT0EsQ0FBQyxJQUFPO1lBQ3pDNEMsV0FBVztZQUNYQyxJQUFJLFNBQVM2NkIsWUFBWTE1QixLQUFLO2dCQUM1QixJQUFJQSxNQUFNMjVCLGdCQUFnQixFQUFFO29CQUMxQjtnQkFDRjtnQkFDQSxJQUFJMzVCLE1BQU02NEIsTUFBTSxLQUFLUixlQUFlO29CQUNsQztnQkFDRjtnQkFDQSxJQUFJcjRCLE1BQU00NUIsT0FBTyxJQUFJNTVCLE1BQU02NUIsT0FBTyxJQUFJNzVCLE1BQU04NUIsUUFBUSxJQUFJOTVCLE1BQU0rNUIsTUFBTSxFQUFFO29CQUNwRTtnQkFDRjtnQkFDQSxNQUFNajRCLGNBQWN3M0IsSUFBSVUsc0JBQXNCLENBQUNoNkI7Z0JBQy9DLElBQUksQ0FBQzhCLGFBQWE7b0JBQ2hCO2dCQUNGO2dCQUNBLE1BQU1rM0IsVUFBVU0sSUFBSVcsVUFBVSxDQUFDbjRCLGFBQWEyZixNQUFNO29CQUNoRHlZLGFBQWFsNkI7Z0JBQ2Y7Z0JBQ0EsSUFBSSxDQUFDZzVCLFNBQVM7b0JBQ1o7Z0JBQ0Y7Z0JBQ0FoNUIsTUFBTUssY0FBYztnQkFDcEIsTUFBTTRDLFFBQVE7b0JBQ1pSLEdBQUd6QyxNQUFNODRCLE9BQU87b0JBQ2hCcDJCLEdBQUcxQyxNQUFNKzRCLE9BQU87Z0JBQ2xCO2dCQUNBUyxnQkFBZ0JsekIsT0FBTztnQkFDdkI2ekIsaUJBQWlCbkIsU0FBUy8xQjtZQUM1QjtRQUNGLElBQUk7UUFBQ3EyQjtLQUFJO0lBQ1QsTUFBTWMsMkJBQTJCcCtCLHFEQUFPQSxDQUFDLElBQU87WUFDOUM0QyxXQUFXO1lBQ1hDLElBQUltQixDQUFBQTtnQkFDRixJQUFJQSxNQUFNMjVCLGdCQUFnQixFQUFFO29CQUMxQjtnQkFDRjtnQkFDQSxNQUFNaDRCLEtBQUsyM0IsSUFBSVUsc0JBQXNCLENBQUNoNkI7Z0JBQ3RDLElBQUksQ0FBQzJCLElBQUk7b0JBQ1A7Z0JBQ0Y7Z0JBQ0EsTUFBTWpELFVBQVU0NkIsSUFBSWUsdUJBQXVCLENBQUMxNEI7Z0JBQzVDLElBQUksQ0FBQ2pELFNBQVM7b0JBQ1o7Z0JBQ0Y7Z0JBQ0EsSUFBSUEsUUFBUTA2Qix1QkFBdUIsRUFBRTtvQkFDbkM7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDRSxJQUFJZ0IsVUFBVSxDQUFDMzRCLEtBQUs7b0JBQ3ZCO2dCQUNGO2dCQUNBM0IsTUFBTUssY0FBYztZQUN0QjtRQUNGLElBQUk7UUFBQ2k1QjtLQUFJO0lBQ1QsTUFBTWlCLG1CQUFtQnQrQix5REFBV0EsQ0FBQyxTQUFTcytCO1FBQzVDLE1BQU03N0IsVUFBVTtZQUNkdWlCLFNBQVM7WUFDVEMsU0FBUztRQUNYO1FBQ0FzWSxnQkFBZ0JsekIsT0FBTyxHQUFHbkksV0FBV1QsUUFBUTtZQUFDMDhCO1lBQTBCWDtTQUFvQixFQUFFLzZCO0lBQ2hHLEdBQUc7UUFBQzA3QjtRQUEwQlg7S0FBb0I7SUFDbEQsTUFBTWhZLE9BQU94bEIseURBQVdBLENBQUM7UUFDdkIsTUFBTXFLLFVBQVVpekIsU0FBU2p6QixPQUFPO1FBQ2hDLElBQUlBLFFBQVE3SSxJQUFJLEtBQUssUUFBUTtZQUMzQjtRQUNGO1FBQ0E4N0IsU0FBU2p6QixPQUFPLEdBQUdteUI7UUFDbkJlLGdCQUFnQmx6QixPQUFPO1FBQ3ZCaTBCO0lBQ0YsR0FBRztRQUFDQTtLQUFpQjtJQUNyQixNQUFNN1ksU0FBU3psQix5REFBV0EsQ0FBQztRQUN6QixNQUFNd1osUUFBUThqQixTQUFTanpCLE9BQU87UUFDOUJtYjtRQUNBLElBQUloTSxNQUFNaFksSUFBSSxLQUFLLFlBQVk7WUFDN0JnWSxNQUFNdWpCLE9BQU8sQ0FBQ3RYLE1BQU0sQ0FBQztnQkFDbkJ5WCxzQkFBc0I7WUFDeEI7UUFDRjtRQUNBLElBQUkxakIsTUFBTWhZLElBQUksS0FBSyxXQUFXO1lBQzVCZ1ksTUFBTXVqQixPQUFPLENBQUN4VSxLQUFLO1FBQ3JCO0lBQ0YsR0FBRztRQUFDL0M7S0FBSztJQUNULE1BQU0rWSxzQkFBc0J2K0IseURBQVdBLENBQUMsU0FBU3UrQjtRQUMvQyxNQUFNOTdCLFVBQVU7WUFDZHdpQixTQUFTO1lBQ1RELFNBQVM7UUFDWDtRQUNBLE1BQU01aUIsV0FBV3E2QixtQkFBbUI7WUFDbENoWDtZQUNBekcsV0FBV3dHO1lBQ1hrWCxVQUFVLElBQU1ZLFNBQVNqekIsT0FBTztZQUNoQ3N5QixVQUFVbmpCLENBQUFBO2dCQUNSOGpCLFNBQVNqekIsT0FBTyxHQUFHbVA7WUFDckI7UUFDRjtRQUNBK2pCLGdCQUFnQmx6QixPQUFPLEdBQUduSSxXQUFXVCxRQUFRVyxVQUFVSztJQUN6RCxHQUFHO1FBQUNnakI7UUFBUUQ7S0FBSztJQUNqQixNQUFNMFksbUJBQW1CbCtCLHlEQUFXQSxDQUFDLFNBQVNrK0IsaUJBQWlCbkIsT0FBTyxFQUFFLzFCLEtBQUs7UUFDM0UsQ0FBRXMyQixDQUFBQSxTQUFTanpCLE9BQU8sQ0FBQzdJLElBQUksS0FBSyxNQUFLLElBQUtaLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sZ0RBQWdEQSxDQUFnQixHQUFHLEtBQUs7UUFDdksrNUIsU0FBU2p6QixPQUFPLEdBQUc7WUFDakI3SSxNQUFNO1lBQ053RjtZQUNBKzFCO1FBQ0Y7UUFDQXdCO0lBQ0YsR0FBRztRQUFDQTtLQUFvQjtJQUN4QnYvQixnQkFBZ0IsU0FBUzg1QjtRQUN2QndGO1FBQ0EsT0FBTyxTQUFTbEg7WUFDZG1HLGdCQUFnQmx6QixPQUFPO1FBQ3pCO0lBQ0YsR0FBRztRQUFDaTBCO0tBQWlCO0FBQ3ZCO0FBRUEsU0FBU0UsVUFBVTtBQUNuQixNQUFNQyxpQkFBaUI7SUFDckIsQ0FBQ2hELFNBQVMsRUFBRTtJQUNaLENBQUNELE9BQU8sRUFBRTtJQUNWLENBQUN0aUIsS0FBSyxFQUFFO0lBQ1IsQ0FBQ2hRLElBQUksRUFBRTtBQUNUO0FBQ0EsU0FBU3cxQixvQkFBb0IzQixPQUFPLEVBQUV2WCxJQUFJO0lBQ3hDLFNBQVNDO1FBQ1BEO1FBQ0F1WCxRQUFRdFgsTUFBTTtJQUNoQjtJQUNBLFNBQVNsRDtRQUNQaUQ7UUFDQXVYLFFBQVF4YSxJQUFJO0lBQ2Q7SUFDQSxPQUFPO1FBQUM7WUFDTjVmLFdBQVc7WUFDWEMsSUFBSW1CLENBQUFBO2dCQUNGLElBQUlBLE1BQU1pNEIsT0FBTyxLQUFLVixRQUFRO29CQUM1QnYzQixNQUFNSyxjQUFjO29CQUNwQnFoQjtvQkFDQTtnQkFDRjtnQkFDQSxJQUFJMWhCLE1BQU1pNEIsT0FBTyxLQUFLVCxPQUFPO29CQUMzQngzQixNQUFNSyxjQUFjO29CQUNwQm1lO29CQUNBO2dCQUNGO2dCQUNBLElBQUl4ZSxNQUFNaTRCLE9BQU8sS0FBS0gsV0FBVztvQkFDL0I5M0IsTUFBTUssY0FBYztvQkFDcEIyNEIsUUFBUXZjLFFBQVE7b0JBQ2hCO2dCQUNGO2dCQUNBLElBQUl6YyxNQUFNaTRCLE9BQU8sS0FBS0wsU0FBUztvQkFDN0I1M0IsTUFBTUssY0FBYztvQkFDcEIyNEIsUUFBUXhjLE1BQU07b0JBQ2Q7Z0JBQ0Y7Z0JBQ0EsSUFBSXhjLE1BQU1pNEIsT0FBTyxLQUFLSixZQUFZO29CQUNoQzczQixNQUFNSyxjQUFjO29CQUNwQjI0QixRQUFRdGMsU0FBUztvQkFDakI7Z0JBQ0Y7Z0JBQ0EsSUFBSTFjLE1BQU1pNEIsT0FBTyxLQUFLTixXQUFXO29CQUMvQjMzQixNQUFNSyxjQUFjO29CQUNwQjI0QixRQUFRcmMsUUFBUTtvQkFDaEI7Z0JBQ0Y7Z0JBQ0EsSUFBSStkLGNBQWMsQ0FBQzE2QixNQUFNaTRCLE9BQU8sQ0FBQyxFQUFFO29CQUNqQ2o0QixNQUFNSyxjQUFjO29CQUNwQjtnQkFDRjtnQkFDQTIzQix5QkFBeUJoNEI7WUFDM0I7UUFDRjtRQUFHO1lBQ0RwQixXQUFXO1lBQ1hDLElBQUk2aUI7UUFDTjtRQUFHO1lBQ0Q5aUIsV0FBVztZQUNYQyxJQUFJNmlCO1FBQ047UUFBRztZQUNEOWlCLFdBQVc7WUFDWEMsSUFBSTZpQjtRQUNOO1FBQUc7WUFDRDlpQixXQUFXO1lBQ1hDLElBQUk2aUI7UUFDTjtRQUFHO1lBQ0Q5aUIsV0FBVztZQUNYQyxJQUFJNmlCO1FBQ047UUFBRztZQUNEOWlCLFdBQVc7WUFDWEMsSUFBSTZpQjtZQUNKaGpCLFNBQVM7Z0JBQ1B1aUIsU0FBUztZQUNYO1FBQ0Y7UUFBRztZQUNEcmlCLFdBQVd3NUI7WUFDWHY1QixJQUFJNmlCO1FBQ047S0FBRTtBQUNKO0FBQ0EsU0FBU2taLGtCQUFrQnRCLEdBQUc7SUFDNUIsTUFBTUUsa0JBQWtCcCtCLDZDQUFNQSxDQUFDcS9CO0lBQy9CLE1BQU1oQixzQkFBc0J6OUIscURBQU9BLENBQUMsSUFBTztZQUN6QzRDLFdBQVc7WUFDWEMsSUFBSSxTQUFTZzhCLFVBQVU3NkIsS0FBSztnQkFDMUIsSUFBSUEsTUFBTTI1QixnQkFBZ0IsRUFBRTtvQkFDMUI7Z0JBQ0Y7Z0JBQ0EsSUFBSTM1QixNQUFNaTRCLE9BQU8sS0FBS1QsT0FBTztvQkFDM0I7Z0JBQ0Y7Z0JBQ0EsTUFBTTExQixjQUFjdzNCLElBQUlVLHNCQUFzQixDQUFDaDZCO2dCQUMvQyxJQUFJLENBQUM4QixhQUFhO29CQUNoQjtnQkFDRjtnQkFDQSxNQUFNZzVCLFVBQVV4QixJQUFJVyxVQUFVLENBQUNuNEIsYUFBYTJmLE1BQU07b0JBQ2hEeVksYUFBYWw2QjtnQkFDZjtnQkFDQSxJQUFJLENBQUM4NkIsU0FBUztvQkFDWjtnQkFDRjtnQkFDQTk2QixNQUFNSyxjQUFjO2dCQUNwQixJQUFJMDZCLGNBQWM7Z0JBQ2xCLE1BQU0vQixVQUFVOEIsUUFBUUUsUUFBUTtnQkFDaEN4QixnQkFBZ0JsekIsT0FBTztnQkFDdkIsU0FBU21iO29CQUNQLENBQUNzWixjQUFjbCtCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sOERBQThEQSxDQUFnQixHQUFHLEtBQUs7b0JBQzlKdTdCLGNBQWM7b0JBQ2R2QixnQkFBZ0JsekIsT0FBTztvQkFDdkJpMEI7Z0JBQ0Y7Z0JBQ0FmLGdCQUFnQmx6QixPQUFPLEdBQUduSSxXQUFXVCxRQUFRaTlCLG9CQUFvQjNCLFNBQVN2WCxPQUFPO29CQUMvRVAsU0FBUztvQkFDVEQsU0FBUztnQkFDWDtZQUNGO1FBQ0YsSUFBSTtRQUFDcVk7S0FBSTtJQUNULE1BQU1pQixtQkFBbUJ0K0IseURBQVdBLENBQUMsU0FBU2cvQjtRQUM1QyxNQUFNdjhCLFVBQVU7WUFDZHVpQixTQUFTO1lBQ1RDLFNBQVM7UUFDWDtRQUNBc1ksZ0JBQWdCbHpCLE9BQU8sR0FBR25JLFdBQVdULFFBQVE7WUFBQys3QjtTQUFvQixFQUFFLzZCO0lBQ3RFLEdBQUc7UUFBQys2QjtLQUFvQjtJQUN4QngrQixnQkFBZ0IsU0FBUzg1QjtRQUN2QndGO1FBQ0EsT0FBTyxTQUFTbEg7WUFDZG1HLGdCQUFnQmx6QixPQUFPO1FBQ3pCO0lBQ0YsR0FBRztRQUFDaTBCO0tBQWlCO0FBQ3ZCO0FBRUEsTUFBTVcsT0FBTztJQUNYejlCLE1BQU07QUFDUjtBQUNBLE1BQU0wOUIsbUJBQW1CO0FBQ3pCLE1BQU1DLHNCQUFzQjtBQUM1QixTQUFTQyxrQkFBa0I3MUIsSUFBSTtJQUM3QixJQUFJLEVBQ0ZrYyxNQUFNLEVBQ05pWCxRQUFRLEVBQ1QsR0FBR256QjtJQUNKLE9BQU87UUFBQztZQUNONUcsV0FBVztZQUNYQyxJQUFJNmlCO1FBQ047UUFBRztZQUNEOWlCLFdBQVc7WUFDWEMsSUFBSTZpQjtRQUNOO1FBQUc7WUFDRDlpQixXQUFXO1lBQ1hDLElBQUltQixDQUFBQTtnQkFDRkEsTUFBTUssY0FBYztZQUN0QjtRQUNGO1FBQUc7WUFDRHpCLFdBQVc7WUFDWEMsSUFBSW1CLENBQUFBO2dCQUNGLElBQUkyNEIsV0FBV2w3QixJQUFJLEtBQUssWUFBWTtvQkFDbENpa0I7b0JBQ0E7Z0JBQ0Y7Z0JBQ0EsSUFBSTFoQixNQUFNaTRCLE9BQU8sS0FBS1YsUUFBUTtvQkFDNUJ2M0IsTUFBTUssY0FBYztnQkFDdEI7Z0JBQ0FxaEI7WUFDRjtRQUNGO1FBQUc7WUFDRDlpQixXQUFXdzVCO1lBQ1h2NUIsSUFBSTZpQjtRQUNOO0tBQUU7QUFDSjtBQUNBLFNBQVM0WixrQkFBa0J6dUIsS0FBSztJQUM5QixJQUFJLEVBQ0Y2VSxNQUFNLEVBQ056RyxTQUFTLEVBQ1QwZCxRQUFRLEVBQ1QsR0FBRzlyQjtJQUNKLE9BQU87UUFBQztZQUNOak8sV0FBVztZQUNYRixTQUFTO2dCQUNQd2lCLFNBQVM7WUFDWDtZQUNBcmlCLElBQUltQixDQUFBQTtnQkFDRixNQUFNeVYsUUFBUWtqQjtnQkFDZCxJQUFJbGpCLE1BQU1oWSxJQUFJLEtBQUssWUFBWTtvQkFDN0Jpa0I7b0JBQ0E7Z0JBQ0Y7Z0JBQ0FqTSxNQUFNOGxCLFFBQVEsR0FBRztnQkFDakIsTUFBTSxFQUNKekMsT0FBTyxFQUNQQyxPQUFPLEVBQ1IsR0FBRy80QixNQUFNdzdCLE9BQU8sQ0FBQyxFQUFFO2dCQUNwQixNQUFNdjRCLFFBQVE7b0JBQ1pSLEdBQUdxMkI7b0JBQ0hwMkIsR0FBR3EyQjtnQkFDTDtnQkFDQS80QixNQUFNSyxjQUFjO2dCQUNwQm9WLE1BQU11akIsT0FBTyxDQUFDM2MsSUFBSSxDQUFDcFo7WUFDckI7UUFDRjtRQUFHO1lBQ0RyRSxXQUFXO1lBQ1hDLElBQUltQixDQUFBQTtnQkFDRixNQUFNeVYsUUFBUWtqQjtnQkFDZCxJQUFJbGpCLE1BQU1oWSxJQUFJLEtBQUssWUFBWTtvQkFDN0Jpa0I7b0JBQ0E7Z0JBQ0Y7Z0JBQ0ExaEIsTUFBTUssY0FBYztnQkFDcEJvVixNQUFNdWpCLE9BQU8sQ0FBQ3hhLElBQUksQ0FBQztvQkFDakIyYSxzQkFBc0I7Z0JBQ3hCO2dCQUNBbGU7WUFDRjtRQUNGO1FBQUc7WUFDRHJjLFdBQVc7WUFDWEMsSUFBSW1CLENBQUFBO2dCQUNGLElBQUkyNEIsV0FBV2w3QixJQUFJLEtBQUssWUFBWTtvQkFDbENpa0I7b0JBQ0E7Z0JBQ0Y7Z0JBQ0ExaEIsTUFBTUssY0FBYztnQkFDcEJxaEI7WUFDRjtRQUNGO1FBQUc7WUFDRDlpQixXQUFXO1lBQ1hDLElBQUltQixDQUFBQTtnQkFDRixNQUFNeVYsUUFBUWtqQjtnQkFDZCxDQUFFbGpCLENBQUFBLE1BQU1oWSxJQUFJLEtBQUssTUFBSyxJQUFLWixLQUFxQyxHQUFHMkMsVUFBVSxTQUFTQSxDQUFnQixHQUFHLEtBQUs7Z0JBQzlHLE1BQU1pOEIsUUFBUXo3QixNQUFNdzdCLE9BQU8sQ0FBQyxFQUFFO2dCQUM5QixJQUFJLENBQUNDLE9BQU87b0JBQ1Y7Z0JBQ0Y7Z0JBQ0EsTUFBTUMsZUFBZUQsTUFBTUUsS0FBSyxJQUFJUDtnQkFDcEMsSUFBSSxDQUFDTSxjQUFjO29CQUNqQjtnQkFDRjtnQkFDQSxNQUFNRSxnQkFBZ0JubUIsTUFBTXVqQixPQUFPLENBQUNJLHVCQUF1QjtnQkFDM0QsSUFBSTNqQixNQUFNaFksSUFBSSxLQUFLLFdBQVc7b0JBQzVCLElBQUltK0IsZUFBZTt3QkFDakJsYTtvQkFDRjtvQkFDQTtnQkFDRjtnQkFDQSxJQUFJa2EsZUFBZTtvQkFDakIsSUFBSW5tQixNQUFNOGxCLFFBQVEsRUFBRTt3QkFDbEJ2N0IsTUFBTUssY0FBYzt3QkFDcEI7b0JBQ0Y7b0JBQ0FxaEI7b0JBQ0E7Z0JBQ0Y7Z0JBQ0ExaEIsTUFBTUssY0FBYztZQUN0QjtRQUNGO1FBQUc7WUFDRHpCLFdBQVd3NUI7WUFDWHY1QixJQUFJNmlCO1FBQ047S0FBRTtBQUNKO0FBQ0EsU0FBU21hLGVBQWV2QyxHQUFHO0lBQ3pCLE1BQU1DLFdBQVduK0IsNkNBQU1BLENBQUM4L0I7SUFDeEIsTUFBTTFCLGtCQUFrQnArQiw2Q0FBTUEsQ0FBQzJDO0lBQy9CLE1BQU00NkIsV0FBVzE4Qix5REFBV0EsQ0FBQyxTQUFTMDhCO1FBQ3BDLE9BQU9ZLFNBQVNqekIsT0FBTztJQUN6QixHQUFHLEVBQUU7SUFDTCxNQUFNc3lCLFdBQVczOEIseURBQVdBLENBQUMsU0FBUzI4QixTQUFTbmpCLEtBQUs7UUFDbEQ4akIsU0FBU2p6QixPQUFPLEdBQUdtUDtJQUNyQixHQUFHLEVBQUU7SUFDTCxNQUFNZ2tCLHNCQUFzQno5QixxREFBT0EsQ0FBQyxJQUFPO1lBQ3pDNEMsV0FBVztZQUNYQyxJQUFJLFNBQVNpOUIsYUFBYTk3QixLQUFLO2dCQUM3QixJQUFJQSxNQUFNMjVCLGdCQUFnQixFQUFFO29CQUMxQjtnQkFDRjtnQkFDQSxNQUFNNzNCLGNBQWN3M0IsSUFBSVUsc0JBQXNCLENBQUNoNkI7Z0JBQy9DLElBQUksQ0FBQzhCLGFBQWE7b0JBQ2hCO2dCQUNGO2dCQUNBLE1BQU1rM0IsVUFBVU0sSUFBSVcsVUFBVSxDQUFDbjRCLGFBQWEyZixNQUFNO29CQUNoRHlZLGFBQWFsNkI7Z0JBQ2Y7Z0JBQ0EsSUFBSSxDQUFDZzVCLFNBQVM7b0JBQ1o7Z0JBQ0Y7Z0JBQ0EsTUFBTXlDLFFBQVF6N0IsTUFBTXc3QixPQUFPLENBQUMsRUFBRTtnQkFDOUIsTUFBTSxFQUNKMUMsT0FBTyxFQUNQQyxPQUFPLEVBQ1IsR0FBRzBDO2dCQUNKLE1BQU14NEIsUUFBUTtvQkFDWlIsR0FBR3EyQjtvQkFDSHAyQixHQUFHcTJCO2dCQUNMO2dCQUNBUyxnQkFBZ0JsekIsT0FBTztnQkFDdkI2ekIsaUJBQWlCbkIsU0FBUy8xQjtZQUM1QjtRQUNGLElBQUk7UUFBQ3EyQjtLQUFJO0lBQ1QsTUFBTWlCLG1CQUFtQnQrQix5REFBV0EsQ0FBQyxTQUFTcytCO1FBQzVDLE1BQU03N0IsVUFBVTtZQUNkd2lCLFNBQVM7WUFDVEQsU0FBUztRQUNYO1FBQ0F1WSxnQkFBZ0JsekIsT0FBTyxHQUFHbkksV0FBV1QsUUFBUTtZQUFDKzdCO1NBQW9CLEVBQUUvNkI7SUFDdEUsR0FBRztRQUFDKzZCO0tBQW9CO0lBQ3hCLE1BQU1oWSxPQUFPeGxCLHlEQUFXQSxDQUFDO1FBQ3ZCLE1BQU1xSyxVQUFVaXpCLFNBQVNqekIsT0FBTztRQUNoQyxJQUFJQSxRQUFRN0ksSUFBSSxLQUFLLFFBQVE7WUFDM0I7UUFDRjtRQUNBLElBQUk2SSxRQUFRN0ksSUFBSSxLQUFLLFdBQVc7WUFDOUI2a0IsYUFBYWhjLFFBQVF5MUIsZ0JBQWdCO1FBQ3ZDO1FBQ0FuRCxTQUFTc0M7UUFDVDFCLGdCQUFnQmx6QixPQUFPO1FBQ3ZCaTBCO0lBQ0YsR0FBRztRQUFDQTtRQUFrQjNCO0tBQVM7SUFDL0IsTUFBTWxYLFNBQVN6bEIseURBQVdBLENBQUM7UUFDekIsTUFBTXdaLFFBQVE4akIsU0FBU2p6QixPQUFPO1FBQzlCbWI7UUFDQSxJQUFJaE0sTUFBTWhZLElBQUksS0FBSyxZQUFZO1lBQzdCZ1ksTUFBTXVqQixPQUFPLENBQUN0WCxNQUFNLENBQUM7Z0JBQ25CeVgsc0JBQXNCO1lBQ3hCO1FBQ0Y7UUFDQSxJQUFJMWpCLE1BQU1oWSxJQUFJLEtBQUssV0FBVztZQUM1QmdZLE1BQU11akIsT0FBTyxDQUFDeFUsS0FBSztRQUNyQjtJQUNGLEdBQUc7UUFBQy9DO0tBQUs7SUFDVCxNQUFNK1ksc0JBQXNCditCLHlEQUFXQSxDQUFDLFNBQVN1K0I7UUFDL0MsTUFBTTk3QixVQUFVO1lBQ2R3aUIsU0FBUztZQUNURCxTQUFTO1FBQ1g7UUFDQSxNQUFNdFYsT0FBTztZQUNYK1Y7WUFDQXpHLFdBQVd3RztZQUNYa1g7UUFDRjtRQUNBLE1BQU1xRCxlQUFlNzlCLFdBQVdULFFBQVE0OUIsa0JBQWtCM3ZCLE9BQU9qTjtRQUNqRSxNQUFNdTlCLGVBQWU5OUIsV0FBV1QsUUFBUTI5QixrQkFBa0IxdkIsT0FBT2pOO1FBQ2pFODZCLGdCQUFnQmx6QixPQUFPLEdBQUcsU0FBU3RIO1lBQ2pDZzlCO1lBQ0FDO1FBQ0Y7SUFDRixHQUFHO1FBQUN2YTtRQUFRaVg7UUFBVWxYO0tBQUs7SUFDM0IsTUFBTXlhLGdCQUFnQmpnQyx5REFBV0EsQ0FBQyxTQUFTaWdDO1FBQ3pDLE1BQU16bUIsUUFBUWtqQjtRQUNkLENBQUVsakIsQ0FBQUEsTUFBTWhZLElBQUksS0FBSyxTQUFRLElBQUtaLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyxpQ0FBaUMsRUFBRWlXLE1BQU1oWSxJQUFJLENBQUMsQ0FBQyxJQUFJK0IsQ0FBZ0IsR0FBRyxLQUFLO1FBQ25LLE1BQU13NUIsVUFBVXZqQixNQUFNdWpCLE9BQU8sQ0FBQ0UsU0FBUyxDQUFDempCLE1BQU14UyxLQUFLO1FBQ25EMjFCLFNBQVM7WUFDUG43QixNQUFNO1lBQ051N0I7WUFDQXVDLFVBQVU7UUFDWjtJQUNGLEdBQUc7UUFBQzVDO1FBQVVDO0tBQVM7SUFDdkIsTUFBTXVCLG1CQUFtQmwrQix5REFBV0EsQ0FBQyxTQUFTaytCLGlCQUFpQm5CLE9BQU8sRUFBRS8xQixLQUFLO1FBQzNFLENBQUUwMUIsQ0FBQUEsV0FBV2w3QixJQUFJLEtBQUssTUFBSyxJQUFLWixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLGdEQUFnREEsQ0FBZ0IsR0FBRyxLQUFLO1FBQ2pLLE1BQU11OEIsbUJBQW1CMVosV0FBVzZaLGVBQWVmO1FBQ25EdkMsU0FBUztZQUNQbjdCLE1BQU07WUFDTndGO1lBQ0ErMUI7WUFDQStDO1FBQ0Y7UUFDQXZCO0lBQ0YsR0FBRztRQUFDQTtRQUFxQjdCO1FBQVVDO1FBQVVzRDtLQUFjO0lBQzNEamhDLGdCQUFnQixTQUFTODVCO1FBQ3ZCd0Y7UUFDQSxPQUFPLFNBQVNsSDtZQUNkbUcsZ0JBQWdCbHpCLE9BQU87WUFDdkIsTUFBTW1QLFFBQVFrakI7WUFDZCxJQUFJbGpCLE1BQU1oWSxJQUFJLEtBQUssV0FBVztnQkFDNUI2a0IsYUFBYTdNLE1BQU1zbUIsZ0JBQWdCO2dCQUNuQ25ELFNBQVNzQztZQUNYO1FBQ0Y7SUFDRixHQUFHO1FBQUN2QztRQUFVNEI7UUFBa0IzQjtLQUFTO0lBQ3pDMzlCLGdCQUFnQixTQUFTa2hDO1FBQ3ZCLE1BQU1yOUIsU0FBU1gsV0FBV1QsUUFBUTtZQUFDO2dCQUNqQ2tCLFdBQVc7Z0JBQ1hDLElBQUksS0FBTztnQkFDWEgsU0FBUztvQkFDUHdpQixTQUFTO29CQUNURCxTQUFTO2dCQUNYO1lBQ0Y7U0FBRTtRQUNGLE9BQU9uaUI7SUFDVCxHQUFHLEVBQUU7QUFDUDtBQUVBLFNBQVNzOUIsdUJBQXVCQyxXQUFXO0lBQ3pDL0YsT0FBTztRQUNMLE1BQU1nRyxjQUFjMUYsWUFBWXlGO1FBQ2hDN0YsbUJBQW1CO1lBQ2pCLENBQUU4RixDQUFBQSxZQUFZaDJCLE9BQU8sQ0FBQ21DLE1BQU0sS0FBSzR6QixZQUFZNXpCLE1BQU0sSUFBSTVMLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sNkRBQTZEQSxDQUFnQixHQUFHLEtBQUs7UUFDdk07SUFDRjtBQUNGO0FBRUEsTUFBTSs4QixzQkFBc0I7SUFBQztJQUFTO0lBQVU7SUFBWTtJQUFVO0lBQVU7SUFBWTtJQUFTO0NBQVE7QUFDN0csU0FBU0MsdUJBQXVCQyxNQUFNLEVBQUVuMkIsT0FBTztJQUM3QyxJQUFJQSxXQUFXLE1BQU07UUFDbkIsT0FBTztJQUNUO0lBQ0EsTUFBTW8yQixzQkFBc0JILG9CQUFvQkksUUFBUSxDQUFDcjJCLFFBQVFzMkIsT0FBTyxDQUFDeEcsV0FBVztJQUNwRixJQUFJc0cscUJBQXFCO1FBQ3ZCLE9BQU87SUFDVDtJQUNBLE1BQU1sTyxZQUFZbG9CLFFBQVFtckIsWUFBWSxDQUFDO0lBQ3ZDLElBQUlqRCxjQUFjLFVBQVVBLGNBQWMsSUFBSTtRQUM1QyxPQUFPO0lBQ1Q7SUFDQSxJQUFJbG9CLFlBQVltMkIsUUFBUTtRQUN0QixPQUFPO0lBQ1Q7SUFDQSxPQUFPRCx1QkFBdUJDLFFBQVFuMkIsUUFBUXUyQixhQUFhO0FBQzdEO0FBQ0EsU0FBU0MsNEJBQTRCMTFCLFNBQVMsRUFBRXBILEtBQUs7SUFDbkQsTUFBTXlELFNBQVN6RCxNQUFNeUQsTUFBTTtJQUMzQixJQUFJLENBQUMydEIsY0FBYzN0QixTQUFTO1FBQzFCLE9BQU87SUFDVDtJQUNBLE9BQU8rNEIsdUJBQXVCcDFCLFdBQVczRDtBQUMzQztBQUVBLElBQUlzNUIsNkJBQThCMytCLENBQUFBLEtBQU1sQyxzREFBT0EsQ0FBQ2tDLEdBQUc0K0IscUJBQXFCLElBQUl6dUIsTUFBTTtBQUVsRixTQUFTMHVCLFVBQVU3K0IsRUFBRTtJQUNuQixPQUFPQSxjQUFjNnlCLGdCQUFnQjd5QixJQUFJOCtCLE9BQU87QUFDbEQ7QUFFQSxNQUFNQyx1QkFBdUIsQ0FBQztJQUM1QixNQUFNaFAsT0FBTztJQUNiLElBQUksT0FBT2hOLGFBQWEsYUFBYTtRQUNuQyxPQUFPZ047SUFDVDtJQUNBLE1BQU1oYyxhQUFhO1FBQUNnYztRQUFNO1FBQXFCO0tBQXdCO0lBQ3ZFLE1BQU1seEIsUUFBUWtWLFdBQVdwRixJQUFJLENBQUNxWixDQUFBQSxPQUFRQSxRQUFROFcsUUFBUTU5QixTQUFTO0lBQy9ELE9BQU9yQyxTQUFTa3hCO0FBQ2xCO0FBQ0EsU0FBU2lQLGdCQUFnQmgvQixFQUFFLEVBQUUwd0IsUUFBUTtJQUNuQyxJQUFJMXdCLE1BQU0sTUFBTTtRQUNkLE9BQU87SUFDVDtJQUNBLElBQUlBLEVBQUUsQ0FBQysrQixxQkFBcUIsQ0FBQ3JPLFdBQVc7UUFDdEMsT0FBTzF3QjtJQUNUO0lBQ0EsT0FBT2cvQixnQkFBZ0JoL0IsR0FBR3krQixhQUFhLEVBQUUvTjtBQUMzQztBQUNBLFNBQVNwZixRQUFRdFIsRUFBRSxFQUFFMHdCLFFBQVE7SUFDM0IsSUFBSTF3QixHQUFHc1IsT0FBTyxFQUFFO1FBQ2QsT0FBT3RSLEdBQUdzUixPQUFPLENBQUNvZjtJQUNwQjtJQUNBLE9BQU9zTyxnQkFBZ0JoL0IsSUFBSTB3QjtBQUM3QjtBQUVBLFNBQVNHLFlBQVliLFNBQVM7SUFDNUIsT0FBTyxDQUFDLENBQUMsRUFBRUYsV0FBV0UsU0FBUyxDQUFDLEVBQUUsRUFBRUEsVUFBVSxFQUFFLENBQUM7QUFDbkQ7QUFDQSxTQUFTaVAsK0JBQStCalAsU0FBUyxFQUFFcHVCLEtBQUs7SUFDdEQsTUFBTXlELFNBQVN6RCxNQUFNeUQsTUFBTTtJQUMzQixJQUFJLENBQUN3NUIsVUFBVXg1QixTQUFTO1FBNWxMMUIsS0E2bEx5QyxHQUFHN0YsUUFBUSxvQ0FBb0MsQ0FBTTtRQUMxRixPQUFPO0lBQ1Q7SUFDQSxNQUFNa3hCLFdBQVdHLFlBQVliO0lBQzdCLE1BQU1vRCxTQUFTOWhCLFFBQVFqTSxRQUFRcXJCO0lBQy9CLElBQUksQ0FBQzBDLFFBQVE7UUFDWCxPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUNKLGNBQWNJLFNBQVM7UUFybUw5QixLQXNtTHlDLEdBQUc1ekIsUUFBUSx1Q0FBdUMsQ0FBTTtRQUM3RixPQUFPO0lBQ1Q7SUFDQSxPQUFPNHpCO0FBQ1Q7QUFDQSxTQUFTOEwsa0NBQWtDbFAsU0FBUyxFQUFFcHVCLEtBQUs7SUFDekQsTUFBTXd4QixTQUFTNkwsK0JBQStCalAsV0FBV3B1QjtJQUN6RCxJQUFJLENBQUN3eEIsUUFBUTtRQUNYLE9BQU87SUFDVDtJQUNBLE9BQU9BLE9BQU9DLFlBQVksQ0FBQ3ZELFdBQVdwc0IsV0FBVztBQUNuRDtBQUVBLFNBQVN5N0IsY0FBY25QLFNBQVMsRUFBRXRzQixXQUFXO0lBQzNDLE1BQU1ndEIsV0FBVyxDQUFDLENBQUMsRUFBRTFuQixVQUFVZ25CLFNBQVMsQ0FBQyxFQUFFLEVBQUVBLFVBQVUsRUFBRSxDQUFDO0lBQzFELE1BQU1tRCxXQUFXVixpQkFBaUIxUCxVQUFVMk47SUFDNUMsTUFBTVEsY0FBY2lDLFNBQVN4a0IsSUFBSSxDQUFDM08sQ0FBQUE7UUFDaEMsT0FBT0EsR0FBR3F6QixZQUFZLENBQUNycUIsVUFBVXpGLEVBQUUsTUFBTUc7SUFDM0M7SUFDQSxJQUFJLENBQUN3dEIsYUFBYTtRQUNoQixPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUM4QixjQUFjOUIsY0FBYztRQTVuTG5DLEtBNm5MeUMsR0FBRzF4QixRQUFRLDRDQUE0QyxDQUFNO1FBQ2xHLE9BQU87SUFDVDtJQUNBLE9BQU8weEI7QUFDVDtBQUVBLFNBQVNqdkIsZUFBZUwsS0FBSztJQUMzQkEsTUFBTUssY0FBYztBQUN0QjtBQUNBLFNBQVNtaEIsU0FBU2hjLElBQUk7SUFDcEIsSUFBSSxFQUNGbXdCLFFBQVEsRUFDUmxnQixLQUFLLEVBQ0wrbkIsWUFBWSxFQUNaQyxVQUFVLEVBQ1gsR0FBR2o0QjtJQUNKLElBQUksQ0FBQ2c0QixnQkFBZ0I7UUFDbkIsSUFBSUMsWUFBWTtZQTlvTHBCLEtBK29MMkMsR0FBRzcvQixRQUFRLENBQUM7Ozs7Ozs7O01BUWpELENBQUMsSUFBSSxDQUFNO1FBQ2I7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxJQUFJKzNCLGFBQWFsZ0IsT0FBTztRQUN0QixJQUFJZ29CLFlBQVk7WUE1cExwQixLQTZwTDJDLEdBQUc3L0IsUUFBUSxDQUFDOzs7O3VCQUloQyxFQUFFKzNCLFNBQVM7a0RBQ2dCLEVBQUVsZ0IsTUFBTTs7Ozs7TUFLcEQsQ0FBQyxJQUFJLENBQU07UUFDYjtRQUNBLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNpb0IsU0FBUzd3QixLQUFLO0lBQ3JCLElBQUksRUFDRjh3QixPQUFPLEVBQ1A5YixLQUFLLEVBQ0w2RSxRQUFRLEVBQ1I1a0IsV0FBVyxFQUNaLEdBQUcrSztJQUNKLElBQUk4d0IsUUFBUTVHLFNBQVMsSUFBSTtRQUN2QixPQUFPO0lBQ1Q7SUFDQSxNQUFNcFUsUUFBUStELFNBQVN0ZixTQUFTLENBQUM0ckIsUUFBUSxDQUFDbHhCO0lBQzFDLElBQUksQ0FBQzZnQixPQUFPO1FBeHJMZCxLQXlyTHlDLEdBQUcva0IsUUFBUSxDQUFDLGtDQUFrQyxFQUFFa0UsWUFBWSxDQUFDLElBQUksQ0FBTTtRQUM1RyxPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUM2Z0IsTUFBTWprQixPQUFPLENBQUNnVCxTQUFTLEVBQUU7UUFDNUIsT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDK1csYUFBYTVHLE1BQU1sRSxRQUFRLElBQUk3YixjQUFjO1FBQ2hELE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVM4N0IsU0FBU3h1QixLQUFLO0lBQ3JCLElBQUksRUFDRnV1QixPQUFPLEVBQ1B2UCxTQUFTLEVBQ1R2TSxLQUFLLEVBQ0w2RSxRQUFRLEVBQ1I1a0IsV0FBVyxFQUNYKzdCLGVBQWUsRUFDZjNELFdBQVcsRUFDWixHQUFHOXFCO0lBQ0osTUFBTTB1QixjQUFjSixTQUFTO1FBQzNCQztRQUNBOWI7UUFDQTZFO1FBQ0E1a0I7SUFDRjtJQUNBLElBQUksQ0FBQ2c4QixhQUFhO1FBQ2hCLE9BQU87SUFDVDtJQUNBLE1BQU1uYixRQUFRK0QsU0FBU3RmLFNBQVMsQ0FBQ3lmLE9BQU8sQ0FBQy9rQjtJQUN6QyxNQUFNMUQsS0FBS20vQixjQUFjblAsV0FBV3pMLE1BQU1oYyxVQUFVLENBQUNoRixFQUFFO0lBQ3ZELElBQUksQ0FBQ3ZELElBQUk7UUF6dExYLEtBMHRMeUMsR0FBR1IsUUFBUSxDQUFDLDBDQUEwQyxFQUFFa0UsWUFBWSxDQUFDLElBQUksQ0FBTTtRQUNwSCxPQUFPO0lBQ1Q7SUFDQSxJQUFJbzRCLGVBQWUsQ0FBQ3ZYLE1BQU1qa0IsT0FBTyxDQUFDcS9CLDBCQUEwQixJQUFJakIsNEJBQTRCMStCLElBQUk4N0IsY0FBYztRQUM1RyxPQUFPO0lBQ1Q7SUFDQSxNQUFNcEQsT0FBTzZHLFFBQVEzRyxLQUFLLENBQUM2RyxtQkFBbUI5L0I7SUFDOUMsSUFBSTBYLFFBQVE7SUFDWixTQUFTdW9CO1FBQ1AsT0FBT3JiLE1BQU1qa0IsT0FBTyxDQUFDMDZCLHVCQUF1QjtJQUM5QztJQUNBLFNBQVNvRTtRQUNQLE9BQU9HLFFBQVFuYyxRQUFRLENBQUNzVjtJQUMxQjtJQUNBLFNBQVNtSCxZQUFZdEksUUFBUSxFQUFFdUksU0FBUztRQUN0QyxJQUFJMWMsU0FBUztZQUNYbVU7WUFDQWxnQjtZQUNBK25CO1lBQ0FDLFlBQVk7UUFDZCxJQUFJO1lBQ0Y1YixNQUFNakUsUUFBUSxDQUFDc2dCO1FBQ2pCO0lBQ0Y7SUFDQSxNQUFNQywwQkFBMEJGLFlBQVlwZ0MsSUFBSSxDQUFDLE1BQU07SUFDdkQsU0FBUzRmLEtBQUs5UixJQUFJO1FBQ2hCLFNBQVNzUDtZQUNQMGlCLFFBQVF4RyxPQUFPO1lBQ2YxaEIsUUFBUTtRQUNWO1FBQ0EsSUFBSUEsVUFBVSxZQUFZO1lBQ3hCd0Y7WUF6dkxOLEtBMHZMMkMsR0FBR3piLFVBQVUsT0FBTyxDQUFDLHFCQUFxQixFQUFFaVcsTUFBTSxDQUFDLElBQUlqVyxDQUFnQjtRQUM5RztRQUNBcWlCLE1BQU1qRSxRQUFRLENBQUM5QixPQUFPblEsS0FBS3l5QixjQUFjO1FBQ3pDM29CLFFBQVE7UUFDUixTQUFTd0QsT0FBTzVXLE1BQU0sRUFBRTNELE9BQU87WUFDN0IsSUFBSUEsWUFBWSxLQUFLLEdBQUc7Z0JBQ3RCQSxVQUFVO29CQUNSeTZCLHNCQUFzQjtnQkFDeEI7WUFDRjtZQUNBeHRCLEtBQUt3b0IsT0FBTztZQUNaLElBQUl6MUIsUUFBUXk2QixvQkFBb0IsRUFBRTtnQkFDaEMsTUFBTXI2QixTQUFTWCxXQUFXVCxRQUFRO29CQUFDO3dCQUNqQ2tCLFdBQVc7d0JBQ1hDLElBQUl3Qjt3QkFDSjNCLFNBQVM7NEJBQ1B1bUIsTUFBTTs0QkFDTmhFLFNBQVM7NEJBQ1RDLFNBQVM7d0JBQ1g7b0JBQ0Y7aUJBQUU7Z0JBQ0ZtQixXQUFXdmpCO1lBQ2I7WUFDQW1jO1lBQ0E0RyxNQUFNakUsUUFBUSxDQUFDYixPQUFPO2dCQUNwQjFhO1lBQ0Y7UUFDRjtRQUNBLE9BQU87WUFDTG1mLFVBQVUsSUFBTUEsU0FBUztvQkFDdkJtVSxVQUFVO29CQUNWbGdCO29CQUNBK25CO29CQUNBQyxZQUFZO2dCQUNkO1lBQ0FyRSx5QkFBeUI0RTtZQUN6QnhmLE1BQU05ZixDQUFBQSxVQUFXdWEsT0FBTyxRQUFRdmE7WUFDaENnakIsUUFBUWhqQixDQUFBQSxVQUFXdWEsT0FBTyxVQUFVdmE7WUFDcEMsR0FBR2lOLEtBQUtxdEIsT0FBTztRQUNqQjtJQUNGO0lBQ0EsU0FBU0UsVUFBVXRuQixlQUFlO1FBQ2hDLE1BQU15c0IsU0FBUzNoQyxvREFBT0EsQ0FBQ3VVLENBQUFBO1lBQ3JCa3RCLHdCQUF3QixJQUFNOWhCLEtBQUs7b0JBQ2pDcEw7Z0JBQ0Y7UUFDRjtRQUNBLE1BQU1xb0IsTUFBTTdiLEtBQUs7WUFDZjJnQixnQkFBZ0I7Z0JBQ2R6OEIsSUFBSUc7Z0JBQ0o4UDtnQkFDQTRHLGNBQWM7WUFDaEI7WUFDQTJiLFNBQVMsSUFBTWtLLE9BQU8zYyxNQUFNO1lBQzVCc1gsU0FBUztnQkFDUDNjLE1BQU1naUI7WUFDUjtRQUNGO1FBQ0EsT0FBTztZQUNMLEdBQUcvRSxHQUFHO1lBQ05qZCxNQUFNZ2lCO1FBQ1I7SUFDRjtJQUNBLFNBQVNyRDtRQUNQLE1BQU1oQyxVQUFVO1lBQ2R4YyxRQUFRLElBQU0yaEIsd0JBQXdCM2hCO1lBQ3RDRSxXQUFXLElBQU15aEIsd0JBQXdCemhCO1lBQ3pDRCxVQUFVLElBQU0waEIsd0JBQXdCMWhCO1lBQ3hDRSxVQUFVLElBQU13aEIsd0JBQXdCeGhCO1FBQzFDO1FBQ0EsT0FBT2MsS0FBSztZQUNWMmdCLGdCQUFnQjtnQkFDZHo4QixJQUFJRztnQkFDSjhQLGlCQUFpQm1yQiwyQkFBMkIzK0I7Z0JBQzVDb2EsY0FBYztZQUNoQjtZQUNBMmIsU0FBU3AyQjtZQUNUaTdCO1FBQ0Y7SUFDRjtJQUNBLFNBQVNzRjtRQUNQLE1BQU1DLGdCQUFnQi9jLFNBQVM7WUFDN0JtVSxVQUFVO1lBQ1ZsZ0I7WUFDQStuQjtZQUNBQyxZQUFZO1FBQ2Q7UUFDQSxJQUFJYyxlQUFlO1lBQ2pCWixRQUFReEcsT0FBTztRQUNqQjtJQUNGO0lBQ0EsTUFBTTJELFVBQVU7UUFDZHRaLFVBQVUsSUFBTUEsU0FBUztnQkFDdkJtVSxVQUFVO2dCQUNWbGdCO2dCQUNBK25CO2dCQUNBQyxZQUFZO1lBQ2Q7UUFDQXJFLHlCQUF5QjRFO1FBQ3pCOUU7UUFDQThCO1FBQ0F4VyxPQUFPOFo7SUFDVDtJQUNBLE9BQU94RDtBQUNUO0FBQ0EsTUFBTTBELGlCQUFpQjtJQUFDbkY7SUFBZ0J1QjtJQUFtQmlCO0NBQWU7QUFDMUUsU0FBUzRDLGlCQUFpQkMsS0FBSztJQUM3QixJQUFJLEVBQ0Z0USxTQUFTLEVBQ1R2TSxLQUFLLEVBQ0w2RSxRQUFRLEVBQ1JpWSxhQUFhLEVBQ2JDLG9CQUFvQixFQUNyQixHQUFHRjtJQUNKLE1BQU1HLGFBQWE7V0FBS0QsdUJBQXVCSixpQkFBaUIsRUFBRTtXQUFPRyxpQkFBaUIsRUFBRTtLQUFFO0lBQzlGLE1BQU1oQixVQUFVdGlDLCtDQUFRQSxDQUFDLElBQU13N0IsU0FBUyxDQUFDLEVBQUU7SUFDM0MsTUFBTWlJLGlCQUFpQjdpQyx5REFBV0EsQ0FBQyxTQUFTNmlDLGVBQWVwNEIsUUFBUSxFQUFFSixPQUFPO1FBQzFFLElBQUlwRyxXQUFXd0csYUFBYSxDQUFDeEcsV0FBV29HLFVBQVU7WUFDaERxM0IsUUFBUXZHLFVBQVU7UUFDcEI7SUFDRixHQUFHO1FBQUN1RztLQUFRO0lBQ1oxaUMsZ0JBQWdCLFNBQVM4akM7UUFDdkIsSUFBSXI0QixXQUFXbWIsTUFBTWxFLFFBQVE7UUFDN0IsTUFBTTJLLGNBQWN6RyxNQUFNMkcsU0FBUyxDQUFDO1lBQ2xDLE1BQU1saUIsVUFBVXViLE1BQU1sRSxRQUFRO1lBQzlCbWhCLGVBQWVwNEIsVUFBVUo7WUFDekJJLFdBQVdKO1FBQ2I7UUFDQSxPQUFPZ2lCO0lBQ1QsR0FBRztRQUFDcVY7UUFBUzliO1FBQU9pZDtLQUFlO0lBQ25DN2pDLGdCQUFnQjtRQUNkLE9BQU8waUMsUUFBUXZHLFVBQVU7SUFDM0IsR0FBRztRQUFDdUcsUUFBUXZHLFVBQVU7S0FBQztJQUN2QixNQUFNa0QsYUFBYXIrQix5REFBV0EsQ0FBQzZGLENBQUFBO1FBQzdCLE9BQU80N0IsU0FBUztZQUNkQztZQUNBalg7WUFDQTdFO1lBQ0EvZjtRQUNGO0lBQ0YsR0FBRztRQUFDNjdCO1FBQVNqWDtRQUFVN0U7S0FBTTtJQUM3QixNQUFNb1ksYUFBYWgrQix5REFBV0EsQ0FBQyxDQUFDNkYsYUFBYWs5QixXQUFXdGdDLFVBQVlrL0IsU0FBUztZQUMzRUQ7WUFDQWpYO1lBQ0EwSDtZQUNBdk07WUFDQS9mO1lBQ0ErN0IsaUJBQWlCbUIsYUFBYTtZQUM5QjlFLGFBQWF4N0IsV0FBV0EsUUFBUXc3QixXQUFXLEdBQUd4N0IsUUFBUXc3QixXQUFXLEdBQUc7UUFDdEUsSUFBSTtRQUFDOUw7UUFBV3VQO1FBQVNqWDtRQUFVN0U7S0FBTTtJQUN6QyxNQUFNbVkseUJBQXlCLzlCLHlEQUFXQSxDQUFDK0QsQ0FBQUEsUUFBU3M5QixrQ0FBa0NsUCxXQUFXcHVCLFFBQVE7UUFBQ291QjtLQUFVO0lBQ3BILE1BQU1pTSwwQkFBMEJwK0IseURBQVdBLENBQUMwRixDQUFBQTtRQUMxQyxNQUFNZ2hCLFFBQVErRCxTQUFTdGYsU0FBUyxDQUFDNHJCLFFBQVEsQ0FBQ3J4QjtRQUMxQyxPQUFPZ2hCLFFBQVFBLE1BQU1qa0IsT0FBTyxHQUFHO0lBQ2pDLEdBQUc7UUFBQ2dvQixTQUFTdGYsU0FBUztLQUFDO0lBQ3ZCLE1BQU02M0IsaUJBQWlCaGpDLHlEQUFXQSxDQUFDLFNBQVNnakM7UUFDMUMsSUFBSSxDQUFDdEIsUUFBUTVHLFNBQVMsSUFBSTtZQUN4QjtRQUNGO1FBQ0E0RyxRQUFRdkcsVUFBVTtRQUNsQixJQUFJdlYsTUFBTWxFLFFBQVEsR0FBR2xJLEtBQUssS0FBSyxRQUFRO1lBQ3JDb00sTUFBTWpFLFFBQVEsQ0FBQ2hCO1FBQ2pCO0lBQ0YsR0FBRztRQUFDK2dCO1FBQVM5YjtLQUFNO0lBQ25CLE1BQU1xZCxnQkFBZ0JqakMseURBQVdBLENBQUMsSUFBTTBoQyxRQUFRNUcsU0FBUyxJQUFJO1FBQUM0RztLQUFRO0lBQ3RFLE1BQU1yRSxNQUFNdDlCLHFEQUFPQSxDQUFDLElBQU87WUFDekJzK0I7WUFDQUw7WUFDQUQ7WUFDQUs7WUFDQTRFO1lBQ0FDO1FBQ0YsSUFBSTtRQUFDNUU7UUFBWUw7UUFBWUQ7UUFBd0JLO1FBQXlCNEU7UUFBZ0JDO0tBQWM7SUFDNUc5Qyx1QkFBdUJ5QztJQUN2QixJQUFLLElBQUl4dUIsSUFBSSxHQUFHQSxJQUFJd3VCLFdBQVdwMkIsTUFBTSxFQUFFNEgsSUFBSztRQUMxQ3d1QixVQUFVLENBQUN4dUIsRUFBRSxDQUFDaXBCO0lBQ2hCO0FBQ0Y7QUFFQSxNQUFNNkYsbUJBQW1CditCLENBQUFBLFFBQVU7UUFDakNtakIsaUJBQWlCcWIsQ0FBQUE7WUFDZixNQUFNQyx5QkFBeUI7Z0JBQzdCLElBQUl6K0IsTUFBTW1qQixlQUFlLEVBQUU7b0JBQ3pCbmpCLE1BQU1takIsZUFBZSxDQUFDcWI7Z0JBQ3hCO1lBQ0Y7WUFDQSxJQUFJcGtDLG9EQUFhLENBQUN1NEIsVUFBVSxDQUFDLFNBQVN2NEIsb0RBQWEsQ0FBQ3U0QixVQUFVLENBQUMsT0FBTztnQkFDcEU4TDtZQUNGLE9BQU87Z0JBQ0w3akMsb0RBQVNBLENBQUM2akM7WUFDWjtRQUNGO1FBQ0FwYixtQkFBbUJyakIsTUFBTXFqQixpQkFBaUI7UUFDMUNoakIsYUFBYUwsTUFBTUssV0FBVztRQUM5QmtCLFdBQVd2QixNQUFNdUIsU0FBUztRQUMxQkosY0FBY25CLE1BQU1tQixZQUFZO0lBQ2xDO0FBQ0EsTUFBTXU5Qiw0QkFBNEIxK0IsQ0FBQUEsUUFBVTtRQUMxQyxHQUFHb29CLDBCQUEwQjtRQUM3QixHQUFHcG9CLE1BQU1ncEIsbUJBQW1CO1FBQzVCUCxtQkFBbUI7WUFDakIsR0FBR0wsMkJBQTJCSyxpQkFBaUI7WUFDL0MsR0FBR3pvQixNQUFNZ3BCLG1CQUFtQjtRQUM5QjtJQUNGO0FBQ0EsU0FBUzJWLFNBQVNDLE9BQU87SUFDdkIsQ0FBQ0EsUUFBUWw1QixPQUFPLEdBQUd6SixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHdDQUF3Q0EsQ0FBZ0IsR0FBRyxLQUFLO0lBQzVJLE9BQU9nZ0MsUUFBUWw1QixPQUFPO0FBQ3hCO0FBQ0EsU0FBU201QixJQUFJNytCLEtBQUs7SUFDaEIsTUFBTSxFQUNKd3RCLFNBQVMsRUFDVDl0QixZQUFZLEVBQ1pvL0IsT0FBTyxFQUNQelAsS0FBSyxFQUNMbnZCLDJCQUEyQixFQUM1QixHQUFHRjtJQUNKLE1BQU0rK0IsZUFBZXZrQyw2Q0FBTUEsQ0FBQztJQUM1QnU3QjtJQUNBLE1BQU1pSixlQUFlaEosWUFBWWgyQjtJQUNqQyxNQUFNZ2pCLGdCQUFnQjNuQix5REFBV0EsQ0FBQztRQUNoQyxPQUFPa2pDLGlCQUFpQlMsYUFBYXQ1QixPQUFPO0lBQzlDLEdBQUc7UUFBQ3M1QjtLQUFhO0lBQ2pCLE1BQU1qVyx5QkFBeUIxdEIseURBQVdBLENBQUM7UUFDekMsT0FBT3FqQywwQkFBMEJNLGFBQWF0NUIsT0FBTztJQUN2RCxHQUFHO1FBQUNzNUI7S0FBYTtJQUNqQixNQUFNM2QsV0FBV2dTLGFBQWE3RjtJQUM5QixNQUFNeVIsZ0NBQWdDaEwscUJBQXFCO1FBQ3pEekc7UUFDQTBHLE1BQU1oMEI7SUFDUjtJQUNBLE1BQU15bEIsZUFBZTRKLGdCQUFnQi9CLFdBQVc2QjtJQUNoRCxNQUFNNlAsZUFBZTdqQyx5REFBV0EsQ0FBQ21mLENBQUFBO1FBQy9CbWtCLFNBQVNJLGNBQWMvaEIsUUFBUSxDQUFDeEM7SUFDbEMsR0FBRyxFQUFFO0lBQ0wsTUFBTTJrQixtQkFBbUIvakMscURBQU9BLENBQUMsSUFBTUgseURBQWtCQSxDQUFDO1lBQ3hEbWdCO1lBQ0FFO1lBQ0FDO1lBQ0FDO1lBQ0FIO1FBQ0YsR0FBRzZqQixlQUFlO1FBQUNBO0tBQWE7SUFDaEMsTUFBTXBaLFdBQVcwTTtJQUNqQixNQUFNL00sbUJBQW1CcnFCLHFEQUFPQSxDQUFDO1FBQy9CLE9BQU9pc0IsdUJBQXVCdkIsVUFBVXFaO0lBQzFDLEdBQUc7UUFBQ3JaO1FBQVVxWjtLQUFpQjtJQUMvQixNQUFNamEsZUFBZTlwQixxREFBT0EsQ0FBQyxJQUFNNnhCLG1CQUFtQjtZQUNwRG5GO1lBQ0EzaUIsaUJBQWlCc2dCLGlCQUFpQnRnQixlQUFlO1lBQ2pENGpCO1lBQ0EsR0FBRzl0Qix5REFBa0JBLENBQUM7Z0JBQ3BCd2dCO1lBQ0YsR0FBR3lqQixhQUFhO1FBQ2xCLElBQUk7UUFBQ3paLGlCQUFpQnRnQixlQUFlO1FBQUUrNUI7UUFBY25XO0tBQXVCO0lBQzVFLE1BQU1yRCxlQUFlb0wsZ0JBQWdCdEQ7SUFDckMsTUFBTXZNLFFBQVE3bEIscURBQU9BLENBQUMsSUFBTVAsWUFBWTtZQUN0Q3dtQjtZQUNBNkQ7WUFDQU87WUFDQUM7WUFDQTFDO1lBQ0EyQztRQUNGLElBQUk7UUFBQ3RFO1FBQVU2RDtRQUFjTztRQUFrQkM7UUFBYzFDO1FBQWUyQztLQUFhO0lBQ3pGLElBQUkxcEIsSUFBeUIsRUFBYztRQUN6QyxJQUFJOGlDLGFBQWFyNUIsT0FBTyxJQUFJcTVCLGFBQWFyNUIsT0FBTyxLQUFLdWIsT0FBTztZQWxnTWhFLEtBbWdNMkMsR0FBR2prQixRQUFRLDZCQUE2QixDQUFNO1FBQ3JGO0lBQ0Y7SUFDQStoQyxhQUFhcjVCLE9BQU8sR0FBR3ViO0lBQ3ZCLE1BQU1tZSxnQkFBZ0IvakMseURBQVdBLENBQUM7UUFDaEMsTUFBTXFLLFVBQVVpNUIsU0FBU0k7UUFDekIsTUFBTTVxQixRQUFRek8sUUFBUXFYLFFBQVE7UUFDOUIsSUFBSTVJLE1BQU1VLEtBQUssS0FBSyxRQUFRO1lBQzFCblAsUUFBUXNYLFFBQVEsQ0FBQ2hCO1FBQ25CO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsTUFBTTFjLGFBQWFqRSx5REFBV0EsQ0FBQztRQUM3QixNQUFNOFksUUFBUXdxQixTQUFTSSxjQUFjaGlCLFFBQVE7UUFDN0MsSUFBSTVJLE1BQU1VLEtBQUssS0FBSyxrQkFBa0I7WUFDcEMsT0FBTztRQUNUO1FBQ0EsSUFBSVYsTUFBTVUsS0FBSyxLQUFLLFFBQVE7WUFDMUIsT0FBTztRQUNUO1FBQ0EsT0FBT1YsTUFBTTdVLFVBQVU7SUFDekIsR0FBRyxFQUFFO0lBQ0wsTUFBTSsvQixlQUFlamtDLHFEQUFPQSxDQUFDLElBQU87WUFDbENrRTtZQUNBQyxVQUFVNi9CO1FBQ1osSUFBSTtRQUFDOS9CO1FBQVk4L0I7S0FBYztJQUMvQjEvQixhQUFhMi9CO0lBQ2IsTUFBTUMsYUFBYWprQyx5REFBV0EsQ0FBQzBGLENBQUFBLEtBQU04bUIsYUFBYThXLFNBQVNJLGNBQWNoaUIsUUFBUSxJQUFJaGMsS0FBSyxFQUFFO0lBQzVGLE1BQU13K0IsdUJBQXVCbGtDLHlEQUFXQSxDQUFDLElBQU11WixrQkFBa0IrcEIsU0FBU0ksY0FBY2hpQixRQUFRLEtBQUssRUFBRTtJQUN2RyxNQUFNeWlCLGFBQWFwa0MscURBQU9BLENBQUMsSUFBTztZQUNoQzBoQixTQUFTMkk7WUFDVGQsT0FBT2U7WUFDUDhIO1lBQ0FpUyxTQUFTSDtZQUNUMXFCLG1CQUFtQjJxQjtZQUNuQk47WUFDQW5aO1FBQ0YsSUFBSTtRQUFDMEg7UUFBVy9IO1FBQWtCd1o7UUFBK0J2WjtRQUFjNFo7UUFBWUM7UUFBc0J6WjtLQUFTO0lBQzFIK1gsaUJBQWlCO1FBQ2ZyUTtRQUNBdk07UUFDQTZFO1FBQ0FpWSxlQUFlZSxXQUFXO1FBQzFCZCxzQkFBc0JoK0IsTUFBTWcrQixvQkFBb0IsS0FBSztJQUN2RDtJQUNBempDLGdEQUFTQSxDQUFDO1FBQ1IsT0FBTzZrQztJQUNULEdBQUc7UUFBQ0E7S0FBYztJQUNsQixxQkFBT2hsQywwREFBbUIsQ0FBQ2k2QixXQUFXbjVCLFFBQVEsRUFBRTtRQUM5Q21CLE9BQU9takM7SUFDVCxpQkFBR3BsQywwREFBbUIsQ0FBQ2MsaURBQVFBLEVBQUU7UUFDL0J5eUIsU0FBU2lGO1FBQ1QzUixPQUFPQTtJQUNULEdBQUdqaEIsTUFBTUMsUUFBUTtBQUNuQjtBQUVBLElBQUl5L0IsUUFBUTtBQUNaLFNBQVNDO0lBQ1BELFFBQVE7QUFDVjtBQUNBLFNBQVNFO0lBQ1AsT0FBT3hrQyxxREFBT0EsQ0FBQyxJQUFNLENBQUMsRUFBRXNrQyxRQUFRLENBQUMsRUFBRSxFQUFFO0FBQ3ZDO0FBQ0EsU0FBU0c7SUFDUCxPQUFPemxDLGtEQUFXO0FBQ3BCO0FBQ0EsSUFBSTBsQyx1QkFBdUIseURBQWdCMWxDLEdBQUd5bEMscUJBQXFCRDtBQUVuRSxTQUFTRztJQUNQLElBQUkseURBQWdCM2xDLEVBQUU7UUF2a014QixLQXdrTXlDLEdBQUc0QyxRQUFRLENBQUMsbUVBQW1FLENBQUMsSUFBSSxDQUFNO1FBQy9IO0lBQ0Y7SUFDQTJpQztJQUNBaE07QUFDRjtBQUNBLFNBQVNxTSxnQkFBZ0JoZ0MsS0FBSztJQUM1QixNQUFNd3RCLFlBQVlzUztJQUNsQixNQUFNNS9CLDhCQUE4QkYsTUFBTUUsMkJBQTJCLElBQUl5QixTQUFTekIsMkJBQTJCO0lBQzdHLHFCQUFPOUYsMERBQW1CLENBQUMwRSxlQUFlLE1BQU1ZLENBQUFBLDZCQUFnQnRGLDBEQUFtQixDQUFDeWtDLEtBQUs7WUFDdkZ4UCxPQUFPcnZCLE1BQU1xdkIsS0FBSztZQUNsQjdCLFdBQVdBO1lBQ1g5dEIsY0FBY0E7WUFDZFEsNkJBQTZCQTtZQUM3Qjg5QixzQkFBc0JoK0IsTUFBTWcrQixvQkFBb0I7WUFDaERjLFNBQVM5K0IsTUFBTTgrQixPQUFPO1lBQ3RCM2IsaUJBQWlCbmpCLE1BQU1takIsZUFBZTtZQUN0Q0UsbUJBQW1CcmpCLE1BQU1xakIsaUJBQWlCO1lBQzFDaGpCLGFBQWFMLE1BQU1LLFdBQVc7WUFDOUJjLGNBQWNuQixNQUFNbUIsWUFBWTtZQUNoQ0ksV0FBV3ZCLE1BQU11QixTQUFTO1lBQzFCeW5CLHFCQUFxQmhwQixNQUFNZ3BCLG1CQUFtQjtRQUNoRCxHQUFHaHBCLE1BQU1DLFFBQVE7QUFDbkI7QUFFQSxNQUFNZ2dDLGdCQUFnQjtJQUNwQjFpQixVQUFVO0lBQ1ZrUixlQUFlO0FBQ2pCO0FBQ0EsTUFBTXlSLHdCQUF3QixDQUFDQywyQkFBMkIzaUI7SUFDeEQsSUFBSUEsVUFBVTtRQUNaLE9BQU9ZLFlBQVlSLElBQUksQ0FBQ0osU0FBU2UsUUFBUTtJQUMzQztJQUNBLElBQUk0aEIsMkJBQTJCO1FBQzdCLE9BQU8vaEIsWUFBWUUsSUFBSTtJQUN6QjtJQUNBLE9BQU9GLFlBQVlDLEtBQUs7QUFDMUI7QUFDQSxNQUFNK2hCLHFCQUFxQixDQUFDeGhCLGFBQWF5aEI7SUFDdkMsSUFBSSxDQUFDemhCLGFBQWE7UUFDaEIsT0FBT0Y7SUFDVDtJQUNBLE9BQU8yaEIsa0JBQWtCci9CLFFBQVE2YyxPQUFPLENBQUNELElBQUksR0FBRzVjLFFBQVE2YyxPQUFPLENBQUNDLFNBQVM7QUFDM0U7QUFDQSxNQUFNd2lCLDJCQUEyQi9pQixDQUFBQTtJQUMvQixJQUFJQSxTQUFTcFMsa0JBQWtCLElBQUksTUFBTTtRQUN2QyxPQUFPb1MsU0FBU3BTLGtCQUFrQjtJQUNwQztJQUNBLE9BQU9vUyxTQUFTL0ssSUFBSSxLQUFLO0FBQzNCO0FBQ0EsU0FBUyt0QixpQkFBaUJoakIsUUFBUTtJQUNoQyxNQUFNMUssWUFBWTBLLFNBQVMxSyxTQUFTO0lBQ3BDLE1BQU05RSxNQUFNOEUsVUFBVXhDLE1BQU07SUFDNUIsTUFBTSxFQUNKN1UsTUFBTSxFQUNOdVIsV0FBVyxFQUNYeVEsUUFBUSxFQUNULEdBQUdEO0lBQ0osTUFBTXFCLGNBQWNqUyxRQUFRSTtJQUM1QixNQUFNM0IsZ0JBQWdCazFCLHlCQUF5Qi9pQjtJQUMvQyxNQUFNOGlCLGtCQUFrQjF6QixRQUFRNlE7SUFDaEMsTUFBTWdqQixZQUFZSCxrQkFBa0IxaEIsV0FBV2YsSUFBSSxDQUFDcGlCLFFBQVFvakIsZUFBZUQsV0FBV0YsTUFBTSxDQUFDampCO0lBQzdGLE1BQU04aEIsUUFBUTtRQUNabmQsVUFBVTtRQUNWaUQsS0FBSzJLLElBQUloSixTQUFTLENBQUMzQixHQUFHO1FBQ3RCSSxNQUFNdUssSUFBSWhKLFNBQVMsQ0FBQ3ZCLElBQUk7UUFDeEJpOUIsV0FBVztRQUNYaDlCLE9BQU9zSyxJQUFJSCxTQUFTLENBQUNuSyxLQUFLO1FBQzFCQyxRQUFRcUssSUFBSUgsU0FBUyxDQUFDbEssTUFBTTtRQUM1QmlyQixZQUFZdVIsc0JBQXNCOTBCLGVBQWVvUztRQUNqRGdqQjtRQUNBM2lCLFNBQVN1aUIsbUJBQW1CeGhCLGFBQWF5aEI7UUFDekNLLFFBQVFMLGtCQUFrQkosY0FBY3hSLGFBQWEsR0FBR3dSLGNBQWMxaUIsUUFBUTtRQUM5RW9qQixlQUFlO0lBQ2pCO0lBQ0EsT0FBT3JqQjtBQUNUO0FBQ0EsU0FBU3NqQixrQkFBa0JDLFNBQVM7SUFDbEMsT0FBTztRQUNMTCxXQUFXN2hCLFdBQVdGLE1BQU0sQ0FBQ29pQixVQUFVcmxDLE1BQU07UUFDN0NtekIsWUFBWWtTLFVBQVVDLHlCQUF5QixHQUFHcGlCLFlBQVk7SUFDaEU7QUFDRjtBQUNBLFNBQVNxaUIsV0FBV0MsTUFBTTtJQUN4QixPQUFPQSxPQUFPbmtDLElBQUksS0FBSyxhQUFhMGpDLGlCQUFpQlMsVUFBVUosa0JBQWtCSTtBQUNuRjtBQUVBLFNBQVNDLGVBQWVsN0IsVUFBVSxFQUFFdkksRUFBRSxFQUFFeXBCLFlBQVk7SUFDbEQsSUFBSUEsaUJBQWlCLEtBQUssR0FBRztRQUMzQkEsZUFBZXJsQjtJQUNqQjtJQUNBLE1BQU1zL0IsaUJBQWlCcGtDLE9BQU9xa0MsZ0JBQWdCLENBQUMzakM7SUFDL0MsTUFBTW9RLFlBQVlwUSxHQUFHNCtCLHFCQUFxQjtJQUMxQyxNQUFNL3JCLFNBQVMzVSwyREFBWUEsQ0FBQ2tTLFdBQVdzekI7SUFDdkMsTUFBTXI4QixPQUFPcEoseURBQVVBLENBQUM0VSxRQUFRNFc7SUFDaEMsTUFBTXZPLGNBQWM7UUFDbEJySTtRQUNBMnJCLFNBQVN4K0IsR0FBR3crQixPQUFPLENBQUN4RyxXQUFXO1FBQy9CcEIsU0FBUzhNLGVBQWU5TSxPQUFPO0lBQ2pDO0lBQ0EsTUFBTXZtQixhQUFhO1FBQ2pCaE0sR0FBR3dPLE9BQU90TCxTQUFTLENBQUN0QixLQUFLO1FBQ3pCM0IsR0FBR3VPLE9BQU90TCxTQUFTLENBQUNyQixNQUFNO0lBQzVCO0lBQ0EsTUFBTW1QLFlBQVk7UUFDaEI5TTtRQUNBMlM7UUFDQTdLO1FBQ0F3QztRQUNBeEw7SUFDRjtJQUNBLE9BQU9nTztBQUNUO0FBRUEsU0FBU3V1QixzQkFBc0JyMkIsSUFBSTtJQUNqQyxNQUFNb25CLFdBQVc0QixjQUFjO0lBQy9CLE1BQU0sRUFDSmh1QixVQUFVLEVBQ1YrZixRQUFRLEVBQ1J1YixlQUFlLEVBQ2ZsRSwwQkFBMEIsRUFDMUIzRSx1QkFBdUIsRUFDdkIxbkIsU0FBUyxFQUNWLEdBQUcvRjtJQUNKLE1BQU1qTixVQUFVMUMscURBQU9BLENBQUMsSUFBTztZQUM3QitoQztZQUNBM0U7WUFDQTFuQjtRQUNGLElBQUk7UUFBQ3FzQjtRQUE0QnJzQjtRQUFXMG5CO0tBQXdCO0lBQ3BFLE1BQU10UyxlQUFlN3FCLHlEQUFXQSxDQUFDNHJCLENBQUFBO1FBQy9CLE1BQU16cEIsS0FBSzZqQztRQUNYLENBQUM3akMsS0FBS3ZCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sNkNBQTZDQSxDQUFnQixHQUFHLEtBQUs7UUFDcEksT0FBT3FpQyxlQUFlbDdCLFlBQVl2SSxJQUFJeXBCO0lBQ3hDLEdBQUc7UUFBQ2xoQjtRQUFZczdCO0tBQWdCO0lBQ2hDLE1BQU10ZixRQUFRM21CLHFEQUFPQSxDQUFDLElBQU87WUFDM0IrMkI7WUFDQXBzQjtZQUNBakk7WUFDQW9vQjtRQUNGLElBQUk7UUFBQ25nQjtRQUFZbWdCO1FBQWNwb0I7UUFBU3EwQjtLQUFTO0lBQ2pELE1BQU1tUCxlQUFlOW1DLDZDQUFNQSxDQUFDdW5CO0lBQzVCLE1BQU13ZixvQkFBb0IvbUMsNkNBQU1BLENBQUM7SUFDakNILGdCQUFnQjtRQUNkeXJCLFNBQVN0ZixTQUFTLENBQUMycUIsUUFBUSxDQUFDbVEsYUFBYTU3QixPQUFPO1FBQ2hELE9BQU8sSUFBTW9nQixTQUFTdGYsU0FBUyxDQUFDNHFCLFVBQVUsQ0FBQ2tRLGFBQWE1N0IsT0FBTztJQUNqRSxHQUFHO1FBQUNvZ0IsU0FBU3RmLFNBQVM7S0FBQztJQUN2Qm5NLGdCQUFnQjtRQUNkLElBQUlrbkMsa0JBQWtCNzdCLE9BQU8sRUFBRTtZQUM3QjY3QixrQkFBa0I3N0IsT0FBTyxHQUFHO1lBQzVCO1FBQ0Y7UUFDQSxNQUFNcUMsT0FBT3U1QixhQUFhNTdCLE9BQU87UUFDakM0N0IsYUFBYTU3QixPQUFPLEdBQUdxYztRQUN2QitELFNBQVN0ZixTQUFTLENBQUNwRixNQUFNLENBQUMyZ0IsT0FBT2hhO0lBQ25DLEdBQUc7UUFBQ2dhO1FBQU8rRCxTQUFTdGYsU0FBUztLQUFDO0FBQ2hDO0FBRUEsSUFBSWc3QixpQ0FBbUJwbkMsMERBQW1CLENBQUM7QUFFM0MsU0FBU3FuQyxxQkFBcUJqa0MsRUFBRTtJQUM5QixDQUFFQSxDQUFBQSxNQUFNZ3pCLGNBQWNoekIsR0FBRSxJQUFLdkIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDOzs7OztFQUt2RixDQUFDLElBQUlBLENBQWdCLEdBQUcsS0FBSztBQUMvQjtBQUVBLFNBQVM4aUMsZ0JBQWdCMWhDLEtBQUssRUFBRXd0QixTQUFTLEVBQUVtVSxNQUFNO0lBQy9DL0wsbUJBQW1CO1FBQ2pCLFNBQVN2SSxPQUFPdHNCLEVBQUU7WUFDaEIsT0FBTyxDQUFDLGNBQWMsRUFBRUEsR0FBRyxHQUFHLENBQUM7UUFDakM7UUFDQSxNQUFNQSxLQUFLZixNQUFNa0IsV0FBVztRQUM1QixDQUFDSCxLQUFLOUUsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxzQ0FBc0NBLENBQWdCLEdBQUcsS0FBSztRQUM3SCxDQUFFLFFBQU9tQyxPQUFPLFFBQU8sSUFBSzlFLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQzt1QkFDbkUsRUFBRSxPQUFPbUMsR0FBRyxVQUFVLEVBQUVBLEdBQUcsQ0FBQyxDQUFDLElBQUluQyxDQUFnQixHQUFHLEtBQUs7UUFDNUUsQ0FBQ3lnQixPQUFPdWlCLFNBQVMsQ0FBQzVoQyxNQUFNSSxLQUFLLElBQUluRSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsRUFBRXl1QixPQUFPdHNCLElBQUksK0JBQStCLENBQUMsSUFBSW5DLENBQWdCLEdBQUcsS0FBSztRQUNwSyxJQUFJb0IsTUFBTWdoQyxNQUFNLENBQUNua0MsSUFBSSxLQUFLLFlBQVk7WUFDcEM7UUFDRjtRQUNBNGtDLHFCQUFxQkU7UUFDckIsSUFBSTNoQyxNQUFNOFEsU0FBUyxFQUFFO1lBQ25CLENBQUM0ZixlQUFlbEQsV0FBV3pzQixNQUFNOUUsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLEVBQUV5dUIsT0FBT3RzQixJQUFJLDJCQUEyQixDQUFDLElBQUluQyxDQUFnQixHQUFHLEtBQUs7UUFDbEs7SUFDRjtBQUNGO0FBQ0EsU0FBU2lqQyx1QkFBdUJDLE9BQU87SUFDckNwTSxPQUFPO1FBQ0wsTUFBTXFNLGFBQWF2bkMsNkNBQU1BLENBQUNzbkM7UUFDMUJsTSxtQkFBbUI7WUFDakIsQ0FBRWtNLENBQUFBLFlBQVlDLFdBQVdyOEIsT0FBTyxJQUFJekosS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxnRUFBZ0VBLENBQWdCLEdBQUcsS0FBSztRQUN2TCxHQUFHO1lBQUNrakM7U0FBUTtJQUNkO0FBQ0Y7QUFFQSxTQUFTRSxtQkFBbUJDLE9BQU87SUFDakMsTUFBTXpnQyxTQUFTOUcsaURBQVVBLENBQUN1bkM7SUFDMUIsQ0FBQ3pnQyxTQUFTdkYsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxxQ0FBcUNBLENBQWdCLEdBQUcsS0FBSztJQUNoSSxPQUFPNEM7QUFDVDtBQUVBLFNBQVMwZ0MsZ0JBQWdCOWlDLEtBQUs7SUFDNUJBLE1BQU1LLGNBQWM7QUFDdEI7QUFDQSxNQUFNMGlDLFlBQVluaUMsQ0FBQUE7SUFDaEIsTUFBTSt2QixNQUFNdjFCLDZDQUFNQSxDQUFDO0lBQ25CLE1BQU00bkMsU0FBUy9tQyx5REFBV0EsQ0FBQyxTQUFVbUMsRUFBRTtRQUNyQyxJQUFJQSxPQUFPLEtBQUssR0FBRztZQUNqQkEsS0FBSztRQUNQO1FBQ0F1eUIsSUFBSXJxQixPQUFPLEdBQUdsSTtJQUNoQixHQUFHLEVBQUU7SUFDTCxNQUFNbWtDLFNBQVN0bUMseURBQVdBLENBQUMsSUFBTTAwQixJQUFJcnFCLE9BQU8sRUFBRSxFQUFFO0lBQ2hELE1BQU0sRUFDSjhuQixTQUFTLEVBQ1R5Uiw2QkFBNkIsRUFDN0JuWixRQUFRLEVBQ1QsR0FBR2tjLG1CQUFtQjNOO0lBQ3ZCLE1BQU0sRUFDSngzQixJQUFJLEVBQ0o4RCxXQUFXLEVBQ1osR0FBR3FoQyxtQkFBbUJSO0lBQ3ZCLE1BQU16N0IsYUFBYTNLLHFEQUFPQSxDQUFDLElBQU87WUFDaEMyRixJQUFJZixNQUFNa0IsV0FBVztZQUNyQmQsT0FBT0osTUFBTUksS0FBSztZQUNsQnZEO1lBQ0E4RDtRQUNGLElBQUk7UUFBQ1gsTUFBTWtCLFdBQVc7UUFBRWxCLE1BQU1JLEtBQUs7UUFBRXZEO1FBQU04RDtLQUFZO0lBQ3ZELE1BQU0sRUFDSlYsUUFBUSxFQUNSaUIsV0FBVyxFQUNYNFAsU0FBUyxFQUNUMG5CLHVCQUF1QixFQUN2QjJFLDBCQUEwQixFQUMxQjJFLE9BQU8sRUFDUGQsTUFBTSxFQUNONWtCLHVCQUF1QmltQiwyQkFBMkIsRUFDbkQsR0FBR3JpQztJQUNKMGhDLGdCQUFnQjFoQyxPQUFPd3RCLFdBQVdtVTtJQUNsQ0UsdUJBQXVCQztJQUN2QixJQUFJLENBQUNBLFNBQVM7UUFDWixNQUFNUSxlQUFlbG5DLHFEQUFPQSxDQUFDLElBQU87Z0JBQ2xDMks7Z0JBQ0ErZjtnQkFDQXViLGlCQUFpQk07Z0JBQ2pCeEU7Z0JBQ0EzRTtnQkFDQTFuQjtZQUNGLElBQUk7WUFBQy9LO1lBQVkrZjtZQUFVNmI7WUFBUXhFO1lBQTRCM0U7WUFBeUIxbkI7U0FBVTtRQUNsR3N3QixzQkFBc0JrQjtJQUN4QjtJQUNBLE1BQU1DLGtCQUFrQm5uQyxxREFBT0EsQ0FBQyxJQUFNMFYsWUFBWTtZQUNoRDB4QixVQUFVO1lBQ1ZDLE1BQU07WUFDTixvQkFBb0J4RDtZQUNwQixxQ0FBcUMvOUI7WUFDckMsbUNBQW1Dc3NCO1lBQ25DaG5CLFdBQVc7WUFDWG5HLGFBQWE2aEM7UUFDZixJQUFJLE1BQU07UUFBQzFVO1FBQVd5UjtRQUErQi85QjtRQUFhNFA7S0FBVTtJQUM1RSxNQUFNNHhCLFlBQVlybkMseURBQVdBLENBQUMrRCxDQUFBQTtRQUM1QixJQUFJNGhDLE9BQU9ua0MsSUFBSSxLQUFLLFlBQVk7WUFDOUI7UUFDRjtRQUNBLElBQUksQ0FBQ21rQyxPQUFPeGpCLFFBQVEsRUFBRTtZQUNwQjtRQUNGO1FBQ0EsSUFBSXBlLE1BQU11akMsWUFBWSxLQUFLLGFBQWE7WUFDdEM7UUFDRjtRQUNBLElBQUl2b0Msb0RBQWEsQ0FBQ3U0QixVQUFVLENBQUMsU0FBU3Y0QixvREFBYSxDQUFDdTRCLFVBQVUsQ0FBQyxPQUFPO1lBQ3BFMFA7UUFDRixPQUFPO1lBQ0x6bkMsb0RBQVNBLENBQUN5bkM7UUFDWjtJQUNGLEdBQUc7UUFBQ0E7UUFBNkJyQjtLQUFPO0lBQ3hDLE1BQU1sZSxXQUFXMW5CLHFEQUFPQSxDQUFDO1FBQ3ZCLE1BQU1raUIsUUFBUXlqQixXQUFXQztRQUN6QixNQUFNNEIsa0JBQWtCNUIsT0FBT25rQyxJQUFJLEtBQUssY0FBY21rQyxPQUFPeGpCLFFBQVEsR0FBR2tsQixZQUFZaGtCO1FBQ3BGLE1BQU1sZCxTQUFTO1lBQ2JxaEMsVUFBVVQ7WUFDVlUsZ0JBQWdCO2dCQUNkLGlDQUFpQ3RWO2dCQUNqQyx5QkFBeUJ0c0I7Z0JBQ3pCb2M7Z0JBQ0FzbEI7WUFDRjtZQUNBTDtRQUNGO1FBQ0EsT0FBTy9nQztJQUNULEdBQUc7UUFBQ2dzQjtRQUFXK1U7UUFBaUJyaEM7UUFBYTgvQjtRQUFRMEI7UUFBV047S0FBTztJQUN2RSxNQUFNVyxTQUFTM25DLHFEQUFPQSxDQUFDLElBQU87WUFDNUI4RixhQUFhNkUsV0FBV2hGLEVBQUU7WUFDMUJsRSxNQUFNa0osV0FBV2xKLElBQUk7WUFDckIwRCxRQUFRO2dCQUNOSCxPQUFPMkYsV0FBVzNGLEtBQUs7Z0JBQ3ZCTyxhQUFhb0YsV0FBV3BGLFdBQVc7WUFDckM7UUFDRixJQUFJO1FBQUNvRixXQUFXcEYsV0FBVztRQUFFb0YsV0FBV2hGLEVBQUU7UUFBRWdGLFdBQVczRixLQUFLO1FBQUUyRixXQUFXbEosSUFBSTtLQUFDO0lBQzlFLHFCQUFPekMsMERBQW1CLENBQUNBLHVEQUFjLEVBQUUsTUFBTTZGLFNBQVM2aUIsVUFBVWtlLE9BQU9pQyxRQUFRLEVBQUVGO0FBQ3ZGO0FBQ0EsSUFBSUcsY0FBY2Y7QUFFbEIsSUFBSWdCLGdCQUFpQixDQUFDejhCLEdBQUdDLElBQU1ELE1BQU1DO0FBRXJDLElBQUl5OEIsOEJBQStCNWhDLENBQUFBO0lBQ2pDLE1BQU0sRUFDSlIsT0FBTyxFQUNQUCxXQUFXLEVBQ1osR0FBR2U7SUFDSixJQUFJZixhQUFhO1FBQ2YsT0FBT0EsWUFBWUUsV0FBVztJQUNoQztJQUNBLElBQUlLLFNBQVM7UUFDWCxPQUFPQSxRQUFRTCxXQUFXO0lBQzVCO0lBQ0EsT0FBTztBQUNUO0FBRUEsTUFBTTBpQywyQkFBMkI3aEMsQ0FBQUE7SUFDL0IsT0FBT0EsT0FBT1IsT0FBTyxHQUFHUSxPQUFPUixPQUFPLENBQUNFLFdBQVcsR0FBRztBQUN2RDtBQUNBLE1BQU1vaUMsMkJBQTJCejhCLENBQUFBO0lBQy9CLE9BQU9BLE9BQU9DLEVBQUUsSUFBSUQsT0FBT0MsRUFBRSxDQUFDakssSUFBSSxLQUFLLFlBQVlnSyxPQUFPQyxFQUFFLENBQUM5RixPQUFPLENBQUNFLFdBQVcsR0FBRztBQUNyRjtBQUNBLFNBQVNxaUM7SUFDUCxNQUFNQyxpQkFBaUIzbkMsdURBQVVBLENBQUMsQ0FBQ2dHLEdBQUdDLElBQU87WUFDM0NEO1lBQ0FDO1FBQ0Y7SUFDQSxNQUFNMmhDLHNCQUFzQjVuQyx1REFBVUEsQ0FBQyxTQUFVMlcsSUFBSSxFQUFFc3ZCLE9BQU8sRUFBRTRCLFlBQVksRUFBRTMyQixXQUFXLEVBQUV5USxRQUFRO1FBQ2pHLElBQUlrbUIsaUJBQWlCLEtBQUssR0FBRztZQUMzQkEsZUFBZTtRQUNqQjtRQUNBLElBQUkzMkIsZ0JBQWdCLEtBQUssR0FBRztZQUMxQkEsY0FBYztRQUNoQjtRQUNBLElBQUl5USxhQUFhLEtBQUssR0FBRztZQUN2QkEsV0FBVztRQUNiO1FBQ0EsT0FBTztZQUNMbGUsWUFBWTtZQUNad2lDO1lBQ0F6QixpQkFBaUIxekIsUUFBUTZRO1lBQ3pCbW1CLGVBQWVubUI7WUFDZmhMO1lBQ0FreEI7WUFDQTMyQjtZQUNBNjJCLGtCQUFrQjtRQUNwQjtJQUNGO0lBQ0EsTUFBTUMsbUJBQW1CaG9DLHVEQUFVQSxDQUFDLFNBQVVMLE1BQU0sRUFBRWdYLElBQUksRUFBRUssU0FBUyxFQUFFaXZCLE9BQU8sRUFBRTRCLFlBQVksRUFBRTMyQixXQUFXLEVBQUU1QixrQkFBa0I7UUFDM0gsSUFBSXU0QixpQkFBaUIsS0FBSyxHQUFHO1lBQzNCQSxlQUFlO1FBQ2pCO1FBQ0EsSUFBSTMyQixnQkFBZ0IsS0FBSyxHQUFHO1lBQzFCQSxjQUFjO1FBQ2hCO1FBQ0EsSUFBSTVCLHVCQUF1QixLQUFLLEdBQUc7WUFDakNBLHFCQUFxQjtRQUN2QjtRQUNBLE9BQU87WUFDTDYxQixRQUFRO2dCQUNObmtDLE1BQU07Z0JBQ04yZ0IsVUFBVTtnQkFDVmttQjtnQkFDQTMyQjtnQkFDQXlGO2dCQUNBaFg7Z0JBQ0FxWDtnQkFDQTFIO2dCQUNBODNCLFVBQVVRLG9CQUFvQmp4QixNQUFNc3ZCLFNBQVM0QixjQUFjMzJCLGFBQWE7WUFDMUU7UUFDRjtJQUNGO0lBQ0EsTUFBTW1oQixXQUFXLENBQUMvWixPQUFPMnZCO1FBQ3ZCLElBQUl4a0MsV0FBVzZVLFFBQVE7WUFDckIsSUFBSUEsTUFBTUssUUFBUSxDQUFDaE8sU0FBUyxDQUFDekYsRUFBRSxLQUFLK2lDLFNBQVM1aUMsV0FBVyxFQUFFO2dCQUN4RCxPQUFPO1lBQ1Q7WUFDQSxNQUFNMUYsU0FBUzJZLE1BQU16TyxPQUFPLENBQUMySyxNQUFNLENBQUM3VSxNQUFNO1lBQzFDLE1BQU1xWCxZQUFZc0IsTUFBTUUsVUFBVSxDQUFDcE8sVUFBVSxDQUFDNjlCLFNBQVM1aUMsV0FBVyxDQUFDO1lBQ25FLE1BQU13aUMsZUFBZTF2QixrQkFBa0JHLE1BQU10TixNQUFNO1lBQ25ELE1BQU1rRyxjQUFjdTJCLHlCQUF5Qm52QixNQUFNdE4sTUFBTTtZQUN6RCxNQUFNc0UscUJBQXFCZ0osTUFBTWhKLGtCQUFrQjtZQUNuRCxPQUFPMDRCLGlCQUFpQkwsZUFBZWhvQyxPQUFPcUcsQ0FBQyxFQUFFckcsT0FBT3NHLENBQUMsR0FBR3FTLE1BQU15RCxZQUFZLEVBQUUvRSxXQUFXaXhCLFNBQVNoQyxPQUFPLEVBQUU0QixjQUFjMzJCLGFBQWE1QjtRQUMxSTtRQUNBLElBQUlnSixNQUFNVSxLQUFLLEtBQUssa0JBQWtCO1lBQ3BDLE1BQU13RixZQUFZbEcsTUFBTWtHLFNBQVM7WUFDakMsSUFBSUEsVUFBVTdZLE1BQU0sQ0FBQ04sV0FBVyxLQUFLNGlDLFNBQVM1aUMsV0FBVyxFQUFFO2dCQUN6RCxPQUFPO1lBQ1Q7WUFDQSxNQUFNNGdDLFVBQVVnQyxTQUFTaEMsT0FBTztZQUNoQyxNQUFNanZCLFlBQVlzQixNQUFNRSxVQUFVLENBQUNwTyxVQUFVLENBQUM2OUIsU0FBUzVpQyxXQUFXLENBQUM7WUFDbkUsTUFBTU0sU0FBUzZZLFVBQVU3WSxNQUFNO1lBQy9CLE1BQU1nUixPQUFPaFIsT0FBT2dSLElBQUk7WUFDeEIsTUFBTWt4QixlQUFlTiw0QkFBNEI1aEM7WUFDakQsTUFBTXVMLGNBQWNzMkIseUJBQXlCN2hDO1lBQzdDLE1BQU0rYyxXQUFXcEssTUFBTTRHLFlBQVk7WUFDbkMsTUFBTXlDLFdBQVc7Z0JBQ2ZlO2dCQUNBd2xCLE9BQU9ybUIsT0FBT0UsSUFBSTtnQkFDbEJhLFFBQVF0SyxNQUFNNkcsbUJBQW1CO2dCQUNqQzZDLFNBQVM5USxjQUFjL0wsUUFBUTZjLE9BQU8sQ0FBQ0QsSUFBSSxHQUFHO2dCQUM5Q0csT0FBT2hSLGNBQWMvTCxRQUFRK2MsS0FBSyxDQUFDSCxJQUFJLEdBQUc7WUFDNUM7WUFDQSxPQUFPO2dCQUNMb2pCLFFBQVE7b0JBQ05ua0MsTUFBTTtvQkFDTnJCLFFBQVEyWSxNQUFNNkcsbUJBQW1CO29CQUNqQ25JO29CQUNBMks7b0JBQ0FrbUI7b0JBQ0EzMkI7b0JBQ0F5RjtvQkFDQXJILG9CQUFvQjtvQkFDcEI4M0IsVUFBVVEsb0JBQW9CanhCLE1BQU1zdkIsU0FBUzRCLGNBQWMzMkIsYUFBYXlRO2dCQUMxRTtZQUNGO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxPQUFPMFE7QUFDVDtBQUNBLFNBQVM4VixxQkFBcUJKLGdCQUFnQjtJQUM1QyxJQUFJQSxxQkFBcUIsS0FBSyxHQUFHO1FBQy9CQSxtQkFBbUI7SUFDckI7SUFDQSxPQUFPO1FBQ0x0a0MsWUFBWTtRQUNaK2dDLGlCQUFpQjtRQUNqQnlCLFNBQVM7UUFDVDZCLGVBQWU7UUFDZm54QixNQUFNO1FBQ05reEIsY0FBYztRQUNkRTtRQUNBNzJCLGFBQWE7SUFDZjtBQUNGO0FBQ0EsTUFBTWszQixTQUFTO0lBQ2JqRCxRQUFRO1FBQ05ua0MsTUFBTTtRQUNOckIsUUFBUW9HO1FBQ1JnaUMsa0JBQWtCO1FBQ2xCOUMsMkJBQTJCO1FBQzNCbUMsVUFBVWUscUJBQXFCO0lBQ2pDO0FBQ0Y7QUFDQSxTQUFTRTtJQUNQLE1BQU1WLGlCQUFpQjNuQyx1REFBVUEsQ0FBQyxDQUFDZ0csR0FBR0MsSUFBTztZQUMzQ0Q7WUFDQUM7UUFDRjtJQUNBLE1BQU0yaEMsc0JBQXNCNW5DLHVEQUFVQSxDQUFDbW9DO0lBQ3ZDLE1BQU1ILG1CQUFtQmhvQyx1REFBVUEsQ0FBQyxTQUFVTCxNQUFNLEVBQUVvb0MsZ0JBQWdCLEVBQUU5Qyx5QkFBeUI7UUFDL0YsSUFBSThDLHFCQUFxQixLQUFLLEdBQUc7WUFDL0JBLG1CQUFtQjtRQUNyQjtRQUNBLE9BQU87WUFDTDVDLFFBQVE7Z0JBQ05ua0MsTUFBTTtnQkFDTnJCO2dCQUNBb29DO2dCQUNBOUM7Z0JBQ0FtQyxVQUFVUSxvQkFBb0JHO1lBQ2hDO1FBQ0Y7SUFDRjtJQUNBLE1BQU1PLGNBQWNQLENBQUFBO1FBQ2xCLE9BQU9BLG1CQUFtQkMsaUJBQWlCamlDLFFBQVFnaUMsa0JBQWtCLFFBQVE7SUFDL0U7SUFDQSxNQUFNUSxXQUFXLENBQUNDLE9BQU9DLFlBQVl6OUIsUUFBUTZGO1FBQzNDLE1BQU02M0IscUJBQXFCMTlCLE9BQU9jLFNBQVMsQ0FBQ2MsT0FBTyxDQUFDNDdCLE1BQU07UUFDMUQsTUFBTUcsK0JBQStCNzNCLFFBQVFELGNBQWN3TCxhQUFhLElBQUl4TCxjQUFjRSxRQUFRLENBQUN5M0IsTUFBTTtRQUN6RyxNQUFNcmpDLFVBQVUrRixjQUFjRjtRQUM5QixNQUFNKzhCLG1CQUFtQjVpQyxXQUFXQSxRQUFRRSxXQUFXLEtBQUttakMsUUFBUUMsYUFBYTtRQUNqRixJQUFJLENBQUNDLG9CQUFvQjtZQUN2QixJQUFJLENBQUNDLDhCQUE4QjtnQkFDakMsT0FBT0wsWUFBWVA7WUFDckI7WUFDQSxJQUFJLzhCLE9BQU9jLFNBQVMsQ0FBQ2EsU0FBUyxDQUFDNjdCLE1BQU0sRUFBRTtnQkFDckMsT0FBTztZQUNUO1lBQ0EsTUFBTTdjLFNBQVNwbEIsT0FBT3NLLGNBQWMvRCxXQUFXLENBQUN0RyxLQUFLO1lBQ3JELE1BQU03RyxTQUFTZ29DLGVBQWVoYyxPQUFPM2xCLENBQUMsRUFBRTJsQixPQUFPMWxCLENBQUM7WUFDaEQsT0FBTytoQyxpQkFBaUJyb0MsUUFBUW9vQyxrQkFBa0I7UUFDcEQ7UUFDQSxJQUFJWSw4QkFBOEI7WUFDaEMsT0FBT0wsWUFBWVA7UUFDckI7UUFDQSxNQUFNLzFCLGFBQWFoSCxPQUFPOEIsV0FBVyxDQUFDdEcsS0FBSztRQUMzQyxNQUFNN0csU0FBU2dvQyxlQUFlMzFCLFdBQVdoTSxDQUFDLEVBQUVnTSxXQUFXL0wsQ0FBQztRQUN4RCxPQUFPK2hDLGlCQUFpQnJvQyxRQUFRb29DLGtCQUFrQlcsbUJBQW1CbjVCLGFBQWE7SUFDcEY7SUFDQSxNQUFNOGlCLFdBQVcsQ0FBQy9aLE9BQU8ydkI7UUFDdkIsSUFBSXhrQyxXQUFXNlUsUUFBUTtZQUNyQixJQUFJQSxNQUFNSyxRQUFRLENBQUNoTyxTQUFTLENBQUN6RixFQUFFLEtBQUsraUMsU0FBUzVpQyxXQUFXLEVBQUU7Z0JBQ3hELE9BQU87WUFDVDtZQUNBLE9BQU9rakMsU0FBU04sU0FBUzVpQyxXQUFXLEVBQUVpVCxNQUFNSyxRQUFRLENBQUNoTyxTQUFTLENBQUN6RixFQUFFLEVBQUVvVCxNQUFNdE4sTUFBTSxFQUFFc04sTUFBTXpILGFBQWE7UUFDdEc7UUFDQSxJQUFJeUgsTUFBTVUsS0FBSyxLQUFLLGtCQUFrQjtZQUNwQyxNQUFNd0YsWUFBWWxHLE1BQU1rRyxTQUFTO1lBQ2pDLElBQUlBLFVBQVU3WSxNQUFNLENBQUNOLFdBQVcsS0FBSzRpQyxTQUFTNWlDLFdBQVcsRUFBRTtnQkFDekQsT0FBTztZQUNUO1lBQ0EsT0FBT2tqQyxTQUFTTixTQUFTNWlDLFdBQVcsRUFBRW1aLFVBQVU3WSxNQUFNLENBQUNOLFdBQVcsRUFBRW1aLFVBQVV4VCxNQUFNLEVBQUV3VCxVQUFVM04sYUFBYTtRQUMvRztRQUNBLE9BQU87SUFDVDtJQUNBLE9BQU93aEI7QUFDVDtBQUNBLE1BQU11Vyx3QkFBd0I7SUFDNUIsTUFBTUMsbUJBQW1CbkI7SUFDekIsTUFBTW9CLG9CQUFvQlQ7SUFDMUIsTUFBTWhXLFdBQVcsQ0FBQy9aLE9BQU8ydkIsV0FBYVksaUJBQWlCdndCLE9BQU8ydkIsYUFBYWEsa0JBQWtCeHdCLE9BQU8ydkIsYUFBYUc7SUFDakgsT0FBTy9WO0FBQ1Q7QUFDQSxNQUFNMFcsdUJBQXVCO0lBQzNCeG9CLHVCQUF1QkE7QUFDekI7QUFDQSxNQUFNeW9CLHFCQUFxQjFwQyxvREFBT0EsQ0FBQ3NwQyx1QkFBdUJHLHNCQUFzQixNQUFNO0lBQ3BGalgsU0FBU2lGO0lBQ1RrUyxvQkFBb0IzQjtBQUN0QixHQUFHRDtBQUNILElBQUk2Qix1QkFBdUJGO0FBRTNCLFNBQVNHLGlCQUFpQmhsQyxLQUFLO0lBQzdCLE1BQU1pbEMsbUJBQW1CakQsbUJBQW1CUjtJQUM1QyxNQUFNMEQsa0JBQWtCRCxpQkFBaUJDLGVBQWU7SUFDeEQsSUFBSUEsb0JBQW9CbGxDLE1BQU1rQixXQUFXLElBQUksQ0FBQ2xCLE1BQU04aEMsT0FBTyxFQUFFO1FBQzNELE9BQU87SUFDVDtJQUNBLHFCQUFPMW5DLDBEQUFtQixDQUFDMnFDLHNCQUFzQi9rQztBQUNuRDtBQUNBLFNBQVNtbEMsZ0JBQWdCbmxDLEtBQUs7SUFDNUIsTUFBTThRLFlBQVksT0FBTzlRLE1BQU1vbEMsY0FBYyxLQUFLLFlBQVksQ0FBQ3BsQyxNQUFNb2xDLGNBQWMsR0FBRztJQUN0RixNQUFNakksNkJBQTZCeHdCLFFBQVEzTSxNQUFNcWxDLGlDQUFpQztJQUNsRixNQUFNN00sMEJBQTBCN3JCLFFBQVEzTSxNQUFNdzRCLHVCQUF1QjtJQUNyRSxxQkFBT3ArQiwwREFBbUIsQ0FBQzRxQyxrQkFBa0JqcEMsOEVBQVFBLENBQUMsQ0FBQyxHQUFHaUUsT0FBTztRQUMvRDhoQyxTQUFTO1FBQ1RoeEIsV0FBV0E7UUFDWHFzQiw0QkFBNEJBO1FBQzVCM0UseUJBQXlCQTtJQUMzQjtBQUNGO0FBRUEsTUFBTThNLFVBQVUvWCxDQUFBQSxPQUFRbHhCLENBQUFBLFFBQVNreEIsU0FBU2x4QjtBQUMxQyxNQUFNa3BDLFdBQVdELFFBQVE7QUFDekIsTUFBTUUsU0FBU0YsUUFBUTtBQUN2QixNQUFNMzVCLFlBQVkyNUIsUUFBUTtBQUMxQixNQUFNRyxXQUFXLENBQUN2UyxVQUFVajFCLEtBQU9BLEdBQUdpMUIsU0FBU3dTLFNBQVMsS0FBS3puQyxHQUFHaTFCLFNBQVN5UyxTQUFTO0FBQ2xGLE1BQU1DLFNBQVMsQ0FBQzFTLFVBQVVqMUIsS0FBT0EsR0FBR2kxQixTQUFTd1MsU0FBUyxLQUFLem5DLEdBQUdpMUIsU0FBU3lTLFNBQVM7QUFDaEYsTUFBTUUsc0JBQXNCcm9DLENBQUFBO0lBQzFCLE1BQU04ZixRQUFReGdCLE9BQU9xa0MsZ0JBQWdCLENBQUMzakM7SUFDdEMsTUFBTTAxQixXQUFXO1FBQ2Z3UyxXQUFXcG9CLE1BQU1vb0IsU0FBUztRQUMxQkMsV0FBV3JvQixNQUFNcW9CLFNBQVM7SUFDNUI7SUFDQSxPQUFPRixTQUFTdlMsVUFBVXFTLGFBQWFFLFNBQVN2UyxVQUFVc1M7QUFDNUQ7QUFDQSxNQUFNTSxtQkFBbUI7SUFDdkIsSUFBSTdwQyxLQUF5QixFQUFjLEVBRTFDO0lBQ0QsTUFBTTZ5QixPQUFPZ0U7SUFDYixNQUFNaVQsT0FBT3hsQixTQUFTb0csZUFBZTtJQUNyQyxDQUFDb2YsT0FBTzlwQyxLQUFxQyxHQUFHMkMsVUFBVSxTQUFTQSxDQUFnQixHQUFHLEtBQUs7SUFDM0YsSUFBSSxDQUFDaW5DLG9CQUFvQi9XLE9BQU87UUFDOUIsT0FBTztJQUNUO0lBQ0EsTUFBTWtYLFlBQVlscEMsT0FBT3FrQyxnQkFBZ0IsQ0FBQzRFO0lBQzFDLE1BQU1FLGVBQWU7UUFDbkJQLFdBQVdNLFVBQVVOLFNBQVM7UUFDOUJDLFdBQVdLLFVBQVVMLFNBQVM7SUFDaEM7SUFDQSxJQUFJQyxPQUFPSyxjQUFjdDZCLFlBQVk7UUFDbkMsT0FBTztJQUNUO0lBM29ORixLQTRvTnVDLEdBQUczTyxRQUFRLENBQUM7Ozs7Ozs7OztFQVNqRCxDQUFDLElBQUksQ0FBTTtJQUNYLE9BQU87QUFDVDtBQUNBLE1BQU1rcEMsdUJBQXVCMW9DLENBQUFBO0lBQzNCLElBQUlBLE1BQU0sTUFBTTtRQUNkLE9BQU87SUFDVDtJQUNBLElBQUlBLE9BQU8raUIsU0FBU3VPLElBQUksRUFBRTtRQUN4QixPQUFPZ1gscUJBQXFCdG9DLEtBQUs7SUFDbkM7SUFDQSxJQUFJQSxPQUFPK2lCLFNBQVNvRyxlQUFlLEVBQUU7UUFDbkMsT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDa2Ysb0JBQW9Ccm9DLEtBQUs7UUFDNUIsT0FBTzBvQyxxQkFBcUIxb0MsR0FBR3krQixhQUFhO0lBQzlDO0lBQ0EsT0FBT3orQjtBQUNUO0FBQ0EsSUFBSTJvQyx5QkFBeUJEO0FBRTdCLElBQUlFLGlDQUFrQzlnQyxDQUFBQTtJQUNwQyxJQUFJLENBQUNBLFlBQVk7UUFDZjtJQUNGO0lBQ0EsTUFBTStnQyxzQkFBc0JGLHVCQUF1QjdnQyxXQUFXMjJCLGFBQWE7SUFDM0UsSUFBSSxDQUFDb0sscUJBQXFCO1FBQ3hCO0lBQ0Y7SUFock5GLEtBaXJOdUMsR0FBR3JwQyxRQUFRLENBQUM7Ozs7OztFQU1qRCxDQUFDLElBQUksQ0FBTTtBQUNiO0FBRUEsSUFBSXNwQyxZQUFhOW9DLENBQUFBLEtBQU87UUFDdEJxRSxHQUFHckUsR0FBRytvQyxVQUFVO1FBQ2hCemtDLEdBQUd0RSxHQUFHZ3BDLFNBQVM7SUFDakI7QUFFQSxNQUFNQyxhQUFhanBDLENBQUFBO0lBQ2pCLElBQUksQ0FBQ0EsSUFBSTtRQUNQLE9BQU87SUFDVDtJQUNBLE1BQU04ZixRQUFReGdCLE9BQU9xa0MsZ0JBQWdCLENBQUMzakM7SUFDdEMsSUFBSThmLE1BQU1uZCxRQUFRLEtBQUssU0FBUztRQUM5QixPQUFPO0lBQ1Q7SUFDQSxPQUFPc21DLFdBQVdqcEMsR0FBR3krQixhQUFhO0FBQ3BDO0FBQ0EsSUFBSXlLLFNBQVVwbUMsQ0FBQUE7SUFDWixNQUFNcW1DLG9CQUFvQlIsdUJBQXVCN2xDO0lBQ2pELE1BQU1zYSxnQkFBZ0I2ckIsV0FBV25tQztJQUNqQyxPQUFPO1FBQ0xxbUM7UUFDQS9yQjtJQUNGO0FBQ0Y7QUFFQSxJQUFJZ3NCLHdCQUF5QmhpQyxDQUFBQTtJQUMzQixJQUFJLEVBQ0ZtQixVQUFVLEVBQ1YrSyxTQUFTLEVBQ1R0SixnQkFBZ0IsRUFDaEJvVCxhQUFhLEVBQ2IvUSxTQUFTLEVBQ1R3RyxNQUFNLEVBQ054TCxJQUFJLEVBQ0ppSyxPQUFPLEVBQ1IsR0FBR2xLO0lBQ0osTUFBTTFCLFFBQVEsQ0FBQztRQUNiLElBQUksQ0FBQzRMLFNBQVM7WUFDWixPQUFPO1FBQ1Q7UUFDQSxNQUFNLEVBQ0orM0IsVUFBVSxFQUNWeDJCLFFBQVF5MkIsV0FBVyxFQUNwQixHQUFHaDRCO1FBQ0osTUFBTXVFLFlBQVlnVCxhQUFhO1lBQzdCQyxjQUFjdWdCLFdBQVd2Z0IsWUFBWTtZQUNyQ0MsYUFBYXNnQixXQUFXdGdCLFdBQVc7WUFDbkM3aUIsUUFBUW9qQyxZQUFZQyxVQUFVLENBQUNyakMsTUFBTTtZQUNyQ0QsT0FBT3FqQyxZQUFZQyxVQUFVLENBQUN0akMsS0FBSztRQUNyQztRQUNBLE9BQU87WUFDTGlCLGVBQWVvSyxRQUFRakssSUFBSSxDQUFDRSxTQUFTO1lBQ3JDK2hDO1lBQ0FEO1lBQ0FwaUMsbUJBQW1CcUssUUFBUXJLLGlCQUFpQjtZQUM1Q1QsUUFBUTtnQkFDTndCLFNBQVNzSixRQUFROUssTUFBTTtnQkFDdkIwQixTQUFTb0osUUFBUTlLLE1BQU07Z0JBQ3ZCWCxLQUFLZ1E7Z0JBQ0xwUCxNQUFNO29CQUNKNUgsT0FBT3VGO29CQUNQc0MsY0FBY3RDO2dCQUNoQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE1BQU13QyxPQUFPeUYsY0FBYyxhQUFhRCxXQUFXTztJQUNuRCxNQUFNaEgsVUFBVXdCLFdBQVc7UUFDekJFO1FBQ0FSLGlCQUFpQjtRQUNqQkQ7UUFDQWxCO0lBQ0Y7SUFDQSxNQUFNMlAsWUFBWTtRQUNoQjlNO1FBQ0F5QjtRQUNBb1Q7UUFDQXhXO1FBQ0EwTTtRQUNBVDtRQUNBeEw7UUFDQTNCO1FBQ0FDO0lBQ0Y7SUFDQSxPQUFPMFA7QUFDVDtBQUVBLE1BQU1tMEIsWUFBWSxDQUFDQyxXQUFXTjtJQUM1QixNQUFNcFosT0FBTzV4QixxREFBTUEsQ0FBQ3NyQztJQUNwQixJQUFJLENBQUNOLG1CQUFtQjtRQUN0QixPQUFPcFo7SUFDVDtJQUNBLElBQUkwWixjQUFjTixtQkFBbUI7UUFDbkMsT0FBT3BaO0lBQ1Q7SUFDQSxNQUFNbnFCLE1BQU1tcUIsS0FBS3daLFVBQVUsQ0FBQzNqQyxHQUFHLEdBQUd1akMsa0JBQWtCSCxTQUFTO0lBQzdELE1BQU1oakMsT0FBTytwQixLQUFLd1osVUFBVSxDQUFDdmpDLElBQUksR0FBR21qQyxrQkFBa0JKLFVBQVU7SUFDaEUsTUFBTWhqQyxTQUFTSCxNQUFNdWpDLGtCQUFrQnJnQixZQUFZO0lBQ25ELE1BQU1oakIsUUFBUUUsT0FBT21qQyxrQkFBa0JwZ0IsV0FBVztJQUNsRCxNQUFNd2dCLGFBQWE7UUFDakIzakM7UUFDQUU7UUFDQUM7UUFDQUM7SUFDRjtJQUNBLE1BQU1vSyxZQUFZclMscURBQU1BLENBQUN3ckMsWUFBWXhaLEtBQUt5RixNQUFNO0lBQ2hELE1BQU0zaUIsU0FBU3pVLHdEQUFTQSxDQUFDO1FBQ3ZCZ1M7UUFDQUksUUFBUXVmLEtBQUt2ZixNQUFNO1FBQ25CZ2xCLFFBQVF6RixLQUFLeUYsTUFBTTtRQUNuQkMsU0FBUzFGLEtBQUswRixPQUFPO0lBQ3ZCO0lBQ0EsT0FBTzVpQjtBQUNUO0FBQ0EsSUFBSTZWLGVBQWdCdGhCLENBQUFBO0lBQ2xCLElBQUksRUFDRm1yQixHQUFHLEVBQ0hocUIsVUFBVSxFQUNWbWhDLEdBQUcsRUFDSGpnQixZQUFZLEVBQ1pwZCxTQUFTLEVBQ1RzOUIsY0FBYyxFQUNkMy9CLGdCQUFnQixFQUNoQi9DLGlCQUFpQixFQUNsQixHQUFHRztJQUNKLE1BQU0raEMsb0JBQW9CTyxJQUFJUCxpQkFBaUI7SUFDL0MsTUFBTXQyQixTQUFTMjJCLFVBQVVqWCxLQUFLNFc7SUFDOUIsTUFBTTloQyxPQUFPcEoseURBQVVBLENBQUM0VSxRQUFRNFc7SUFDaEMsTUFBTW5ZLFVBQVUsQ0FBQztRQUNmLElBQUksQ0FBQzYzQixtQkFBbUI7WUFDdEIsT0FBTztRQUNUO1FBQ0EsTUFBTUcsY0FBY25yQyxxREFBTUEsQ0FBQ2dyQztRQUMzQixNQUFNRSxhQUFhO1lBQ2pCdmdCLGNBQWNxZ0Isa0JBQWtCcmdCLFlBQVk7WUFDNUNDLGFBQWFvZ0Isa0JBQWtCcGdCLFdBQVc7UUFDNUM7UUFDQSxPQUFPO1lBQ0xsVyxRQUFReTJCO1lBQ1JqaUMsTUFBTXBKLHlEQUFVQSxDQUFDcXJDLGFBQWE3ZjtZQUM5QmpqQixRQUFRc2lDLFVBQVVLO1lBQ2xCRTtZQUNBcGlDO1FBQ0Y7SUFDRjtJQUNBLE1BQU1vTyxZQUFZK3pCLHNCQUFzQjtRQUN0QzdnQztRQUNBK0ssV0FBVyxDQUFDcTJCO1FBQ1ozL0I7UUFDQW9ULGVBQWVzc0IsSUFBSXRzQixhQUFhO1FBQ2hDL1E7UUFDQXdHO1FBQ0F4TDtRQUNBaUs7SUFDRjtJQUNBLE9BQU8rRDtBQUNUO0FBRUEsTUFBTXUwQixZQUFZO0lBQ2hCL21CLFNBQVM7QUFDWDtBQUNBLE1BQU1nbkIsVUFBVTtJQUNkaG5CLFNBQVM7QUFDWDtBQUNBLElBQUlpbkIscUJBQXNCeHBDLENBQUFBLFVBQVdBLFFBQVFxZix3QkFBd0IsR0FBR2lxQixZQUFZQztBQUVwRixNQUFNRSwrQkFBK0JocUIsQ0FBQUEsV0FBWUEsWUFBWUEsU0FBUzJwQixHQUFHLENBQUNQLGlCQUFpQixJQUFJO0FBQy9GLFNBQVNhLHNCQUFzQno4QixJQUFJO0lBQ2pDLE1BQU0wOEIsbUJBQW1CanRDLDZDQUFNQSxDQUFDO0lBQ2hDLE1BQU1nbEMsYUFBYXdDLG1CQUFtQjNOO0lBQ3RDLE1BQU1sQyxXQUFXNEIsY0FBYztJQUMvQixNQUFNLEVBQ0pqTyxRQUFRLEVBQ1JoSixPQUFPLEVBQ1IsR0FBRzBpQjtJQUNKLE1BQU05RCxjQUFjMUYsWUFBWWpyQjtJQUNoQyxNQUFNaEYsYUFBYTNLLHFEQUFPQSxDQUFDLElBQU87WUFDaEMyRixJQUFJZ0ssS0FBS3BLLFdBQVc7WUFDcEI5RCxNQUFNa08sS0FBS2xPLElBQUk7WUFDZjJWLE1BQU16SCxLQUFLeUgsSUFBSTtRQUNqQixJQUFJO1FBQUN6SCxLQUFLcEssV0FBVztRQUFFb0ssS0FBS3lILElBQUk7UUFBRXpILEtBQUtsTyxJQUFJO0tBQUM7SUFDNUMsTUFBTTZxQyx5QkFBeUJsdEMsNkNBQU1BLENBQUN1TDtJQUN0QyxNQUFNNGhDLHVCQUF1QnZzQyxxREFBT0EsQ0FBQyxJQUFNUyx1REFBVUEsQ0FBQyxDQUFDZ0csR0FBR0M7WUFDeEQsQ0FBQzJsQyxpQkFBaUIvaEMsT0FBTyxHQUFHekosS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywwQ0FBMENBLENBQWdCLEdBQUcsS0FBSztZQUN2SixNQUFNb0YsU0FBUztnQkFDYm5DO2dCQUNBQztZQUNGO1lBQ0FnYixRQUFReEIscUJBQXFCLENBQUN2VixXQUFXaEYsRUFBRSxFQUFFaUQ7UUFDL0MsSUFBSTtRQUFDK0IsV0FBV2hGLEVBQUU7UUFBRStiO0tBQVE7SUFDNUIsTUFBTThxQixtQkFBbUJ2c0MseURBQVdBLENBQUM7UUFDbkMsTUFBTWtpQixXQUFXa3FCLGlCQUFpQi9oQyxPQUFPO1FBQ3pDLElBQUksQ0FBQzZYLFlBQVksQ0FBQ0EsU0FBUzJwQixHQUFHLENBQUNQLGlCQUFpQixFQUFFO1lBQ2hELE9BQU8va0M7UUFDVDtRQUNBLE9BQU8wa0MsVUFBVS9vQixTQUFTMnBCLEdBQUcsQ0FBQ1AsaUJBQWlCO0lBQ2pELEdBQUcsRUFBRTtJQUNMLE1BQU1qbUIsZUFBZXJsQix5REFBV0EsQ0FBQztRQUMvQixNQUFNMkksU0FBUzRqQztRQUNmRCxxQkFBcUIzakMsT0FBT25DLENBQUMsRUFBRW1DLE9BQU9sQyxDQUFDO0lBQ3pDLEdBQUc7UUFBQzhsQztRQUFrQkQ7S0FBcUI7SUFDM0MsTUFBTUUsdUJBQXVCenNDLHFEQUFPQSxDQUFDLElBQU1VLG9EQUFPQSxDQUFDNGtCLGVBQWU7UUFBQ0E7S0FBYTtJQUNoRixNQUFNb25CLGtCQUFrQnpzQyx5REFBV0EsQ0FBQztRQUNsQyxNQUFNa2lCLFdBQVdrcUIsaUJBQWlCL2hDLE9BQU87UUFDekMsTUFBTW9KLFVBQVV5NEIsNkJBQTZCaHFCO1FBQzdDLENBQUVBLENBQUFBLFlBQVl6TyxPQUFNLElBQUs3UyxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLG1EQUFtREEsQ0FBZ0IsR0FBRyxLQUFLO1FBQzdKLE1BQU1kLFVBQVV5ZixTQUFTTCxhQUFhO1FBQ3RDLElBQUlwZixRQUFRcWYsd0JBQXdCLEVBQUU7WUFDcEN1RDtZQUNBO1FBQ0Y7UUFDQW1uQjtJQUNGLEdBQUc7UUFBQ0E7UUFBc0JubkI7S0FBYTtJQUN2QyxNQUFNeUcsNkJBQTZCOXJCLHlEQUFXQSxDQUFDLENBQUM0ckIsY0FBY25wQjtRQUM1RCxDQUFDLENBQUMycEMsaUJBQWlCL2hDLE9BQU8sR0FBR3pKLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sMERBQTBEQSxDQUFnQixHQUFHLEtBQUs7UUFDeEssTUFBTWtILFdBQVc0MUIsWUFBWWgyQixPQUFPO1FBQ3BDLE1BQU1xcUIsTUFBTWpxQixTQUFTaWlDLGVBQWU7UUFDcEMsQ0FBQ2hZLE1BQU05ekIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyw0Q0FBNENBLENBQWdCLEdBQUcsS0FBSztRQUNwSSxNQUFNc29DLE1BQU1SLE9BQU8zVztRQUNuQixNQUFNeFMsV0FBVztZQUNmd1M7WUFDQWhxQjtZQUNBbWhDO1lBQ0FocUIsZUFBZXBmO1FBQ2pCO1FBQ0EycEMsaUJBQWlCL2hDLE9BQU8sR0FBRzZYO1FBQzNCLE1BQU0xSyxZQUFZcVQsYUFBYTtZQUM3QjZKO1lBQ0FocUI7WUFDQW1oQztZQUNBamdCO1lBQ0FwZCxXQUFXL0QsU0FBUytELFNBQVM7WUFDN0JzOUIsZ0JBQWdCcmhDLFNBQVNxaEMsY0FBYztZQUN2QzMvQixrQkFBa0IxQixTQUFTMEIsZ0JBQWdCO1lBQzNDL0MsbUJBQW1CLENBQUNxQixTQUFTa2lDLHVCQUF1QjtRQUN0RDtRQUNBLE1BQU0xaUMsYUFBYTRoQyxJQUFJUCxpQkFBaUI7UUFDeEMsSUFBSXJoQyxZQUFZO1lBQ2RBLFdBQVdncUIsWUFBWSxDQUFDN0IsZ0JBQWdCRCxTQUFTLEVBQUVnUyxXQUFXaFMsU0FBUztZQUN2RWxvQixXQUFXdkgsZ0JBQWdCLENBQUMsVUFBVStwQyxpQkFBaUJSLG1CQUFtQi9wQixTQUFTTCxhQUFhO1lBQ2hHLElBQUlqaEIsSUFBeUIsRUFBYztnQkFDekNtcUMsK0JBQStCOWdDO1lBQ2pDO1FBQ0Y7UUFDQSxPQUFPdU47SUFDVCxHQUFHO1FBQUMyc0IsV0FBV2hTLFNBQVM7UUFBRXpuQjtRQUFZK2hDO1FBQWlCcE07S0FBWTtJQUNuRSxNQUFNdlYseUJBQXlCOXFCLHlEQUFXQSxDQUFDO1FBQ3pDLE1BQU1raUIsV0FBV2txQixpQkFBaUIvaEMsT0FBTztRQUN6QyxNQUFNb0osVUFBVXk0Qiw2QkFBNkJocUI7UUFDN0MsQ0FBRUEsQ0FBQUEsWUFBWXpPLE9BQU0sSUFBSzdTLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8scUZBQXFGQSxDQUFnQixHQUFHLEtBQUs7UUFDL0wsT0FBTzBuQyxVQUFVeDNCO0lBQ25CLEdBQUcsRUFBRTtJQUNMLE1BQU0yWSxjQUFjcHNCLHlEQUFXQSxDQUFDO1FBQzlCLE1BQU1raUIsV0FBV2txQixpQkFBaUIvaEMsT0FBTztRQUN6QyxDQUFDNlgsV0FBV3RoQixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLDBDQUEwQ0EsQ0FBZ0IsR0FBRyxLQUFLO1FBQ3ZJLE1BQU1rUSxVQUFVeTRCLDZCQUE2QmhxQjtRQUM3Q2txQixpQkFBaUIvaEMsT0FBTyxHQUFHO1FBQzNCLElBQUksQ0FBQ29KLFNBQVM7WUFDWjtRQUNGO1FBQ0ErNEIscUJBQXFCL21CLE1BQU07UUFDM0JoUyxRQUFRbTVCLGVBQWUsQ0FBQ3hhLGdCQUFnQkQsU0FBUztRQUNqRDFlLFFBQVEzUSxtQkFBbUIsQ0FBQyxVQUFVMnBDLGlCQUFpQlIsbUJBQW1CL3BCLFNBQVNMLGFBQWE7SUFDbEcsR0FBRztRQUFDNHFCO1FBQWlCRDtLQUFxQjtJQUMxQyxNQUFNN2pDLFNBQVMzSSx5REFBV0EsQ0FBQ21zQixDQUFBQTtRQUN6QixNQUFNakssV0FBV2txQixpQkFBaUIvaEMsT0FBTztRQUN6QyxDQUFDNlgsV0FBV3RoQixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHlDQUF5Q0EsQ0FBZ0IsR0FBRyxLQUFLO1FBQ3RJLE1BQU1rUSxVQUFVeTRCLDZCQUE2QmhxQjtRQUM3QyxDQUFDek8sVUFBVTdTLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sMERBQTBEQSxDQUFnQixHQUFHLEtBQUs7UUFDdEprUSxRQUFRMDNCLFNBQVMsSUFBSWhmLE9BQU8xbEIsQ0FBQztRQUM3QmdOLFFBQVF5M0IsVUFBVSxJQUFJL2UsT0FBTzNsQixDQUFDO0lBQ2hDLEdBQUcsRUFBRTtJQUNMLE1BQU0zQyxZQUFZOUQscURBQU9BLENBQUM7UUFDeEIsT0FBTztZQUNMK3JCO1lBQ0FoQjtZQUNBc0I7WUFDQXpqQjtRQUNGO0lBQ0YsR0FBRztRQUFDeWpCO1FBQWFOO1FBQTRCaEI7UUFBd0JuaUI7S0FBTztJQUM1RSxNQUFNK2QsUUFBUTNtQixxREFBT0EsQ0FBQyxJQUFPO1lBQzNCKzJCO1lBQ0Fwc0I7WUFDQTdHO1FBQ0YsSUFBSTtRQUFDQTtRQUFXNkc7UUFBWW9zQjtLQUFTO0lBQ3JDOTNCLGdCQUFnQjtRQUNkcXRDLHVCQUF1QmhpQyxPQUFPLEdBQUdxYyxNQUFNaGMsVUFBVTtRQUNqRCtmLFNBQVMxZ0IsU0FBUyxDQUFDK3JCLFFBQVEsQ0FBQ3BQO1FBQzVCLE9BQU87WUFDTCxJQUFJMGxCLGlCQUFpQi9oQyxPQUFPLEVBQUU7Z0JBMTlOcEMsS0EyOU42QyxHQUFHMUksUUFBUSxnRkFBZ0YsQ0FBTTtnQkFDdEl5cUI7WUFDRjtZQUNBM0IsU0FBUzFnQixTQUFTLENBQUNnc0IsVUFBVSxDQUFDclA7UUFDaEM7SUFDRixHQUFHO1FBQUM3aUI7UUFBVzZHO1FBQVkwaEI7UUFBYTFGO1FBQU9qRjtRQUFTZ0osU0FBUzFnQixTQUFTO0tBQUM7SUFDM0UvSyxnQkFBZ0I7UUFDZCxJQUFJLENBQUNvdEMsaUJBQWlCL2hDLE9BQU8sRUFBRTtZQUM3QjtRQUNGO1FBQ0FvWCxRQUFRdkIsd0JBQXdCLENBQUNtc0IsdUJBQXVCaGlDLE9BQU8sQ0FBQzNFLEVBQUUsRUFBRSxDQUFDZ0ssS0FBS284QixjQUFjO0lBQzFGLEdBQUc7UUFBQ3A4QixLQUFLbzhCLGNBQWM7UUFBRXJxQjtLQUFRO0lBQ2pDemlCLGdCQUFnQjtRQUNkLElBQUksQ0FBQ290QyxpQkFBaUIvaEMsT0FBTyxFQUFFO1lBQzdCO1FBQ0Y7UUFDQW9YLFFBQVF0QiwrQkFBK0IsQ0FBQ2tzQix1QkFBdUJoaUMsT0FBTyxDQUFDM0UsRUFBRSxFQUFFZ0ssS0FBS3ZELGdCQUFnQjtJQUNsRyxHQUFHO1FBQUN1RCxLQUFLdkQsZ0JBQWdCO1FBQUVzVjtLQUFRO0FBQ3JDO0FBRUEsU0FBU29yQixRQUFRO0FBQ2pCLE1BQU1DLFFBQVE7SUFDWjFrQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUnNLLFFBQVFsSztBQUNWO0FBQ0EsTUFBTXNrQyxVQUFVeGpDLENBQUFBO0lBQ2QsSUFBSSxFQUNGeWpDLHNCQUFzQixFQUN0QjN2QixXQUFXLEVBQ1g0dkIsT0FBTyxFQUNSLEdBQUcxakM7SUFDSixJQUFJeWpDLHdCQUF3QjtRQUMxQixPQUFPRjtJQUNUO0lBQ0EsSUFBSUcsWUFBWSxTQUFTO1FBQ3ZCLE9BQU9IO0lBQ1Q7SUFDQSxPQUFPO1FBQ0x6a0MsUUFBUWdWLFlBQVlySSxNQUFNLENBQUN6QyxTQUFTLENBQUNsSyxNQUFNO1FBQzNDRCxPQUFPaVYsWUFBWXJJLE1BQU0sQ0FBQ3pDLFNBQVMsQ0FBQ25LLEtBQUs7UUFDekN1SyxRQUFRMEssWUFBWXJJLE1BQU0sQ0FBQ3JDLE1BQU07SUFDbkM7QUFDRjtBQUNBLE1BQU11NkIsV0FBV3Q4QixDQUFBQTtJQUNmLElBQUksRUFDRm84QixzQkFBc0IsRUFDdEIzdkIsV0FBVyxFQUNYNHZCLE9BQU8sRUFDUixHQUFHcjhCO0lBQ0osTUFBTWxDLE9BQU9xK0IsUUFBUTtRQUNuQkM7UUFDQTN2QjtRQUNBNHZCO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xsVSxTQUFTMWIsWUFBWTBiLE9BQU87UUFDNUJxTSxXQUFXO1FBQ1hoOUIsT0FBT3NHLEtBQUt0RyxLQUFLO1FBQ2pCQyxRQUFRcUcsS0FBS3JHLE1BQU07UUFDbkI4a0MsV0FBV3orQixLQUFLaUUsTUFBTSxDQUFDNUssR0FBRztRQUMxQnFsQyxhQUFhMStCLEtBQUtpRSxNQUFNLENBQUMxSyxLQUFLO1FBQzlCb2xDLGNBQWMzK0IsS0FBS2lFLE1BQU0sQ0FBQ3pLLE1BQU07UUFDaENvbEMsWUFBWTUrQixLQUFLaUUsTUFBTSxDQUFDeEssSUFBSTtRQUM1Qm9sQyxZQUFZO1FBQ1pDLFVBQVU7UUFDVmxJLGVBQWU7UUFDZmhTLFlBQVkyWixZQUFZLFNBQVNscUIsWUFBWTFGLFdBQVcsR0FBRztJQUM3RDtBQUNGO0FBQ0EsTUFBTW93QixjQUFjOW9DLENBQUFBO0lBQ2xCLE1BQU0rb0Msc0JBQXNCdnVDLDZDQUFNQSxDQUFDO0lBQ25DLE1BQU13dUMsMkJBQTJCM3RDLHlEQUFXQSxDQUFDO1FBQzNDLElBQUksQ0FBQzB0QyxvQkFBb0JyakMsT0FBTyxFQUFFO1lBQ2hDO1FBQ0Y7UUFDQWdjLGFBQWFxbkIsb0JBQW9CcmpDLE9BQU87UUFDeENxakMsb0JBQW9CcmpDLE9BQU8sR0FBRztJQUNoQyxHQUFHLEVBQUU7SUFDTCxNQUFNLEVBQ0o0aUMsT0FBTyxFQUNQMUYsZUFBZSxFQUNmcUcsT0FBTyxFQUNQemIsU0FBUyxFQUNWLEdBQUd4dEI7SUFDSixNQUFNLENBQUNxb0Msd0JBQXdCYSwwQkFBMEIsR0FBR3p1QywrQ0FBUUEsQ0FBQ3VGLE1BQU1zb0MsT0FBTyxLQUFLO0lBQ3ZGL3RDLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDOHRDLHdCQUF3QjtZQUMzQixPQUFPSDtRQUNUO1FBQ0EsSUFBSUksWUFBWSxRQUFRO1lBQ3RCVTtZQUNBRSwwQkFBMEI7WUFDMUIsT0FBT2hCO1FBQ1Q7UUFDQSxJQUFJYSxvQkFBb0JyakMsT0FBTyxFQUFFO1lBQy9CLE9BQU93aUM7UUFDVDtRQUNBYSxvQkFBb0JyakMsT0FBTyxHQUFHK2IsV0FBVztZQUN2Q3NuQixvQkFBb0JyakMsT0FBTyxHQUFHO1lBQzlCd2pDLDBCQUEwQjtRQUM1QjtRQUNBLE9BQU9GO0lBQ1QsR0FBRztRQUFDVjtRQUFTRDtRQUF3Qlc7S0FBeUI7SUFDOUQsTUFBTUcsa0JBQWtCOXRDLHlEQUFXQSxDQUFDK0QsQ0FBQUE7UUFDbEMsSUFBSUEsTUFBTXVqQyxZQUFZLEtBQUssVUFBVTtZQUNuQztRQUNGO1FBQ0FDO1FBQ0EsSUFBSTBGLFlBQVksU0FBUztZQUN2Qlc7UUFDRjtJQUNGLEdBQUc7UUFBQ1g7UUFBU1c7UUFBU3JHO0tBQWdCO0lBQ3RDLE1BQU10bEIsUUFBUWlyQixTQUFTO1FBQ3JCRjtRQUNBQyxTQUFTdG9DLE1BQU1zb0MsT0FBTztRQUN0QjV2QixhQUFhMVksTUFBTTBZLFdBQVc7SUFDaEM7SUFDQSxxQkFBT3RlLDBEQUFtQixDQUFDNEYsTUFBTTBZLFdBQVcsQ0FBQ3NqQixPQUFPLEVBQUU7UUFDcEQxZTtRQUNBLG1DQUFtQ2tRO1FBQ25Db1YsaUJBQWlCdUc7UUFDakJwWixLQUFLL3ZCLE1BQU02aUMsUUFBUTtJQUNyQjtBQUNGO0FBQ0EsSUFBSXVHLDhCQUFnQmh2QyxpREFBVSxDQUFDMHVDO0FBRS9CLFNBQVNRLFVBQVVqdEMsS0FBSztJQUN0QixPQUFPLE9BQU9BLFVBQVU7QUFDMUI7QUFDQSxTQUFTa3RDLFVBQVV4K0IsSUFBSSxFQUFFeStCLE1BQU07SUFDN0JBLE9BQU9uckMsT0FBTyxDQUFDb3JDLENBQUFBLFFBQVNBLE1BQU0xK0I7QUFDaEM7QUFDQSxNQUFNMU4sU0FBUztJQUFDLFNBQVMydEIsU0FBU3BtQixJQUFJO1FBQ3BDLElBQUksRUFDRjVFLEtBQUssRUFDTixHQUFHNEU7UUFDSixDQUFDNUUsTUFBTVcsV0FBVyxHQUFHMUUsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyw2Q0FBNkNBLENBQWdCLEdBQUcsS0FBSztRQUNuSixDQUFFLFFBQU9vQixNQUFNVyxXQUFXLEtBQUssUUFBTyxJQUFLMUUsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLHdEQUF3RCxFQUFFLE9BQU9vQixNQUFNVyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUkvQixDQUFnQixHQUFHLEtBQUs7SUFDeE47SUFBRyxTQUFTOHFDLFFBQVF6OUIsS0FBSztRQUN2QixJQUFJLEVBQ0ZqTSxLQUFLLEVBQ04sR0FBR2lNO1FBQ0osQ0FBQ3E5QixVQUFVdHBDLE1BQU1tbkMsY0FBYyxJQUFJbHJDLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sc0NBQXNDQSxDQUFnQixHQUFHLEtBQUs7UUFDMUosQ0FBQzBxQyxVQUFVdHBDLE1BQU13SCxnQkFBZ0IsSUFBSXZMLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sd0NBQXdDQSxDQUFnQixHQUFHLEtBQUs7UUFDOUosQ0FBQzBxQyxVQUFVdHBDLE1BQU1nb0MsdUJBQXVCLElBQUkvckMsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywrQ0FBK0NBLENBQWdCLEdBQUcsS0FBSztJQUM5SztJQUFHLFNBQVNteEIsSUFBSXZoQixLQUFLO1FBQ25CLElBQUksRUFDRnU1QixlQUFlLEVBQ2hCLEdBQUd2NUI7UUFDSml6QixxQkFBcUJzRztJQUN2QjtDQUFFO0FBQ0YsTUFBTTRCLFdBQVc7SUFBQyxTQUFTanhCLFlBQVlvbEIsS0FBSztRQUMxQyxJQUFJLEVBQ0Y5OUIsS0FBSyxFQUNMNHBDLGlCQUFpQixFQUNsQixHQUFHOUw7UUFDSixJQUFJLENBQUM5OUIsTUFBTTBZLFdBQVcsRUFBRTtZQUN0QjtRQUNGO1FBQ0EsTUFBTXFYLE1BQU02WjtRQUNaLElBQUk3WixLQUFLO1lBQ1A7UUFDRjtRQTluT0YsS0Erbk91QyxHQUFHL3lCLFFBQVEsQ0FBQzsyQ0FDUixFQUFFZ0QsTUFBTVcsV0FBVyxDQUFDOzs7OztJQUszRCxDQUFDLElBQUksQ0FBTTtJQUNmO0NBQUU7QUFDRixNQUFNa3BDLFVBQVU7SUFBQyxTQUFTQyxTQUFTQyxLQUFLO1FBQ3RDLElBQUksRUFDRi9wQyxLQUFLLEVBQ04sR0FBRytwQztRQUNKLENBQUMvcEMsTUFBTWdxQyxXQUFXLEdBQUcvdEMsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywwRUFBMEVBLENBQWdCLEdBQUcsS0FBSztJQUNsTDtJQUFHLFNBQVNxckMsaUJBQWlCQyxLQUFLO1FBQ2hDLElBQUksRUFDRk4saUJBQWlCLEVBQ2xCLEdBQUdNO1FBQ0osQ0FBQyxDQUFDTixzQkFBc0IzdEMsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxxREFBcURBLENBQWdCLEdBQUcsS0FBSztJQUNoSztDQUFFO0FBQ0YsU0FBU3VyQyxjQUFjcC9CLElBQUk7SUFDekI2cUIsbUJBQW1CO1FBQ2pCMlQsVUFBVXgrQixNQUFNMU47UUFDaEIsSUFBSTBOLEtBQUsvSyxLQUFLLENBQUN3UyxJQUFJLEtBQUssWUFBWTtZQUNsQysyQixVQUFVeCtCLE1BQU00K0I7UUFDbEI7UUFDQSxJQUFJNStCLEtBQUsvSyxLQUFLLENBQUN3UyxJQUFJLEtBQUssV0FBVztZQUNqQysyQixVQUFVeCtCLE1BQU04K0I7UUFDbEI7SUFDRjtBQUNGO0FBRUEsTUFBTU8scUJBQXFCaHdDLDREQUFtQjtJQUM1QzRFLGFBQWM7UUFDWixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDa1YsS0FBSyxHQUFHO1lBQ1h4SSxXQUFXZ0IsUUFBUSxJQUFJLENBQUMzTSxLQUFLLENBQUNzcUMsRUFBRTtZQUNoQzNuQixNQUFNLElBQUksQ0FBQzNpQixLQUFLLENBQUNzcUMsRUFBRTtZQUNuQmhDLFNBQVMsSUFBSSxDQUFDdG9DLEtBQUssQ0FBQ29MLGFBQWEsSUFBSSxJQUFJLENBQUNwTCxLQUFLLENBQUNzcUMsRUFBRSxHQUFHLFNBQVM7UUFDaEU7UUFDQSxJQUFJLENBQUNyQixPQUFPLEdBQUc7WUFDYixJQUFJLElBQUksQ0FBQzkwQixLQUFLLENBQUNtMEIsT0FBTyxLQUFLLFNBQVM7Z0JBQ2xDO1lBQ0Y7WUFDQSxJQUFJLENBQUN6b0MsUUFBUSxDQUFDO2dCQUNaOEwsV0FBVztZQUNiO1FBQ0Y7SUFDRjtJQUNBLE9BQU80K0IseUJBQXlCdnFDLEtBQUssRUFBRW1VLEtBQUssRUFBRTtRQUM1QyxJQUFJLENBQUNuVSxNQUFNb0wsYUFBYSxFQUFFO1lBQ3hCLE9BQU87Z0JBQ0xPLFdBQVdnQixRQUFRM00sTUFBTXNxQyxFQUFFO2dCQUMzQjNuQixNQUFNM2lCLE1BQU1zcUMsRUFBRTtnQkFDZGhDLFNBQVM7WUFDWDtRQUNGO1FBQ0EsSUFBSXRvQyxNQUFNc3FDLEVBQUUsRUFBRTtZQUNaLE9BQU87Z0JBQ0wzK0IsV0FBVztnQkFDWGdYLE1BQU0zaUIsTUFBTXNxQyxFQUFFO2dCQUNkaEMsU0FBUztZQUNYO1FBQ0Y7UUFDQSxJQUFJbjBCLE1BQU14SSxTQUFTLEVBQUU7WUFDbkIsT0FBTztnQkFDTEEsV0FBVztnQkFDWGdYLE1BQU14TyxNQUFNd08sSUFBSTtnQkFDaEIybEIsU0FBUztZQUNYO1FBQ0Y7UUFDQSxPQUFPO1lBQ0wzOEIsV0FBVztZQUNYMjhCLFNBQVM7WUFDVDNsQixNQUFNO1FBQ1I7SUFDRjtJQUNBNWlCLFNBQVM7UUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDb1UsS0FBSyxDQUFDeEksU0FBUyxFQUFFO1lBQ3pCLE9BQU87UUFDVDtRQUNBLE1BQU1tWCxXQUFXO1lBQ2ZtbUIsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJ0bUIsTUFBTSxJQUFJLENBQUN4TyxLQUFLLENBQUN3TyxJQUFJO1lBQ3JCMmxCLFNBQVMsSUFBSSxDQUFDbjBCLEtBQUssQ0FBQ20wQixPQUFPO1FBQzdCO1FBQ0EsT0FBTyxJQUFJLENBQUN0b0MsS0FBSyxDQUFDQyxRQUFRLENBQUM2aUI7SUFDN0I7QUFDRjtBQUVBLE1BQU0wbkIsWUFBWXhxQyxDQUFBQTtJQUNoQixNQUFNdy9CLGFBQWE5a0MsaURBQVVBLENBQUMyNUI7SUFDOUIsQ0FBQ21MLGFBQWF2akMsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxnQ0FBZ0NBLENBQWdCLEdBQUcsS0FBSztJQUMvSCxNQUFNLEVBQ0o0dUIsU0FBUyxFQUNUNVksaUJBQWlCLEVBQ2xCLEdBQUc0cUI7SUFDSixNQUFNaUwsZUFBZWp3Qyw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNa3dDLGlCQUFpQmx3Qyw2Q0FBTUEsQ0FBQztJQUM5QixNQUFNLEVBQ0p5RixRQUFRLEVBQ1JVLFdBQVcsRUFDWDlELElBQUksRUFDSjJWLElBQUksRUFDSjNJLFNBQVMsRUFDVG0rQix1QkFBdUIsRUFDdkJiLGNBQWMsRUFDZDMvQixnQkFBZ0IsRUFDaEJ5N0IsUUFBUSxFQUNSMEgsUUFBUSxFQUNSaHZCLHVCQUF1QixFQUN2Qml2QixvQkFBb0IsRUFDckIsR0FBRzVxQztJQUNKLE1BQU0rbkMsa0JBQWtCMXNDLHlEQUFXQSxDQUFDLElBQU1vdkMsYUFBYS9rQyxPQUFPLEVBQUUsRUFBRTtJQUNsRSxNQUFNbWxDLGtCQUFrQnh2Qyx5REFBV0EsQ0FBQyxTQUFVZ0IsS0FBSztRQUNqRCxJQUFJQSxVQUFVLEtBQUssR0FBRztZQUNwQkEsUUFBUTtRQUNWO1FBQ0FvdUMsYUFBYS9rQyxPQUFPLEdBQUdySjtJQUN6QixHQUFHLEVBQUU7SUFDTCxNQUFNdXRDLG9CQUFvQnZ1Qyx5REFBV0EsQ0FBQyxJQUFNcXZDLGVBQWVobEMsT0FBTyxFQUFFLEVBQUU7SUFDdEUsTUFBTW9sQyxvQkFBb0J6dkMseURBQVdBLENBQUMsU0FBVWdCLEtBQUs7UUFDbkQsSUFBSUEsVUFBVSxLQUFLLEdBQUc7WUFDcEJBLFFBQVE7UUFDVjtRQUNBcXVDLGVBQWVobEMsT0FBTyxHQUFHcko7SUFDM0IsR0FBRyxFQUFFO0lBQ0w4dEMsY0FBYztRQUNabnFDO1FBQ0ErbkM7UUFDQTZCO0lBQ0Y7SUFDQSxNQUFNbUIsNkJBQTZCMXZDLHlEQUFXQSxDQUFDO1FBQzdDLElBQUl1WixxQkFBcUI7WUFDdkIrRyx3QkFBd0I7Z0JBQ3RCdEksV0FBV3VUO1lBQ2I7UUFDRjtJQUNGLEdBQUc7UUFBQ2hTO1FBQW1CK0c7S0FBd0I7SUFDL0M2ckIsc0JBQXNCO1FBQ3BCN21DO1FBQ0E5RDtRQUNBMlY7UUFDQTNJO1FBQ0FzOUI7UUFDQTMvQjtRQUNBd2dDO1FBQ0FEO0lBQ0Y7SUFDQSxNQUFNcnZCLGNBQWN0ZCxxREFBT0EsQ0FBQyxrQkFBTWhCLDBEQUFtQixDQUFDZ3dDLGNBQWM7WUFDbEVFLElBQUl0cUMsTUFBTTBZLFdBQVc7WUFDckJ0TixlQUFlcEwsTUFBTWdyQyx3QkFBd0I7UUFDL0MsR0FBR3BtQyxDQUFBQTtZQUNELElBQUksRUFDRnFrQyxPQUFPLEVBQ1B0bUIsSUFBSSxFQUNKMmxCLE9BQU8sRUFDUixHQUFHMWpDO1lBQ0oscUJBQU94SywwREFBbUIsQ0FBQ2d2QyxlQUFlO2dCQUN4QzF3QixhQUFhaUs7Z0JBQ2JzbUIsU0FBU0E7Z0JBQ1RwRyxVQUFVaUk7Z0JBQ1Z4QyxTQUFTQTtnQkFDVDlhLFdBQVdBO2dCQUNYb1YsaUJBQWlCbUk7WUFDbkI7UUFDRixJQUFJO1FBQUN2ZDtRQUFXdWQ7UUFBNEIvcUMsTUFBTTBZLFdBQVc7UUFBRTFZLE1BQU1nckMsd0JBQXdCO1FBQUVGO0tBQWtCO0lBQ2pILE1BQU1ob0IsV0FBVzFuQixxREFBT0EsQ0FBQyxJQUFPO1lBQzlCeW5DLFVBQVVnSTtZQUNWbnlCO1lBQ0F1eUIsZ0JBQWdCO2dCQUNkLHlCQUF5QnRxQztnQkFDekIsaUNBQWlDNnNCO1lBQ25DO1FBQ0YsSUFBSTtRQUFDQTtRQUFXN3NCO1FBQWErWDtRQUFhbXlCO0tBQWdCO0lBQzFELE1BQU0zRixrQkFBa0J5RixXQUFXQSxTQUFTcHRCLFFBQVEsQ0FBQ3JjLFdBQVcsR0FBRztJQUNuRSxNQUFNK2pDLG1CQUFtQjdwQyxxREFBT0EsQ0FBQyxJQUFPO1lBQ3RDdUY7WUFDQTlEO1lBQ0Fxb0M7UUFDRixJQUFJO1FBQUN2a0M7UUFBYXVrQztRQUFpQnJvQztLQUFLO0lBQ3hDLFNBQVNxdUM7UUFDUCxJQUFJLENBQUNQLFVBQVU7WUFDYixPQUFPO1FBQ1Q7UUFDQSxNQUFNLEVBQ0pwdEIsUUFBUSxFQUNSeGQsTUFBTSxFQUNQLEdBQUc0cUM7UUFDSixNQUFNUSxxQkFBTy93QywwREFBbUIsQ0FBQzRxQyxrQkFBa0I7WUFDakQ5akMsYUFBYXFjLFNBQVNyYyxXQUFXO1lBQ2pDZCxPQUFPbWQsU0FBU2hkLE1BQU0sQ0FBQ0gsS0FBSztZQUM1QjBoQyxTQUFTO1lBQ1RoeEIsV0FBVztZQUNYMG5CLHlCQUF5QjtZQUN6QjJFLDRCQUE0QjtRQUM5QixHQUFHLENBQUNpTyxtQkFBbUJDLG9CQUFzQnRyQyxPQUFPcXJDLG1CQUFtQkMsbUJBQW1COXRCO1FBQzFGLHFCQUFPNWlCLDZEQUFxQixDQUFDd3dDLE1BQU1QO0lBQ3JDO0lBQ0EscUJBQU94d0MsMERBQW1CLENBQUNvbkMsaUJBQWlCdG1DLFFBQVEsRUFBRTtRQUNwRG1CLE9BQU80b0M7SUFDVCxHQUFHaGxDLFNBQVM2aUIsVUFBVW1nQixXQUFXaUk7QUFDbkM7QUFDQSxJQUFJSyxjQUFjZjtBQUVsQixTQUFTZ0I7SUFDUCxDQUFDanJCLFNBQVN1TyxJQUFJLEdBQUc3eUIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxnQ0FBZ0NBLENBQWdCLEdBQUcsS0FBSztJQUNsSSxPQUFPMmhCLFNBQVN1TyxJQUFJO0FBQ3RCO0FBQ0EsTUFBTTJjLGVBQWU7SUFDbkJqNUIsTUFBTTtJQUNOM1YsTUFBTTtJQUNOZ04sV0FBVztJQUNYczlCLGdCQUFnQjtJQUNoQjMvQixrQkFBa0I7SUFDbEJ3Z0MseUJBQXlCO0lBQ3pCZ0MsYUFBYTtJQUNiWSxzQkFBc0JZO0FBQ3hCO0FBQ0EsTUFBTUUsK0JBQStCNUgsQ0FBQUE7SUFDbkMsSUFBSTZILGNBQWM7UUFDaEIsR0FBRzdILFFBQVE7SUFDYjtJQUNBLElBQUk4SDtJQUNKLElBQUtBLGtCQUFrQkgsYUFBYztRQUNuQyxJQUFJM0gsUUFBUSxDQUFDOEgsZUFBZSxLQUFLbHRCLFdBQVc7WUFDMUNpdEIsY0FBYztnQkFDWixHQUFHQSxXQUFXO2dCQUNkLENBQUNDLGVBQWUsRUFBRUgsWUFBWSxDQUFDRyxlQUFlO1lBQ2hEO1FBQ0Y7SUFDRjtJQUNBLE9BQU9EO0FBQ1Q7QUFDQSxNQUFNRSxpQkFBaUIsQ0FBQ2h2QyxNQUFNMlgsV0FBYTNYLFNBQVMyWCxTQUFTcFAsU0FBUyxDQUFDdkksSUFBSTtBQUMzRSxNQUFNaXZDLGVBQWUsQ0FBQ3QzQixVQUFVSCxhQUFlQSxXQUFXcE8sVUFBVSxDQUFDdU8sU0FBU2hPLFNBQVMsQ0FBQ3pGLEVBQUUsQ0FBQztBQUMzRixNQUFNZ3JDLHNCQUFzQjtJQUMxQixNQUFNQyxvQkFBb0I7UUFDeEJ0ekIsYUFBYTtRQUNic3lCLDBCQUEwQjtRQUMxQi9ILFVBQVU7WUFDUmdKLGdCQUFnQjtZQUNoQkMsa0JBQWtCO1lBQ2xCQyxzQkFBc0I7WUFDdEJDLG9CQUFvQjtRQUN0QjtRQUNBekIsVUFBVTtJQUNaO0lBQ0EsTUFBTTBCLHVCQUF1QjtRQUMzQixHQUFHTCxpQkFBaUI7UUFDcEJoQiwwQkFBMEI7SUFDNUI7SUFDQSxNQUFNc0IscUJBQXFCendDLHVEQUFVQSxDQUFDa0ssQ0FBQUEsYUFBZTtZQUNuRDdFLGFBQWE2RSxXQUFXaEYsRUFBRTtZQUMxQmxFLE1BQU1rSixXQUFXbEosSUFBSTtZQUNyQjBELFFBQVE7Z0JBQ05ILE9BQU8yRixXQUFXM0YsS0FBSztnQkFDdkJPLGFBQWFvRixXQUFXcEYsV0FBVztZQUNyQztRQUNGO0lBQ0EsTUFBTTRyQyxjQUFjMXdDLHVEQUFVQSxDQUFDLENBQUNrRixJQUFJK1AsV0FBVzA3QiwyQkFBMkJDLHlCQUF5Qmx2QixVQUFVeXNCO1FBQzNHLE1BQU05b0MsY0FBY3FjLFNBQVN4WCxVQUFVLENBQUNoRixFQUFFO1FBQzFDLE1BQU0yckMsU0FBU252QixTQUFTeFgsVUFBVSxDQUFDcEYsV0FBVyxLQUFLSTtRQUNuRCxJQUFJMnJDLFFBQVE7WUFDVixNQUFNL0IsV0FBV1gsY0FBYztnQkFDN0JqcUMsUUFBUWlxQztnQkFDUnpzQixVQUFVK3VCLG1CQUFtQi91QixTQUFTeFgsVUFBVTtZQUNsRCxJQUFJO1lBQ0osTUFBTWs5QixXQUFXO2dCQUNmZ0osZ0JBQWdCTztnQkFDaEJOLGtCQUFrQk0sNEJBQTRCdHJDLGNBQWM7Z0JBQzVEaXJDLHNCQUFzQmpyQztnQkFDdEJrckMsb0JBQW9CO1lBQ3RCO1lBQ0EsT0FBTztnQkFDTDF6QixhQUFhNkUsU0FBUzdFLFdBQVc7Z0JBQ2pDc3lCLDBCQUEwQjtnQkFDMUIvSDtnQkFDQTBIO1lBQ0Y7UUFDRjtRQUNBLElBQUksQ0FBQzc1QixXQUFXO1lBQ2QsT0FBT3U3QjtRQUNUO1FBQ0EsSUFBSSxDQUFDSSx5QkFBeUI7WUFDNUIsT0FBT1Q7UUFDVDtRQUNBLE1BQU0vSSxXQUFXO1lBQ2ZnSixnQkFBZ0JPO1lBQ2hCTixrQkFBa0JockM7WUFDbEJpckMsc0JBQXNCO1lBQ3RCQyxvQkFBb0I7UUFDdEI7UUFDQSxPQUFPO1lBQ0wxekIsYUFBYTZFLFNBQVM3RSxXQUFXO1lBQ2pDc3lCLDBCQUEwQjtZQUMxQi9IO1lBQ0EwSCxVQUFVO1FBQ1o7SUFDRjtJQUNBLE1BQU16YyxXQUFXLENBQUMvWixPQUFPMnZCO1FBQ3ZCLE1BQU02SSwyQkFBMkJqQiw2QkFBNkI1SDtRQUM5RCxNQUFNL2lDLEtBQUs0ckMseUJBQXlCaHNDLFdBQVc7UUFDL0MsTUFBTTlELE9BQU84dkMseUJBQXlCOXZDLElBQUk7UUFDMUMsTUFBTWlVLFlBQVksQ0FBQzY3Qix5QkFBeUJ4RixjQUFjO1FBQzFELE1BQU02QyxjQUFjMkMseUJBQXlCM0MsV0FBVztRQUN4RCxJQUFJMXFDLFdBQVc2VSxRQUFRO1lBQ3JCLE1BQU1LLFdBQVdMLE1BQU1LLFFBQVE7WUFDL0IsSUFBSSxDQUFDcTNCLGVBQWVodkMsTUFBTTJYLFdBQVc7Z0JBQ25DLE9BQU82M0I7WUFDVDtZQUNBLE1BQU05dUIsV0FBV3V1QixhQUFhdDNCLFVBQVVMLE1BQU1FLFVBQVU7WUFDeEQsTUFBTTQzQixpQkFBaUJqNEIsa0JBQWtCRyxNQUFNdE4sTUFBTSxNQUFNOUY7WUFDM0QsT0FBT3dyQyxZQUFZeHJDLElBQUkrUCxXQUFXbTdCLGdCQUFnQkEsZ0JBQWdCMXVCLFVBQVV5c0I7UUFDOUU7UUFDQSxJQUFJNzFCLE1BQU1VLEtBQUssS0FBSyxrQkFBa0I7WUFDcEMsTUFBTXdGLFlBQVlsRyxNQUFNa0csU0FBUztZQUNqQyxJQUFJLENBQUN3eEIsZUFBZWh2QyxNQUFNd2QsVUFBVTdGLFFBQVEsR0FBRztnQkFDN0MsT0FBTzYzQjtZQUNUO1lBQ0EsTUFBTTl1QixXQUFXdXVCLGFBQWF6eEIsVUFBVTdGLFFBQVEsRUFBRUwsTUFBTUUsVUFBVTtZQUNsRSxPQUFPazRCLFlBQVl4ckMsSUFBSStQLFdBQVdzeUIsNEJBQTRCL29CLFVBQVU3WSxNQUFNLE1BQU1ULElBQUlpVCxrQkFBa0JxRyxVQUFVeFQsTUFBTSxNQUFNOUYsSUFBSXdjLFVBQVV5c0I7UUFDaEo7UUFDQSxJQUFJNzFCLE1BQU1VLEtBQUssS0FBSyxVQUFVVixNQUFNa0csU0FBUyxJQUFJLENBQUNsRyxNQUFNbUcsV0FBVyxFQUFFO1lBQ25FLE1BQU1ELFlBQVlsRyxNQUFNa0csU0FBUztZQUNqQyxJQUFJLENBQUN3eEIsZUFBZWh2QyxNQUFNd2QsVUFBVTdGLFFBQVEsR0FBRztnQkFDN0MsT0FBTzYzQjtZQUNUO1lBQ0EsTUFBTTF5QixVQUFVM0Ysa0JBQWtCcUcsVUFBVXhULE1BQU0sTUFBTTlGO1lBQ3hELE1BQU02ckMsZUFBZWpnQyxRQUFRME4sVUFBVXhULE1BQU0sQ0FBQ0MsRUFBRSxJQUFJdVQsVUFBVXhULE1BQU0sQ0FBQ0MsRUFBRSxDQUFDakssSUFBSSxLQUFLO1lBQ2pGLE1BQU02dkMsU0FBU3J5QixVQUFVN0YsUUFBUSxDQUFDcFAsU0FBUyxDQUFDckUsRUFBRSxLQUFLQTtZQUNuRCxJQUFJNFksU0FBUztnQkFDWCxPQUFPaXpCLGVBQWVaLG9CQUFvQks7WUFDNUM7WUFDQSxJQUFJSyxRQUFRO2dCQUNWLE9BQU9WO1lBQ1Q7WUFDQSxPQUFPSztRQUNUO1FBQ0EsT0FBT0E7SUFDVDtJQUNBLE9BQU9uZTtBQUNUO0FBQ0EsTUFBTTJlLHFCQUFxQjtJQUN6Qmx4Qix5QkFBeUJBO0FBQzNCO0FBQ0EsTUFBTW14QixxQkFBcUIzeEMsb0RBQU9BLENBQUM0d0MscUJBQXFCYyxvQkFBb0IsQ0FBQ0UsWUFBWUMsZUFBZWxKO0lBQ3RHLE9BQU87UUFDTCxHQUFHNEgsNkJBQTZCNUgsU0FBUztRQUN6QyxHQUFHaUosVUFBVTtRQUNiLEdBQUdDLGFBQWE7SUFDbEI7QUFDRixHQUFHO0lBQ0RyZixTQUFTaUY7SUFDVGtTLG9CQUFvQjNCO0FBQ3RCLEdBQUdvSTtBQUNILElBQUkwQix1QkFBdUJIO0FBRXdJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhaW5pbmctaHViLy4vbm9kZV9tb2R1bGVzL0BoZWxsby1wYW5nZWEvZG5kL2Rpc3QvZG5kLmVzbS5qcz9jOTk3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0JDEsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSwgeyBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgY3JlYXRlU3RvcmUgYXMgY3JlYXRlU3RvcmUkMSwgYXBwbHlNaWRkbGV3YXJlLCBjb21wb3NlLCBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBQcm92aWRlciwgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IHVzZU1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAndXNlLW1lbW8tb25lJztcbmltcG9ydCB7IGdldFJlY3QsIGV4cGFuZCwgb2Zmc2V0LCB3aXRoU2Nyb2xsLCBjYWxjdWxhdGVCb3gsIGdldEJveCwgY3JlYXRlQm94IH0gZnJvbSAnY3NzLWJveC1tb2RlbCc7XG5pbXBvcnQgbWVtb2l6ZU9uZSBmcm9tICdtZW1vaXplLW9uZSc7XG5pbXBvcnQgcmFmU2NoZCBmcm9tICdyYWYtc2NoZCc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5cbmNvbnN0IGlzUHJvZHVjdGlvbiQxID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbmNvbnN0IHNwYWNlc0FuZFRhYnMgPSAvWyBcXHRdezIsfS9nO1xuY29uc3QgbGluZVN0YXJ0V2l0aFNwYWNlcyA9IC9eWyBcXHRdKi9nbTtcbmNvbnN0IGNsZWFuJDIgPSB2YWx1ZSA9PiB2YWx1ZS5yZXBsYWNlKHNwYWNlc0FuZFRhYnMsICcgJykucmVwbGFjZShsaW5lU3RhcnRXaXRoU3BhY2VzLCAnJykudHJpbSgpO1xuY29uc3QgZ2V0RGV2TWVzc2FnZSA9IG1lc3NhZ2UgPT4gY2xlYW4kMihgXG4gICVjQGhlbGxvLXBhbmdlYS9kbmRcblxuICAlYyR7Y2xlYW4kMihtZXNzYWdlKX1cblxuICAlY/CfkbfigI0gVGhpcyBpcyBhIGRldmVsb3BtZW50IG9ubHkgbWVzc2FnZS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLlxuYCk7XG5jb25zdCBnZXRGb3JtYXR0ZWRNZXNzYWdlID0gbWVzc2FnZSA9PiBbZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSwgJ2NvbG9yOiAjMDBDNTg0OyBmb250LXNpemU6IDEuMmVtOyBmb250LXdlaWdodDogYm9sZDsnLCAnbGluZS1oZWlnaHQ6IDEuNScsICdjb2xvcjogIzcyMzg3NDsnXTtcbmNvbnN0IGlzRGlzYWJsZWRGbGFnID0gJ19fQGhlbGxvLXBhbmdlYS9kbmQtZGlzYWJsZS1kZXYtd2FybmluZ3MnO1xuZnVuY3Rpb24gbG9nKHR5cGUsIG1lc3NhZ2UpIHtcbiAgaWYgKGlzUHJvZHVjdGlvbiQxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3dbaXNEaXNhYmxlZEZsYWddKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGVbdHlwZV0oLi4uZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG59XG5jb25zdCB3YXJuaW5nID0gbG9nLmJpbmQobnVsbCwgJ3dhcm4nKTtcbmNvbnN0IGVycm9yID0gbG9nLmJpbmQobnVsbCwgJ2Vycm9yJyk7XG5cbmZ1bmN0aW9uIG5vb3AkMigpIHt9XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMoc2hhcmVkLCBmcm9tQmluZGluZykge1xuICByZXR1cm4ge1xuICAgIC4uLnNoYXJlZCxcbiAgICAuLi5mcm9tQmluZGluZ1xuICB9O1xufVxuZnVuY3Rpb24gYmluZEV2ZW50cyhlbCwgYmluZGluZ3MsIHNoYXJlZE9wdGlvbnMpIHtcbiAgY29uc3QgdW5iaW5kaW5ncyA9IGJpbmRpbmdzLm1hcChiaW5kaW5nID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0T3B0aW9ucyhzaGFyZWRPcHRpb25zLCBiaW5kaW5nLm9wdGlvbnMpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoYmluZGluZy5ldmVudE5hbWUsIGJpbmRpbmcuZm4sIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGJpbmRpbmcuZXZlbnROYW1lLCBiaW5kaW5nLmZuLCBvcHRpb25zKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVuYmluZEFsbCgpIHtcbiAgICB1bmJpbmRpbmdzLmZvckVhY2godW5iaW5kID0+IHtcbiAgICAgIHVuYmluZCgpO1xuICAgIH0pO1xuICB9O1xufVxuXG5jb25zdCBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuY29uc3QgcHJlZml4JDEgPSAnSW52YXJpYW50IGZhaWxlZCc7XG5jbGFzcyBSYmRJbnZhcmlhbnQgZXh0ZW5kcyBFcnJvciB7fVxuUmJkSW52YXJpYW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5tZXNzYWdlO1xufTtcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKGNvbmRpdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChwcmVmaXgkMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChgJHtwcmVmaXgkMX06ICR7bWVzc2FnZSB8fCAnJ31gKTtcbiAgfVxufVxuXG5jbGFzcyBFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy51bmJpbmQgPSBub29wJDI7XG4gICAgdGhpcy5vbldpbmRvd0Vycm9yID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5nZXRDYWxsYmFja3MoKTtcbiAgICAgIGlmIChjYWxsYmFja3MuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIGNhbGxiYWNrcy50cnlBYm9ydCgpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgICAgQW4gZXJyb3Igd2FzIGNhdWdodCBieSBvdXIgd2luZG93ICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgd2hpbGUgYSBkcmFnIHdhcyBvY2N1cnJpbmcuXG4gICAgICAgIFRoZSBhY3RpdmUgZHJhZyBoYXMgYmVlbiBhYm9ydGVkLlxuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnIgPSBldmVudC5lcnJvcjtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBSYmRJbnZhcmlhbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBlcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0Q2FsbGJhY2tzID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIEFwcENhbGxiYWNrcyBpbiA8RXJyb3JCb3VuZGFyeS8+Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jYWxsYmFja3M7XG4gICAgfTtcbiAgICB0aGlzLnNldENhbGxiYWNrcyA9IGNhbGxiYWNrcyA9PiB7XG4gICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFt7XG4gICAgICBldmVudE5hbWU6ICdlcnJvcicsXG4gICAgICBmbjogdGhpcy5vbldpbmRvd0Vycm9yXG4gICAgfV0pO1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBSYmRJbnZhcmlhbnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoe30pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy51bmJpbmQoKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5zZXRDYWxsYmFja3MpO1xuICB9XG59XG5cbmNvbnN0IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyA9IGBcbiAgUHJlc3Mgc3BhY2UgYmFyIHRvIHN0YXJ0IGEgZHJhZy5cbiAgV2hlbiBkcmFnZ2luZyB5b3UgY2FuIHVzZSB0aGUgYXJyb3cga2V5cyB0byBtb3ZlIHRoZSBpdGVtIGFyb3VuZCBhbmQgZXNjYXBlIHRvIGNhbmNlbC5cbiAgU29tZSBzY3JlZW4gcmVhZGVycyBtYXkgcmVxdWlyZSB5b3UgdG8gYmUgaW4gZm9jdXMgbW9kZSBvciB0byB1c2UgeW91ciBwYXNzIHRocm91Z2gga2V5XG5gO1xuY29uc3QgcG9zaXRpb24gPSBpbmRleCA9PiBpbmRleCArIDE7XG5jb25zdCBvbkRyYWdTdGFydCA9IHN0YXJ0ID0+IGBcbiAgWW91IGhhdmUgbGlmdGVkIGFuIGl0ZW0gaW4gcG9zaXRpb24gJHtwb3NpdGlvbihzdGFydC5zb3VyY2UuaW5kZXgpfVxuYDtcbmNvbnN0IHdpdGhMb2NhdGlvbiA9IChzb3VyY2UsIGRlc3RpbmF0aW9uKSA9PiB7XG4gIGNvbnN0IGlzSW5Ib21lTGlzdCA9IHNvdXJjZS5kcm9wcGFibGVJZCA9PT0gZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBwb3NpdGlvbihzb3VyY2UuaW5kZXgpO1xuICBjb25zdCBlbmRQb3NpdGlvbiA9IHBvc2l0aW9uKGRlc3RpbmF0aW9uLmluZGV4KTtcbiAgaWYgKGlzSW5Ib21lTGlzdCkge1xuICAgIHJldHVybiBgXG4gICAgICBZb3UgaGF2ZSBtb3ZlZCB0aGUgaXRlbSBmcm9tIHBvc2l0aW9uICR7c3RhcnRQb3NpdGlvbn1cbiAgICAgIHRvIHBvc2l0aW9uICR7ZW5kUG9zaXRpb259XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgIFlvdSBoYXZlIG1vdmVkIHRoZSBpdGVtIGZyb20gcG9zaXRpb24gJHtzdGFydFBvc2l0aW9ufVxuICAgIGluIGxpc3QgJHtzb3VyY2UuZHJvcHBhYmxlSWR9XG4gICAgdG8gbGlzdCAke2Rlc3RpbmF0aW9uLmRyb3BwYWJsZUlkfVxuICAgIGluIHBvc2l0aW9uICR7ZW5kUG9zaXRpb259XG4gIGA7XG59O1xuY29uc3Qgd2l0aENvbWJpbmUgPSAoaWQsIHNvdXJjZSwgY29tYmluZSkgPT4ge1xuICBjb25zdCBpbkhvbWVMaXN0ID0gc291cmNlLmRyb3BwYWJsZUlkID09PSBjb21iaW5lLmRyb3BwYWJsZUlkO1xuICBpZiAoaW5Ib21lTGlzdCkge1xuICAgIHJldHVybiBgXG4gICAgICBUaGUgaXRlbSAke2lkfVxuICAgICAgaGFzIGJlZW4gY29tYmluZWQgd2l0aCAke2NvbWJpbmUuZHJhZ2dhYmxlSWR9YDtcbiAgfVxuICByZXR1cm4gYFxuICAgICAgVGhlIGl0ZW0gJHtpZH1cbiAgICAgIGluIGxpc3QgJHtzb3VyY2UuZHJvcHBhYmxlSWR9XG4gICAgICBoYXMgYmVlbiBjb21iaW5lZCB3aXRoICR7Y29tYmluZS5kcmFnZ2FibGVJZH1cbiAgICAgIGluIGxpc3QgJHtjb21iaW5lLmRyb3BwYWJsZUlkfVxuICAgIGA7XG59O1xuY29uc3Qgb25EcmFnVXBkYXRlID0gdXBkYXRlID0+IHtcbiAgY29uc3QgbG9jYXRpb24gPSB1cGRhdGUuZGVzdGluYXRpb247XG4gIGlmIChsb2NhdGlvbikge1xuICAgIHJldHVybiB3aXRoTG9jYXRpb24odXBkYXRlLnNvdXJjZSwgbG9jYXRpb24pO1xuICB9XG4gIGNvbnN0IGNvbWJpbmUgPSB1cGRhdGUuY29tYmluZTtcbiAgaWYgKGNvbWJpbmUpIHtcbiAgICByZXR1cm4gd2l0aENvbWJpbmUodXBkYXRlLmRyYWdnYWJsZUlkLCB1cGRhdGUuc291cmNlLCBjb21iaW5lKTtcbiAgfVxuICByZXR1cm4gJ1lvdSBhcmUgb3ZlciBhbiBhcmVhIHRoYXQgY2Fubm90IGJlIGRyb3BwZWQgb24nO1xufTtcbmNvbnN0IHJldHVybmVkVG9TdGFydCA9IHNvdXJjZSA9PiBgXG4gIFRoZSBpdGVtIGhhcyByZXR1cm5lZCB0byBpdHMgc3RhcnRpbmcgcG9zaXRpb25cbiAgb2YgJHtwb3NpdGlvbihzb3VyY2UuaW5kZXgpfVxuYDtcbmNvbnN0IG9uRHJhZ0VuZCA9IHJlc3VsdCA9PiB7XG4gIGlmIChyZXN1bHQucmVhc29uID09PSAnQ0FOQ0VMJykge1xuICAgIHJldHVybiBgXG4gICAgICBNb3ZlbWVudCBjYW5jZWxsZWQuXG4gICAgICAke3JldHVybmVkVG9TdGFydChyZXN1bHQuc291cmNlKX1cbiAgICBgO1xuICB9XG4gIGNvbnN0IGxvY2F0aW9uID0gcmVzdWx0LmRlc3RpbmF0aW9uO1xuICBjb25zdCBjb21iaW5lID0gcmVzdWx0LmNvbWJpbmU7XG4gIGlmIChsb2NhdGlvbikge1xuICAgIHJldHVybiBgXG4gICAgICBZb3UgaGF2ZSBkcm9wcGVkIHRoZSBpdGVtLlxuICAgICAgJHt3aXRoTG9jYXRpb24ocmVzdWx0LnNvdXJjZSwgbG9jYXRpb24pfVxuICAgIGA7XG4gIH1cbiAgaWYgKGNvbWJpbmUpIHtcbiAgICByZXR1cm4gYFxuICAgICAgWW91IGhhdmUgZHJvcHBlZCB0aGUgaXRlbS5cbiAgICAgICR7d2l0aENvbWJpbmUocmVzdWx0LmRyYWdnYWJsZUlkLCByZXN1bHQuc291cmNlLCBjb21iaW5lKX1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgVGhlIGl0ZW0gaGFzIGJlZW4gZHJvcHBlZCB3aGlsZSBub3Qgb3ZlciBhIGRyb3AgYXJlYS5cbiAgICAke3JldHVybmVkVG9TdGFydChyZXN1bHQuc291cmNlKX1cbiAgYDtcbn07XG5jb25zdCBwcmVzZXQgPSB7XG4gIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyxcbiAgb25EcmFnU3RhcnQsXG4gIG9uRHJhZ1VwZGF0ZSxcbiAgb25EcmFnRW5kXG59O1xudmFyIHByZXNldCQxID0gcHJlc2V0O1xuXG5jb25zdCBvcmlnaW4gPSB7XG4gIHg6IDAsXG4gIHk6IDBcbn07XG5jb25zdCBhZGQgPSAocG9pbnQxLCBwb2ludDIpID0+ICh7XG4gIHg6IHBvaW50MS54ICsgcG9pbnQyLngsXG4gIHk6IHBvaW50MS55ICsgcG9pbnQyLnlcbn0pO1xuY29uc3Qgc3VidHJhY3QgPSAocG9pbnQxLCBwb2ludDIpID0+ICh7XG4gIHg6IHBvaW50MS54IC0gcG9pbnQyLngsXG4gIHk6IHBvaW50MS55IC0gcG9pbnQyLnlcbn0pO1xuY29uc3QgaXNFcXVhbCQxID0gKHBvaW50MSwgcG9pbnQyKSA9PiBwb2ludDEueCA9PT0gcG9pbnQyLnggJiYgcG9pbnQxLnkgPT09IHBvaW50Mi55O1xuY29uc3QgbmVnYXRlID0gcG9pbnQgPT4gKHtcbiAgeDogcG9pbnQueCAhPT0gMCA/IC1wb2ludC54IDogMCxcbiAgeTogcG9pbnQueSAhPT0gMCA/IC1wb2ludC55IDogMFxufSk7XG5jb25zdCBwYXRjaCA9IGZ1bmN0aW9uIChsaW5lLCB2YWx1ZSwgb3RoZXJWYWx1ZSkge1xuICBpZiAob3RoZXJWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgb3RoZXJWYWx1ZSA9IDA7XG4gIH1cbiAgaWYgKGxpbmUgPT09ICd4Jykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB2YWx1ZSxcbiAgICAgIHk6IG90aGVyVmFsdWVcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogb3RoZXJWYWx1ZSxcbiAgICB5OiB2YWx1ZVxuICB9O1xufTtcbmNvbnN0IGRpc3RhbmNlID0gKHBvaW50MSwgcG9pbnQyKSA9PiBNYXRoLnNxcnQoKHBvaW50Mi54IC0gcG9pbnQxLngpICoqIDIgKyAocG9pbnQyLnkgLSBwb2ludDEueSkgKiogMik7XG5jb25zdCBjbG9zZXN0JDEgPSAodGFyZ2V0LCBwb2ludHMpID0+IE1hdGgubWluKC4uLnBvaW50cy5tYXAocG9pbnQgPT4gZGlzdGFuY2UodGFyZ2V0LCBwb2ludCkpKTtcbmNvbnN0IGFwcGx5ID0gZm4gPT4gcG9pbnQgPT4gKHtcbiAgeDogZm4ocG9pbnQueCksXG4gIHk6IGZuKHBvaW50LnkpXG59KTtcblxudmFyIGV4ZWN1dGVDbGlwID0gKChmcmFtZSwgc3ViamVjdCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBnZXRSZWN0KHtcbiAgICB0b3A6IE1hdGgubWF4KHN1YmplY3QudG9wLCBmcmFtZS50b3ApLFxuICAgIHJpZ2h0OiBNYXRoLm1pbihzdWJqZWN0LnJpZ2h0LCBmcmFtZS5yaWdodCksXG4gICAgYm90dG9tOiBNYXRoLm1pbihzdWJqZWN0LmJvdHRvbSwgZnJhbWUuYm90dG9tKSxcbiAgICBsZWZ0OiBNYXRoLm1heChzdWJqZWN0LmxlZnQsIGZyYW1lLmxlZnQpXG4gIH0pO1xuICBpZiAocmVzdWx0LndpZHRoIDw9IDAgfHwgcmVzdWx0LmhlaWdodCA8PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5jb25zdCBvZmZzZXRCeVBvc2l0aW9uID0gKHNwYWNpbmcsIHBvaW50KSA9PiAoe1xuICB0b3A6IHNwYWNpbmcudG9wICsgcG9pbnQueSxcbiAgbGVmdDogc3BhY2luZy5sZWZ0ICsgcG9pbnQueCxcbiAgYm90dG9tOiBzcGFjaW5nLmJvdHRvbSArIHBvaW50LnksXG4gIHJpZ2h0OiBzcGFjaW5nLnJpZ2h0ICsgcG9pbnQueFxufSk7XG5jb25zdCBnZXRDb3JuZXJzID0gc3BhY2luZyA9PiBbe1xuICB4OiBzcGFjaW5nLmxlZnQsXG4gIHk6IHNwYWNpbmcudG9wXG59LCB7XG4gIHg6IHNwYWNpbmcucmlnaHQsXG4gIHk6IHNwYWNpbmcudG9wXG59LCB7XG4gIHg6IHNwYWNpbmcubGVmdCxcbiAgeTogc3BhY2luZy5ib3R0b21cbn0sIHtcbiAgeDogc3BhY2luZy5yaWdodCxcbiAgeTogc3BhY2luZy5ib3R0b21cbn1dO1xuY29uc3Qgbm9TcGFjaW5nID0ge1xuICB0b3A6IDAsXG4gIHJpZ2h0OiAwLFxuICBib3R0b206IDAsXG4gIGxlZnQ6IDBcbn07XG5cbmNvbnN0IHNjcm9sbCQxID0gKHRhcmdldCwgZnJhbWUpID0+IHtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG9mZnNldEJ5UG9zaXRpb24odGFyZ2V0LCBmcmFtZS5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQpO1xufTtcbmNvbnN0IGluY3JlYXNlID0gKHRhcmdldCwgYXhpcywgd2l0aFBsYWNlaG9sZGVyKSA9PiB7XG4gIGlmICh3aXRoUGxhY2Vob2xkZXIgJiYgd2l0aFBsYWNlaG9sZGVyLmluY3JlYXNlZEJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIFtheGlzLmVuZF06IHRhcmdldFtheGlzLmVuZF0gKyB3aXRoUGxhY2Vob2xkZXIuaW5jcmVhc2VkQnlbYXhpcy5saW5lXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5jb25zdCBjbGlwID0gKHRhcmdldCwgZnJhbWUpID0+IHtcbiAgaWYgKGZyYW1lICYmIGZyYW1lLnNob3VsZENsaXBTdWJqZWN0KSB7XG4gICAgcmV0dXJuIGV4ZWN1dGVDbGlwKGZyYW1lLnBhZ2VNYXJnaW5Cb3gsIHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGdldFJlY3QodGFyZ2V0KTtcbn07XG52YXIgZ2V0U3ViamVjdCA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBwYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcixcbiAgICBheGlzLFxuICAgIGZyYW1lXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzY3JvbGxlZCA9IHNjcm9sbCQxKHBhZ2UubWFyZ2luQm94LCBmcmFtZSk7XG4gIGNvbnN0IGluY3JlYXNlZCA9IGluY3JlYXNlKHNjcm9sbGVkLCBheGlzLCB3aXRoUGxhY2Vob2xkZXIpO1xuICBjb25zdCBjbGlwcGVkID0gY2xpcChpbmNyZWFzZWQsIGZyYW1lKTtcbiAgcmV0dXJuIHtcbiAgICBwYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcixcbiAgICBhY3RpdmU6IGNsaXBwZWRcbiAgfTtcbn0pO1xuXG52YXIgc2Nyb2xsRHJvcHBhYmxlID0gKChkcm9wcGFibGUsIG5ld1Njcm9sbCkgPT4ge1xuICAhZHJvcHBhYmxlLmZyYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGNvbnN0IHNjcm9sbGFibGUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGNvbnN0IHNjcm9sbERpZmYgPSBzdWJ0cmFjdChuZXdTY3JvbGwsIHNjcm9sbGFibGUuc2Nyb2xsLmluaXRpYWwpO1xuICBjb25zdCBzY3JvbGxEaXNwbGFjZW1lbnQgPSBuZWdhdGUoc2Nyb2xsRGlmZik7XG4gIGNvbnN0IGZyYW1lID0ge1xuICAgIC4uLnNjcm9sbGFibGUsXG4gICAgc2Nyb2xsOiB7XG4gICAgICBpbml0aWFsOiBzY3JvbGxhYmxlLnNjcm9sbC5pbml0aWFsLFxuICAgICAgY3VycmVudDogbmV3U2Nyb2xsLFxuICAgICAgZGlmZjoge1xuICAgICAgICB2YWx1ZTogc2Nyb2xsRGlmZixcbiAgICAgICAgZGlzcGxhY2VtZW50OiBzY3JvbGxEaXNwbGFjZW1lbnRcbiAgICAgIH0sXG4gICAgICBtYXg6IHNjcm9sbGFibGUuc2Nyb2xsLm1heFxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIsXG4gICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgZnJhbWVcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAuLi5kcm9wcGFibGUsXG4gICAgZnJhbWUsXG4gICAgc3ViamVjdFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmNvbnN0IHRvRHJvcHBhYmxlTWFwID0gbWVtb2l6ZU9uZShkcm9wcGFibGVzID0+IGRyb3BwYWJsZXMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICBwcmV2aW91c1tjdXJyZW50LmRlc2NyaXB0b3IuaWRdID0gY3VycmVudDtcbiAgcmV0dXJuIHByZXZpb3VzO1xufSwge30pKTtcbmNvbnN0IHRvRHJhZ2dhYmxlTWFwID0gbWVtb2l6ZU9uZShkcmFnZ2FibGVzID0+IGRyYWdnYWJsZXMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICBwcmV2aW91c1tjdXJyZW50LmRlc2NyaXB0b3IuaWRdID0gY3VycmVudDtcbiAgcmV0dXJuIHByZXZpb3VzO1xufSwge30pKTtcbmNvbnN0IHRvRHJvcHBhYmxlTGlzdCA9IG1lbW9pemVPbmUoZHJvcHBhYmxlcyA9PiBPYmplY3QudmFsdWVzKGRyb3BwYWJsZXMpKTtcbmNvbnN0IHRvRHJhZ2dhYmxlTGlzdCA9IG1lbW9pemVPbmUoZHJhZ2dhYmxlcyA9PiBPYmplY3QudmFsdWVzKGRyYWdnYWJsZXMpKTtcblxudmFyIGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUgPSBtZW1vaXplT25lKChkcm9wcGFibGVJZCwgZHJhZ2dhYmxlcykgPT4ge1xuICBjb25zdCByZXN1bHQgPSB0b0RyYWdnYWJsZUxpc3QoZHJhZ2dhYmxlcykuZmlsdGVyKGRyYWdnYWJsZSA9PiBkcm9wcGFibGVJZCA9PT0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpLnNvcnQoKGEsIGIpID0+IGEuZGVzY3JpcHRvci5pbmRleCAtIGIuZGVzY3JpcHRvci5pbmRleCk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZnVuY3Rpb24gdHJ5R2V0RGVzdGluYXRpb24oaW1wYWN0KSB7XG4gIGlmIChpbXBhY3QuYXQgJiYgaW1wYWN0LmF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiBpbXBhY3QuYXQuZGVzdGluYXRpb247XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0cnlHZXRDb21iaW5lKGltcGFjdCkge1xuICBpZiAoaW1wYWN0LmF0ICYmIGltcGFjdC5hdC50eXBlID09PSAnQ09NQklORScpIHtcbiAgICByZXR1cm4gaW1wYWN0LmF0LmNvbWJpbmU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdCA9IG1lbW9pemVPbmUoKHJlbW92ZSwgbGlzdCkgPT4gbGlzdC5maWx0ZXIoaXRlbSA9PiBpdGVtLmRlc2NyaXB0b3IuaWQgIT09IHJlbW92ZS5kZXNjcmlwdG9yLmlkKSk7XG5cbnZhciBtb3ZlVG9OZXh0Q29tYmluZSA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0XG4gIH0gPSBfcmVmO1xuICBpZiAoIWRlc3RpbmF0aW9uLmlzQ29tYmluZUVuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsb2NhdGlvbiA9IHRyeUdldERlc3RpbmF0aW9uKHByZXZpb3VzSW1wYWN0KTtcbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldEltcGFjdCh0YXJnZXQpIHtcbiAgICBjb25zdCBhdCA9IHtcbiAgICAgIHR5cGU6ICdDT01CSU5FJyxcbiAgICAgIGNvbWJpbmU6IHtcbiAgICAgICAgZHJhZ2dhYmxlSWQ6IHRhcmdldCxcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWRcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wcmV2aW91c0ltcGFjdCxcbiAgICAgIGF0XG4gICAgfTtcbiAgfVxuICBjb25zdCBhbGwgPSBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQuYWxsO1xuICBjb25zdCBjbG9zZXN0SWQgPSBhbGwubGVuZ3RoID8gYWxsWzBdIDogbnVsbDtcbiAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgIHJldHVybiBjbG9zZXN0SWQgPyBnZXRJbXBhY3QoY2xvc2VzdElkKSA6IG51bGw7XG4gIH1cbiAgY29uc3Qgd2l0aG91dERyYWdnYWJsZSA9IHJlbW92ZURyYWdnYWJsZUZyb21MaXN0KGRyYWdnYWJsZSwgaW5zaWRlRGVzdGluYXRpb24pO1xuICBpZiAoIWNsb3Nlc3RJZCkge1xuICAgIGlmICghd2l0aG91dERyYWdnYWJsZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gd2l0aG91dERyYWdnYWJsZVt3aXRob3V0RHJhZ2dhYmxlLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBnZXRJbXBhY3QobGFzdC5kZXNjcmlwdG9yLmlkKTtcbiAgfVxuICBjb25zdCBpbmRleE9mQ2xvc2VzdCA9IHdpdGhvdXREcmFnZ2FibGUuZmluZEluZGV4KGQgPT4gZC5kZXNjcmlwdG9yLmlkID09PSBjbG9zZXN0SWQpO1xuICAhKGluZGV4T2ZDbG9zZXN0ICE9PSAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBkaXNwbGFjZWQgaXRlbSBpbiBzZXQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGNvbnN0IHByb3Bvc2VkSW5kZXggPSBpbmRleE9mQ2xvc2VzdCAtIDE7XG4gIGlmIChwcm9wb3NlZEluZGV4IDwgMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGJlZm9yZSA9IHdpdGhvdXREcmFnZ2FibGVbcHJvcG9zZWRJbmRleF07XG4gIHJldHVybiBnZXRJbXBhY3QoYmVmb3JlLmRlc2NyaXB0b3IuaWQpO1xufSk7XG5cbnZhciBpc0hvbWVPZiA9ICgoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbikgPT4gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQgPT09IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQpO1xuXG5jb25zdCBub0Rpc3BsYWNlZEJ5ID0ge1xuICBwb2ludDogb3JpZ2luLFxuICB2YWx1ZTogMFxufTtcbmNvbnN0IGVtcHR5R3JvdXBzID0ge1xuICBpbnZpc2libGU6IHt9LFxuICB2aXNpYmxlOiB7fSxcbiAgYWxsOiBbXVxufTtcbmNvbnN0IG5vSW1wYWN0ID0ge1xuICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzLFxuICBkaXNwbGFjZWRCeTogbm9EaXNwbGFjZWRCeSxcbiAgYXQ6IG51bGxcbn07XG52YXIgbm9JbXBhY3QkMSA9IG5vSW1wYWN0O1xuXG52YXIgaXNXaXRoaW4gPSAoKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpID0+IHZhbHVlID0+IGxvd2VyQm91bmQgPD0gdmFsdWUgJiYgdmFsdWUgPD0gdXBwZXJCb3VuZCk7XG5cbnZhciBpc1BhcnRpYWxseVZpc2libGVUaHJvdWdoRnJhbWUgPSAoZnJhbWUgPT4ge1xuICBjb25zdCBpc1dpdGhpblZlcnRpY2FsID0gaXNXaXRoaW4oZnJhbWUudG9wLCBmcmFtZS5ib3R0b20pO1xuICBjb25zdCBpc1dpdGhpbkhvcml6b250YWwgPSBpc1dpdGhpbihmcmFtZS5sZWZ0LCBmcmFtZS5yaWdodCk7XG4gIHJldHVybiBzdWJqZWN0ID0+IHtcbiAgICBjb25zdCBpc0NvbnRhaW5lZCA9IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApICYmIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgICBpZiAoaXNDb250YWluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpc1BhcnRpYWxseVZpc2libGVWZXJ0aWNhbGx5ID0gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgfHwgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSk7XG4gICAgY29uc3QgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5ID0gaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgfHwgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICAgIGNvbnN0IGlzUGFydGlhbGx5Q29udGFpbmVkID0gaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseSAmJiBpc1BhcnRpYWxseVZpc2libGVIb3Jpem9udGFsbHk7XG4gICAgaWYgKGlzUGFydGlhbGx5Q29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaXNCaWdnZXJWZXJ0aWNhbGx5ID0gc3ViamVjdC50b3AgPCBmcmFtZS50b3AgJiYgc3ViamVjdC5ib3R0b20gPiBmcmFtZS5ib3R0b207XG4gICAgY29uc3QgaXNCaWdnZXJIb3Jpem9udGFsbHkgPSBzdWJqZWN0LmxlZnQgPCBmcmFtZS5sZWZ0ICYmIHN1YmplY3QucmlnaHQgPiBmcmFtZS5yaWdodDtcbiAgICBjb25zdCBpc1RhcmdldEJpZ2dlclRoYW5GcmFtZSA9IGlzQmlnZ2VyVmVydGljYWxseSAmJiBpc0JpZ2dlckhvcml6b250YWxseTtcbiAgICBpZiAoaXNUYXJnZXRCaWdnZXJUaGFuRnJhbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpc1RhcmdldEJpZ2dlck9uT25lQXhpcyA9IGlzQmlnZ2VyVmVydGljYWxseSAmJiBpc1BhcnRpYWxseVZpc2libGVIb3Jpem9udGFsbHkgfHwgaXNCaWdnZXJIb3Jpem9udGFsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseTtcbiAgICByZXR1cm4gaXNUYXJnZXRCaWdnZXJPbk9uZUF4aXM7XG4gIH07XG59KTtcblxudmFyIGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWUgPSAoZnJhbWUgPT4ge1xuICBjb25zdCBpc1dpdGhpblZlcnRpY2FsID0gaXNXaXRoaW4oZnJhbWUudG9wLCBmcmFtZS5ib3R0b20pO1xuICBjb25zdCBpc1dpdGhpbkhvcml6b250YWwgPSBpc1dpdGhpbihmcmFtZS5sZWZ0LCBmcmFtZS5yaWdodCk7XG4gIHJldHVybiBzdWJqZWN0ID0+IHtcbiAgICBjb25zdCBpc0NvbnRhaW5lZCA9IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApICYmIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgICByZXR1cm4gaXNDb250YWluZWQ7XG4gIH07XG59KTtcblxuY29uc3QgdmVydGljYWwgPSB7XG4gIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgbGluZTogJ3knLFxuICBjcm9zc0F4aXNMaW5lOiAneCcsXG4gIHN0YXJ0OiAndG9wJyxcbiAgZW5kOiAnYm90dG9tJyxcbiAgc2l6ZTogJ2hlaWdodCcsXG4gIGNyb3NzQXhpc1N0YXJ0OiAnbGVmdCcsXG4gIGNyb3NzQXhpc0VuZDogJ3JpZ2h0JyxcbiAgY3Jvc3NBeGlzU2l6ZTogJ3dpZHRoJ1xufTtcbmNvbnN0IGhvcml6b250YWwgPSB7XG4gIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLFxuICBsaW5lOiAneCcsXG4gIGNyb3NzQXhpc0xpbmU6ICd5JyxcbiAgc3RhcnQ6ICdsZWZ0JyxcbiAgZW5kOiAncmlnaHQnLFxuICBzaXplOiAnd2lkdGgnLFxuICBjcm9zc0F4aXNTdGFydDogJ3RvcCcsXG4gIGNyb3NzQXhpc0VuZDogJ2JvdHRvbScsXG4gIGNyb3NzQXhpc1NpemU6ICdoZWlnaHQnXG59O1xuXG52YXIgaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZU9uQXhpcyA9IChheGlzID0+IGZyYW1lID0+IHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gc3ViamVjdCA9PiB7XG4gICAgaWYgKGF4aXMgPT09IHZlcnRpY2FsKSB7XG4gICAgICByZXR1cm4gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgJiYgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSk7XG4gICAgfVxuICAgIHJldHVybiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gIH07XG59KTtcblxuY29uc3QgZ2V0RHJvcHBhYmxlRGlzcGxhY2VkID0gKHRhcmdldCwgZGVzdGluYXRpb24pID0+IHtcbiAgY29uc3QgZGlzcGxhY2VtZW50ID0gZGVzdGluYXRpb24uZnJhbWUgPyBkZXN0aW5hdGlvbi5mcmFtZS5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQgOiBvcmlnaW47XG4gIHJldHVybiBvZmZzZXRCeVBvc2l0aW9uKHRhcmdldCwgZGlzcGxhY2VtZW50KTtcbn07XG5jb25zdCBpc1Zpc2libGVJbkRyb3BwYWJsZSA9ICh0YXJnZXQsIGRlc3RpbmF0aW9uLCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbikgPT4ge1xuICBpZiAoIWRlc3RpbmF0aW9uLnN1YmplY3QuYWN0aXZlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbihkZXN0aW5hdGlvbi5zdWJqZWN0LmFjdGl2ZSkodGFyZ2V0KTtcbn07XG5jb25zdCBpc1Zpc2libGVJblZpZXdwb3J0ID0gKHRhcmdldCwgdmlld3BvcnQsIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKSA9PiBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbih2aWV3cG9ydCkodGFyZ2V0KTtcbmNvbnN0IGlzVmlzaWJsZSQxID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgdGFyZ2V0OiB0b0JlRGlzcGxhY2VkLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0LFxuICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gICAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm5cbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGRpc3BsYWNlZFRhcmdldCA9IHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQgPyBnZXREcm9wcGFibGVEaXNwbGFjZWQodG9CZURpc3BsYWNlZCwgZGVzdGluYXRpb24pIDogdG9CZURpc3BsYWNlZDtcbiAgcmV0dXJuIGlzVmlzaWJsZUluRHJvcHBhYmxlKGRpc3BsYWNlZFRhcmdldCwgZGVzdGluYXRpb24sIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKSAmJiBpc1Zpc2libGVJblZpZXdwb3J0KGRpc3BsYWNlZFRhcmdldCwgdmlld3BvcnQsIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKTtcbn07XG5jb25zdCBpc1BhcnRpYWxseVZpc2libGUgPSBhcmdzID0+IGlzVmlzaWJsZSQxKHtcbiAgLi4uYXJncyxcbiAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm46IGlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZVxufSk7XG5jb25zdCBpc1RvdGFsbHlWaXNpYmxlID0gYXJncyA9PiBpc1Zpc2libGUkMSh7XG4gIC4uLmFyZ3MsXG4gIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuOiBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lXG59KTtcbmNvbnN0IGlzVG90YWxseVZpc2libGVPbkF4aXMgPSBhcmdzID0+IGlzVmlzaWJsZSQxKHtcbiAgLi4uYXJncyxcbiAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm46IGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVPbkF4aXMoYXJncy5kZXN0aW5hdGlvbi5heGlzKVxufSk7XG5cbmNvbnN0IGdldFNob3VsZEFuaW1hdGUgPSAoaWQsIGxhc3QsIGZvcmNlU2hvdWxkQW5pbWF0ZSkgPT4ge1xuICBpZiAodHlwZW9mIGZvcmNlU2hvdWxkQW5pbWF0ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGZvcmNlU2hvdWxkQW5pbWF0ZTtcbiAgfVxuICBpZiAoIWxhc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW52aXNpYmxlLFxuICAgIHZpc2libGVcbiAgfSA9IGxhc3Q7XG4gIGlmIChpbnZpc2libGVbaWRdKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHByZXZpb3VzID0gdmlzaWJsZVtpZF07XG4gIHJldHVybiBwcmV2aW91cyA/IHByZXZpb3VzLnNob3VsZEFuaW1hdGUgOiB0cnVlO1xufTtcbmZ1bmN0aW9uIGdldFRhcmdldChkcmFnZ2FibGUsIGRpc3BsYWNlZEJ5KSB7XG4gIGNvbnN0IG1hcmdpbkJveCA9IGRyYWdnYWJsZS5wYWdlLm1hcmdpbkJveDtcbiAgY29uc3QgZXhwYW5kQnkgPSB7XG4gICAgdG9wOiBkaXNwbGFjZWRCeS5wb2ludC55LFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiBkaXNwbGFjZWRCeS5wb2ludC54XG4gIH07XG4gIHJldHVybiBnZXRSZWN0KGV4cGFuZChtYXJnaW5Cb3gsIGV4cGFuZEJ5KSk7XG59XG5mdW5jdGlvbiBnZXREaXNwbGFjZW1lbnRHcm91cHMoX3JlZikge1xuICBsZXQge1xuICAgIGFmdGVyRHJhZ2dpbmcsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlLFxuICAgIGxhc3RcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBhZnRlckRyYWdnaW5nLnJlZHVjZShmdW5jdGlvbiBwcm9jZXNzKGdyb3VwcywgZHJhZ2dhYmxlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGRyYWdnYWJsZSwgZGlzcGxhY2VkQnkpO1xuICAgIGNvbnN0IGlkID0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQ7XG4gICAgZ3JvdXBzLmFsbC5wdXNoKGlkKTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSBpc1BhcnRpYWxseVZpc2libGUoe1xuICAgICAgdGFyZ2V0LFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoIWlzVmlzaWJsZSkge1xuICAgICAgZ3JvdXBzLmludmlzaWJsZVtkcmFnZ2FibGUuZGVzY3JpcHRvci5pZF0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkQW5pbWF0ZSA9IGdldFNob3VsZEFuaW1hdGUoaWQsIGxhc3QsIGZvcmNlU2hvdWxkQW5pbWF0ZSk7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0ge1xuICAgICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgICAgc2hvdWxkQW5pbWF0ZVxuICAgIH07XG4gICAgZ3JvdXBzLnZpc2libGVbaWRdID0gZGlzcGxhY2VtZW50O1xuICAgIHJldHVybiBncm91cHM7XG4gIH0sIHtcbiAgICBhbGw6IFtdLFxuICAgIHZpc2libGU6IHt9LFxuICAgIGludmlzaWJsZToge31cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4T2ZMYXN0SXRlbShkcmFnZ2FibGVzLCBvcHRpb25zKSB7XG4gIGlmICghZHJhZ2dhYmxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBpbmRleE9mTGFzdEl0ZW0gPSBkcmFnZ2FibGVzW2RyYWdnYWJsZXMubGVuZ3RoIC0gMV0uZGVzY3JpcHRvci5pbmRleDtcbiAgcmV0dXJuIG9wdGlvbnMuaW5Ib21lTGlzdCA/IGluZGV4T2ZMYXN0SXRlbSA6IGluZGV4T2ZMYXN0SXRlbSArIDE7XG59XG5mdW5jdGlvbiBnb0F0RW5kKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBpbkhvbWVMaXN0LFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGRlc3RpbmF0aW9uXG4gIH0gPSBfcmVmO1xuICBjb25zdCBuZXdJbmRleCA9IGdldEluZGV4T2ZMYXN0SXRlbShpbnNpZGVEZXN0aW5hdGlvbiwge1xuICAgIGluSG9tZUxpc3RcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxhY2VkOiBlbXB0eUdyb3VwcyxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3QoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgbGFzdCxcbiAgICBpbmRleCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGVcbiAgfSA9IF9yZWYyO1xuICBjb25zdCBpbkhvbWVMaXN0ID0gaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbik7XG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdvQXRFbmQoe1xuICAgICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBpbkhvbWVMaXN0LFxuICAgICAgZGlzcGxhY2VkQnksXG4gICAgICBkZXN0aW5hdGlvblxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gaW5zaWRlRGVzdGluYXRpb24uZmluZChpdGVtID0+IGl0ZW0uZGVzY3JpcHRvci5pbmRleCA9PT0gaW5kZXgpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIGdvQXRFbmQoe1xuICAgICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBpbkhvbWVMaXN0LFxuICAgICAgZGlzcGxhY2VkQnksXG4gICAgICBkZXN0aW5hdGlvblxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHdpdGhvdXREcmFnZ2luZyA9IHJlbW92ZURyYWdnYWJsZUZyb21MaXN0KGRyYWdnYWJsZSwgaW5zaWRlRGVzdGluYXRpb24pO1xuICBjb25zdCBzbGljZUZyb20gPSBpbnNpZGVEZXN0aW5hdGlvbi5pbmRleE9mKG1hdGNoKTtcbiAgY29uc3QgaW1wYWN0ZWQgPSB3aXRob3V0RHJhZ2dpbmcuc2xpY2Uoc2xpY2VGcm9tKTtcbiAgY29uc3QgZGlzcGxhY2VkID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBpbXBhY3RlZCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBsYXN0LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGVcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCxcbiAgICAgICAgaW5kZXhcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGVJZCwgYWZ0ZXJDcml0aWNhbCkge1xuICByZXR1cm4gQm9vbGVhbihhZnRlckNyaXRpY2FsLmVmZmVjdGVkW2RyYWdnYWJsZUlkXSk7XG59XG5cbnZhciBmcm9tQ29tYmluZSA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBjb21iaW5lLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSA9IF9yZWY7XG4gIGlmICghZGVzdGluYXRpb24uaXNDb21iaW5lRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNvbWJpbmVJZCA9IGNvbWJpbmUuZHJhZ2dhYmxlSWQ7XG4gIGNvbnN0IGNvbWJpbmVXaXRoID0gZHJhZ2dhYmxlc1tjb21iaW5lSWRdO1xuICBjb25zdCBjb21iaW5lV2l0aEluZGV4ID0gY29tYmluZVdpdGguZGVzY3JpcHRvci5pbmRleDtcbiAgY29uc3QgZGlkQ29tYmluZVdpdGhTdGFydEFmdGVyQ3JpdGljYWwgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoY29tYmluZUlkLCBhZnRlckNyaXRpY2FsKTtcbiAgaWYgKGRpZENvbWJpbmVXaXRoU3RhcnRBZnRlckNyaXRpY2FsKSB7XG4gICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXg7XG4gICAgfVxuICAgIHJldHVybiBjb21iaW5lV2l0aEluZGV4IC0gMTtcbiAgfVxuICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXggKyAxO1xuICB9XG4gIHJldHVybiBjb21iaW5lV2l0aEluZGV4O1xufSk7XG5cbnZhciBmcm9tUmVvcmRlciA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgaXNJbkhvbWVMaXN0LFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGxvY2F0aW9uXG4gIH0gPSBfcmVmO1xuICBpZiAoIWluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRJbmRleCA9IGxvY2F0aW9uLmluZGV4O1xuICBjb25zdCBwcm9wb3NlZEluZGV4ID0gaXNNb3ZpbmdGb3J3YXJkID8gY3VycmVudEluZGV4ICsgMSA6IGN1cnJlbnRJbmRleCAtIDE7XG4gIGNvbnN0IGZpcnN0SW5kZXggPSBpbnNpZGVEZXN0aW5hdGlvblswXS5kZXNjcmlwdG9yLmluZGV4O1xuICBjb25zdCBsYXN0SW5kZXggPSBpbnNpZGVEZXN0aW5hdGlvbltpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGggLSAxXS5kZXNjcmlwdG9yLmluZGV4O1xuICBjb25zdCB1cHBlckJvdW5kID0gaXNJbkhvbWVMaXN0ID8gbGFzdEluZGV4IDogbGFzdEluZGV4ICsgMTtcbiAgaWYgKHByb3Bvc2VkSW5kZXggPCBmaXJzdEluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHByb3Bvc2VkSW5kZXggPiB1cHBlckJvdW5kKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHByb3Bvc2VkSW5kZXg7XG59KTtcblxudmFyIG1vdmVUb05leHRJbmRleCA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgaXNJbkhvbWVMaXN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHdhc0F0ID0gcHJldmlvdXNJbXBhY3QuYXQ7XG4gICF3YXNBdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBtb3ZlIGluIGRpcmVjdGlvbiB3aXRob3V0IHByZXZpb3VzIGltcGFjdCBsb2NhdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgaWYgKHdhc0F0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIGNvbnN0IG5ld0luZGV4ID0gZnJvbVJlb3JkZXIoe1xuICAgICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgaXNJbkhvbWVMaXN0LFxuICAgICAgbG9jYXRpb246IHdhc0F0LmRlc3RpbmF0aW9uLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb25cbiAgICB9KTtcbiAgICBpZiAobmV3SW5kZXggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGxhc3Q6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICAgIGRpc3BsYWNlZEJ5OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG5ld0luZGV4ID0gZnJvbUNvbWJpbmUoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWQ6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGNvbWJpbmU6IHdhc0F0LmNvbWJpbmUsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgaWYgKG5ld0luZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0LFxuICAgIGxhc3Q6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeTogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgaW5kZXg6IG5ld0luZGV4XG4gIH0pO1xufSk7XG5cbnZhciBnZXRDb21iaW5lZEl0ZW1EaXNwbGFjZW1lbnQgPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgZGlzcGxhY2VkLFxuICAgIGFmdGVyQ3JpdGljYWwsXG4gICAgY29tYmluZVdpdGgsXG4gICAgZGlzcGxhY2VkQnlcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGlzRGlzcGxhY2VkID0gQm9vbGVhbihkaXNwbGFjZWQudmlzaWJsZVtjb21iaW5lV2l0aF0gfHwgZGlzcGxhY2VkLmludmlzaWJsZVtjb21iaW5lV2l0aF0pO1xuICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsKGNvbWJpbmVXaXRoLCBhZnRlckNyaXRpY2FsKSkge1xuICAgIHJldHVybiBpc0Rpc3BsYWNlZCA/IG9yaWdpbiA6IG5lZ2F0ZShkaXNwbGFjZWRCeS5wb2ludCk7XG4gIH1cbiAgcmV0dXJuIGlzRGlzcGxhY2VkID8gZGlzcGxhY2VkQnkucG9pbnQgOiBvcmlnaW47XG59KTtcblxudmFyIHdoZW5Db21iaW5pbmcgPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgYWZ0ZXJDcml0aWNhbCxcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlc1xuICB9ID0gX3JlZjtcbiAgY29uc3QgY29tYmluZSA9IHRyeUdldENvbWJpbmUoaW1wYWN0KTtcbiAgIWNvbWJpbmUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgY29uc3QgY29tYmluZVdpdGggPSBjb21iaW5lLmRyYWdnYWJsZUlkO1xuICBjb25zdCBjZW50ZXIgPSBkcmFnZ2FibGVzW2NvbWJpbmVXaXRoXS5wYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIGNvbnN0IGRpc3BsYWNlQnkgPSBnZXRDb21iaW5lZEl0ZW1EaXNwbGFjZW1lbnQoe1xuICAgIGRpc3BsYWNlZDogaW1wYWN0LmRpc3BsYWNlZCxcbiAgICBhZnRlckNyaXRpY2FsLFxuICAgIGNvbWJpbmVXaXRoLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnlcbiAgfSk7XG4gIHJldHVybiBhZGQoY2VudGVyLCBkaXNwbGFjZUJ5KTtcbn0pO1xuXG5jb25zdCBkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyID0gKGF4aXMsIGJveCkgPT4gYm94Lm1hcmdpbltheGlzLnN0YXJ0XSArIGJveC5ib3JkZXJCb3hbYXhpcy5zaXplXSAvIDI7XG5jb25zdCBkaXN0YW5jZUZyb21FbmRUb0JvcmRlckJveENlbnRlciA9IChheGlzLCBib3gpID0+IGJveC5tYXJnaW5bYXhpcy5lbmRdICsgYm94LmJvcmRlckJveFtheGlzLnNpemVdIC8gMjtcbmNvbnN0IGdldENyb3NzQXhpc0JvcmRlckJveENlbnRlciA9IChheGlzLCB0YXJnZXQsIGlzTW92aW5nKSA9PiB0YXJnZXRbYXhpcy5jcm9zc0F4aXNTdGFydF0gKyBpc01vdmluZy5tYXJnaW5bYXhpcy5jcm9zc0F4aXNTdGFydF0gKyBpc01vdmluZy5ib3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNTaXplXSAvIDI7XG5jb25zdCBnb0FmdGVyID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgYXhpcyxcbiAgICBtb3ZlUmVsYXRpdmVUbyxcbiAgICBpc01vdmluZ1xuICB9ID0gX3JlZjtcbiAgcmV0dXJuIHBhdGNoKGF4aXMubGluZSwgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94W2F4aXMuZW5kXSArIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94LCBpc01vdmluZykpO1xufTtcbmNvbnN0IGdvQmVmb3JlID0gX3JlZjIgPT4ge1xuICBsZXQge1xuICAgIGF4aXMsXG4gICAgbW92ZVJlbGF0aXZlVG8sXG4gICAgaXNNb3ZpbmdcbiAgfSA9IF9yZWYyO1xuICByZXR1cm4gcGF0Y2goYXhpcy5saW5lLCBtb3ZlUmVsYXRpdmVUby5tYXJnaW5Cb3hbYXhpcy5zdGFydF0gLSBkaXN0YW5jZUZyb21FbmRUb0JvcmRlckJveENlbnRlcihheGlzLCBpc01vdmluZyksIGdldENyb3NzQXhpc0JvcmRlckJveENlbnRlcihheGlzLCBtb3ZlUmVsYXRpdmVUby5tYXJnaW5Cb3gsIGlzTW92aW5nKSk7XG59O1xuY29uc3QgZ29JbnRvU3RhcnQgPSBfcmVmMyA9PiB7XG4gIGxldCB7XG4gICAgYXhpcyxcbiAgICBtb3ZlSW50byxcbiAgICBpc01vdmluZ1xuICB9ID0gX3JlZjM7XG4gIHJldHVybiBwYXRjaChheGlzLmxpbmUsIG1vdmVJbnRvLmNvbnRlbnRCb3hbYXhpcy5zdGFydF0gKyBkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyKGF4aXMsIGlzTW92aW5nKSwgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyKGF4aXMsIG1vdmVJbnRvLmNvbnRlbnRCb3gsIGlzTW92aW5nKSk7XG59O1xuXG52YXIgd2hlblJlb3JkZXJpbmcgPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZSxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0gPSBfcmVmO1xuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBkcmFnZ2FibGVQYWdlID0gZHJhZ2dhYmxlLnBhZ2U7XG4gIGNvbnN0IGF4aXMgPSBkcm9wcGFibGUuYXhpcztcbiAgaWYgKCFpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZ29JbnRvU3RhcnQoe1xuICAgICAgYXhpcyxcbiAgICAgIG1vdmVJbnRvOiBkcm9wcGFibGUucGFnZSxcbiAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeVxuICB9ID0gaW1wYWN0O1xuICBjb25zdCBjbG9zZXN0QWZ0ZXIgPSBkaXNwbGFjZWQuYWxsWzBdO1xuICBpZiAoY2xvc2VzdEFmdGVyKSB7XG4gICAgY29uc3QgY2xvc2VzdCA9IGRyYWdnYWJsZXNbY2xvc2VzdEFmdGVyXTtcbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsKGNsb3Nlc3RBZnRlciwgYWZ0ZXJDcml0aWNhbCkpIHtcbiAgICAgIHJldHVybiBnb0JlZm9yZSh7XG4gICAgICAgIGF4aXMsXG4gICAgICAgIG1vdmVSZWxhdGl2ZVRvOiBjbG9zZXN0LnBhZ2UsXG4gICAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgd2l0aERpc3BsYWNlbWVudCA9IG9mZnNldChjbG9zZXN0LnBhZ2UsIGRpc3BsYWNlZEJ5LnBvaW50KTtcbiAgICByZXR1cm4gZ29CZWZvcmUoe1xuICAgICAgYXhpcyxcbiAgICAgIG1vdmVSZWxhdGl2ZVRvOiB3aXRoRGlzcGxhY2VtZW50LFxuICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICB9KTtcbiAgfVxuICBjb25zdCBsYXN0ID0gaW5zaWRlRGVzdGluYXRpb25baW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0LmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkKSB7XG4gICAgcmV0dXJuIGRyYWdnYWJsZVBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgfVxuICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsKGxhc3QuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkpIHtcbiAgICBjb25zdCBwYWdlID0gb2Zmc2V0KGxhc3QucGFnZSwgbmVnYXRlKGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpKTtcbiAgICByZXR1cm4gZ29BZnRlcih7XG4gICAgICBheGlzLFxuICAgICAgbW92ZVJlbGF0aXZlVG86IHBhZ2UsXG4gICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBnb0FmdGVyKHtcbiAgICBheGlzLFxuICAgIG1vdmVSZWxhdGl2ZVRvOiBsYXN0LnBhZ2UsXG4gICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgfSk7XG59KTtcblxudmFyIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQgPSAoKGRyb3BwYWJsZSwgcG9pbnQpID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cbiAgcmV0dXJuIGFkZChwb2ludCwgZnJhbWUuc2Nyb2xsLmRpZmYuZGlzcGxhY2VtZW50KTtcbn0pO1xuXG5jb25zdCBnZXRSZXN1bHRXaXRob3V0RHJvcHBhYmxlRGlzcGxhY2VtZW50ID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0gPSBfcmVmO1xuICBjb25zdCBvcmlnaW5hbCA9IGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIGNvbnN0IGF0ID0gaW1wYWN0LmF0O1xuICBpZiAoIWRyb3BwYWJsZSkge1xuICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsO1xuICB9XG4gIGlmIChhdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gd2hlblJlb3JkZXJpbmcoe1xuICAgICAgaW1wYWN0LFxuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZSxcbiAgICAgIGFmdGVyQ3JpdGljYWxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gd2hlbkNvbWJpbmluZyh7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbn07XG52YXIgZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3QgPSAoYXJncyA9PiB7XG4gIGNvbnN0IHdpdGhvdXREaXNwbGFjZW1lbnQgPSBnZXRSZXN1bHRXaXRob3V0RHJvcHBhYmxlRGlzcGxhY2VtZW50KGFyZ3MpO1xuICBjb25zdCBkcm9wcGFibGUgPSBhcmdzLmRyb3BwYWJsZTtcbiAgY29uc3Qgd2l0aERpc3BsYWNlbWVudCA9IGRyb3BwYWJsZSA/IHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQoZHJvcHBhYmxlLCB3aXRob3V0RGlzcGxhY2VtZW50KSA6IHdpdGhvdXREaXNwbGFjZW1lbnQ7XG4gIHJldHVybiB3aXRoRGlzcGxhY2VtZW50O1xufSk7XG5cbnZhciBzY3JvbGxWaWV3cG9ydCA9ICgodmlld3BvcnQsIG5ld1Njcm9sbCkgPT4ge1xuICBjb25zdCBkaWZmID0gc3VidHJhY3QobmV3U2Nyb2xsLCB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCk7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IG5lZ2F0ZShkaWZmKTtcbiAgY29uc3QgZnJhbWUgPSBnZXRSZWN0KHtcbiAgICB0b3A6IG5ld1Njcm9sbC55LFxuICAgIGJvdHRvbTogbmV3U2Nyb2xsLnkgKyB2aWV3cG9ydC5mcmFtZS5oZWlnaHQsXG4gICAgbGVmdDogbmV3U2Nyb2xsLngsXG4gICAgcmlnaHQ6IG5ld1Njcm9sbC54ICsgdmlld3BvcnQuZnJhbWUud2lkdGhcbiAgfSk7XG4gIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgZnJhbWUsXG4gICAgc2Nyb2xsOiB7XG4gICAgICBpbml0aWFsOiB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCxcbiAgICAgIG1heDogdmlld3BvcnQuc2Nyb2xsLm1heCxcbiAgICAgIGN1cnJlbnQ6IG5ld1Njcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IGRpZmYsXG4gICAgICAgIGRpc3BsYWNlbWVudFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZWQ7XG59KTtcblxuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlcyQxKGlkcywgZHJhZ2dhYmxlcykge1xuICByZXR1cm4gaWRzLm1hcChpZCA9PiBkcmFnZ2FibGVzW2lkXSk7XG59XG5mdW5jdGlvbiB0cnlHZXRWaXNpYmxlKGlkLCBncm91cHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSBncm91cHNbaV0udmlzaWJsZVtpZF07XG4gICAgaWYgKGRpc3BsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIGRpc3BsYWNlbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG52YXIgc3BlY3VsYXRpdmVseUluY3JlYXNlID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIG1heFNjcm9sbENoYW5nZVxuICB9ID0gX3JlZjtcbiAgY29uc3Qgc2Nyb2xsZWRWaWV3cG9ydCA9IHNjcm9sbFZpZXdwb3J0KHZpZXdwb3J0LCBhZGQodmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQsIG1heFNjcm9sbENoYW5nZSkpO1xuICBjb25zdCBzY3JvbGxlZERyb3BwYWJsZSA9IGRlc3RpbmF0aW9uLmZyYW1lID8gc2Nyb2xsRHJvcHBhYmxlKGRlc3RpbmF0aW9uLCBhZGQoZGVzdGluYXRpb24uZnJhbWUuc2Nyb2xsLmN1cnJlbnQsIG1heFNjcm9sbENoYW5nZSkpIDogZGVzdGluYXRpb247XG4gIGNvbnN0IGxhc3QgPSBpbXBhY3QuZGlzcGxhY2VkO1xuICBjb25zdCB3aXRoVmlld3BvcnRTY3JvbGwgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmc6IGdldERyYWdnYWJsZXMkMShsYXN0LmFsbCwgZHJhZ2dhYmxlcyksXG4gICAgZGVzdGluYXRpb24sXG4gICAgZGlzcGxhY2VkQnk6IGltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICB2aWV3cG9ydDogc2Nyb2xsZWRWaWV3cG9ydC5mcmFtZSxcbiAgICBsYXN0LFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IHdpdGhEcm9wcGFibGVTY3JvbGwgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmc6IGdldERyYWdnYWJsZXMkMShsYXN0LmFsbCwgZHJhZ2dhYmxlcyksXG4gICAgZGVzdGluYXRpb246IHNjcm9sbGVkRHJvcHBhYmxlLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGxhc3QsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgaW52aXNpYmxlID0ge307XG4gIGNvbnN0IHZpc2libGUgPSB7fTtcbiAgY29uc3QgZ3JvdXBzID0gW2xhc3QsIHdpdGhWaWV3cG9ydFNjcm9sbCwgd2l0aERyb3BwYWJsZVNjcm9sbF07XG4gIGxhc3QuYWxsLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRyeUdldFZpc2libGUoaWQsIGdyb3Vwcyk7XG4gICAgaWYgKGRpc3BsYWNlbWVudCkge1xuICAgICAgdmlzaWJsZVtpZF0gPSBkaXNwbGFjZW1lbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmlzaWJsZVtpZF0gPSB0cnVlO1xuICB9KTtcbiAgY29uc3QgbmV3SW1wYWN0ID0ge1xuICAgIC4uLmltcGFjdCxcbiAgICBkaXNwbGFjZWQ6IHtcbiAgICAgIGFsbDogbGFzdC5hbGwsXG4gICAgICBpbnZpc2libGUsXG4gICAgICB2aXNpYmxlXG4gICAgfVxuICB9O1xuICByZXR1cm4gbmV3SW1wYWN0O1xufSk7XG5cbnZhciB3aXRoVmlld3BvcnREaXNwbGFjZW1lbnQgPSAoKHZpZXdwb3J0LCBwb2ludCkgPT4gYWRkKHZpZXdwb3J0LnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCwgcG9pbnQpKTtcblxudmFyIGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlLFxuICAgIHZpZXdwb3J0XG4gIH0gPSBfcmVmO1xuICBjb25zdCB3aXRob3V0UGFnZVNjcm9sbENoYW5nZSA9IHdpdGhWaWV3cG9ydERpc3BsYWNlbWVudCh2aWV3cG9ydCwgcGFnZUJvcmRlckJveENlbnRlcik7XG4gIGNvbnN0IG9mZnNldCA9IHN1YnRyYWN0KHdpdGhvdXRQYWdlU2Nyb2xsQ2hhbmdlLCBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyKTtcbiAgcmV0dXJuIGFkZChkcmFnZ2FibGUuY2xpZW50LmJvcmRlckJveC5jZW50ZXIsIG9mZnNldCk7XG59KTtcblxudmFyIGlzVG90YWxseVZpc2libGVJbk5ld0xvY2F0aW9uID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBuZXdQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHZpZXdwb3J0LFxuICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gICAgb25seU9uTWFpbkF4aXMgPSBmYWxzZVxuICB9ID0gX3JlZjtcbiAgY29uc3QgY2hhbmdlTmVlZGVkID0gc3VidHJhY3QobmV3UGFnZUJvcmRlckJveENlbnRlciwgZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcik7XG4gIGNvbnN0IHNoaWZ0ZWQgPSBvZmZzZXRCeVBvc2l0aW9uKGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveCwgY2hhbmdlTmVlZGVkKTtcbiAgY29uc3QgYXJncyA9IHtcbiAgICB0YXJnZXQ6IHNoaWZ0ZWQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCxcbiAgICB2aWV3cG9ydFxuICB9O1xuICByZXR1cm4gb25seU9uTWFpbkF4aXMgPyBpc1RvdGFsbHlWaXNpYmxlT25BeGlzKGFyZ3MpIDogaXNUb3RhbGx5VmlzaWJsZShhcmdzKTtcbn0pO1xuXG52YXIgbW92ZVRvTmV4dFBsYWNlID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBwcmV2aW91c0ltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgcHJldmlvdXNDbGllbnRTZWxlY3Rpb24sXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9ID0gX3JlZjtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IGlzSW5Ib21lTGlzdCA9IGlzSG9tZU9mKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pO1xuICBjb25zdCBpbXBhY3QgPSBtb3ZlVG9OZXh0Q29tYmluZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBwcmV2aW91c0ltcGFjdFxuICB9KSB8fCBtb3ZlVG9OZXh0SW5kZXgoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBpc0luSG9tZUxpc3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgaWYgKCFpbXBhY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBwYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IGlzVmlzaWJsZUluTmV3TG9jYXRpb24gPSBpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbih7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXI6IHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IGZhbHNlLFxuICAgIG9ubHlPbk1haW5BeGlzOiB0cnVlXG4gIH0pO1xuICBpZiAoaXNWaXNpYmxlSW5OZXdMb2NhdGlvbikge1xuICAgIGNvbnN0IGNsaWVudFNlbGVjdGlvbiA9IGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyKHtcbiAgICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICBkcmFnZ2FibGUsXG4gICAgICB2aWV3cG9ydFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBpbXBhY3QsXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbFxuICAgIH07XG4gIH1cbiAgY29uc3QgZGlzdGFuY2UgPSBzdWJ0cmFjdChwYWdlQm9yZGVyQm94Q2VudGVyLCBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIpO1xuICBjb25zdCBjYXV0aW91cyA9IHNwZWN1bGF0aXZlbHlJbmNyZWFzZSh7XG4gICAgaW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgbWF4U2Nyb2xsQ2hhbmdlOiBkaXN0YW5jZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRTZWxlY3Rpb246IHByZXZpb3VzQ2xpZW50U2VsZWN0aW9uLFxuICAgIGltcGFjdDogY2F1dGlvdXMsXG4gICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IGRpc3RhbmNlXG4gIH07XG59KTtcblxuY29uc3QgZ2V0S25vd25BY3RpdmUgPSBkcm9wcGFibGUgPT4ge1xuICBjb25zdCByZWN0ID0gZHJvcHBhYmxlLnN1YmplY3QuYWN0aXZlO1xuICAhcmVjdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBnZXQgY2xpcHBlZCBhcmVhIGZyb20gZHJvcHBhYmxlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gcmVjdDtcbn07XG52YXIgZ2V0QmVzdENyb3NzQXhpc0Ryb3BwYWJsZSA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgICBzb3VyY2UsXG4gICAgZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydFxuICB9ID0gX3JlZjtcbiAgY29uc3QgYWN0aXZlID0gc291cmNlLnN1YmplY3QuYWN0aXZlO1xuICBpZiAoIWFjdGl2ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGF4aXMgPSBzb3VyY2UuYXhpcztcbiAgY29uc3QgaXNCZXR3ZWVuU291cmNlQ2xpcHBlZCA9IGlzV2l0aGluKGFjdGl2ZVtheGlzLnN0YXJ0XSwgYWN0aXZlW2F4aXMuZW5kXSk7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSB0b0Ryb3BwYWJsZUxpc3QoZHJvcHBhYmxlcykuZmlsdGVyKGRyb3BwYWJsZSA9PiBkcm9wcGFibGUgIT09IHNvdXJjZSkuZmlsdGVyKGRyb3BwYWJsZSA9PiBkcm9wcGFibGUuaXNFbmFibGVkKS5maWx0ZXIoZHJvcHBhYmxlID0+IEJvb2xlYW4oZHJvcHBhYmxlLnN1YmplY3QuYWN0aXZlKSkuZmlsdGVyKGRyb3BwYWJsZSA9PiBpc1BhcnRpYWxseVZpc2libGVUaHJvdWdoRnJhbWUodmlld3BvcnQuZnJhbWUpKGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSkpKS5maWx0ZXIoZHJvcHBhYmxlID0+IHtcbiAgICBjb25zdCBhY3RpdmVPZlRhcmdldCA9IGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSk7XG4gICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZVtheGlzLmNyb3NzQXhpc0VuZF0gPCBhY3RpdmVPZlRhcmdldFtheGlzLmNyb3NzQXhpc0VuZF07XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVPZlRhcmdldFtheGlzLmNyb3NzQXhpc1N0YXJ0XSA8IGFjdGl2ZVtheGlzLmNyb3NzQXhpc1N0YXJ0XTtcbiAgfSkuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gICAgY29uc3QgYWN0aXZlT2ZUYXJnZXQgPSBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpO1xuICAgIGNvbnN0IGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZCA9IGlzV2l0aGluKGFjdGl2ZU9mVGFyZ2V0W2F4aXMuc3RhcnRdLCBhY3RpdmVPZlRhcmdldFtheGlzLmVuZF0pO1xuICAgIHJldHVybiBpc0JldHdlZW5Tb3VyY2VDbGlwcGVkKGFjdGl2ZU9mVGFyZ2V0W2F4aXMuc3RhcnRdKSB8fCBpc0JldHdlZW5Tb3VyY2VDbGlwcGVkKGFjdGl2ZU9mVGFyZ2V0W2F4aXMuZW5kXSkgfHwgaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkKGFjdGl2ZVtheGlzLnN0YXJ0XSkgfHwgaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkKGFjdGl2ZVtheGlzLmVuZF0pO1xuICB9KS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgZmlyc3QgPSBnZXRLbm93bkFjdGl2ZShhKVtheGlzLmNyb3NzQXhpc1N0YXJ0XTtcbiAgICBjb25zdCBzZWNvbmQgPSBnZXRLbm93bkFjdGl2ZShiKVtheGlzLmNyb3NzQXhpc1N0YXJ0XTtcbiAgICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICByZXR1cm4gZmlyc3QgLSBzZWNvbmQ7XG4gICAgfVxuICAgIHJldHVybiBzZWNvbmQgLSBmaXJzdDtcbiAgfSkuZmlsdGVyKChkcm9wcGFibGUsIGluZGV4LCBhcnJheSkgPT4gZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKVtheGlzLmNyb3NzQXhpc1N0YXJ0XSA9PT0gZ2V0S25vd25BY3RpdmUoYXJyYXlbMF0pW2F4aXMuY3Jvc3NBeGlzU3RhcnRdKTtcbiAgaWYgKCFjYW5kaWRhdGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjYW5kaWRhdGVzWzBdO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5zID0gY2FuZGlkYXRlcy5maWx0ZXIoZHJvcHBhYmxlID0+IHtcbiAgICBjb25zdCBpc1dpdGhpbkRyb3BwYWJsZSA9IGlzV2l0aGluKGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSlbYXhpcy5zdGFydF0sIGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSlbYXhpcy5lbmRdKTtcbiAgICByZXR1cm4gaXNXaXRoaW5Ecm9wcGFibGUocGFnZUJvcmRlckJveENlbnRlcltheGlzLmxpbmVdKTtcbiAgfSk7XG4gIGlmIChjb250YWlucy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY29udGFpbnNbMF07XG4gIH1cbiAgaWYgKGNvbnRhaW5zLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gY29udGFpbnMuc29ydCgoYSwgYikgPT4gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5zdGFydF0gLSBnZXRLbm93bkFjdGl2ZShiKVtheGlzLnN0YXJ0XSlbMF07XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGZpcnN0ID0gY2xvc2VzdCQxKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIGdldENvcm5lcnMoZ2V0S25vd25BY3RpdmUoYSkpKTtcbiAgICBjb25zdCBzZWNvbmQgPSBjbG9zZXN0JDEocGFnZUJvcmRlckJveENlbnRlciwgZ2V0Q29ybmVycyhnZXRLbm93bkFjdGl2ZShiKSkpO1xuICAgIGlmIChmaXJzdCAhPT0gc2Vjb25kKSB7XG4gICAgICByZXR1cm4gZmlyc3QgLSBzZWNvbmQ7XG4gICAgfVxuICAgIHJldHVybiBnZXRLbm93bkFjdGl2ZShhKVtheGlzLnN0YXJ0XSAtIGdldEtub3duQWN0aXZlKGIpW2F4aXMuc3RhcnRdO1xuICB9KVswXTtcbn0pO1xuXG5jb25zdCBnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlciA9IChkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpID0+IHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICByZXR1cm4gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkLCBhZnRlckNyaXRpY2FsKSA/IHN1YnRyYWN0KG9yaWdpbmFsLCBhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KSA6IG9yaWdpbmFsO1xufTtcbmNvbnN0IGdldEN1cnJlbnRQYWdlQm9yZGVyQm94ID0gKGRyYWdnYWJsZSwgYWZ0ZXJDcml0aWNhbCkgPT4ge1xuICBjb25zdCBvcmlnaW5hbCA9IGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveDtcbiAgcmV0dXJuIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkgPyBvZmZzZXRCeVBvc2l0aW9uKG9yaWdpbmFsLCBuZWdhdGUoYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCkpIDogb3JpZ2luYWw7XG59O1xuXG52YXIgZ2V0Q2xvc2VzdERyYWdnYWJsZSA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHZpZXdwb3J0LFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNvcnRlZCA9IGluc2lkZURlc3RpbmF0aW9uLmZpbHRlcihkcmFnZ2FibGUgPT4gaXNUb3RhbGx5VmlzaWJsZSh7XG4gICAgdGFyZ2V0OiBnZXRDdXJyZW50UGFnZUJvcmRlckJveChkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiB0cnVlXG4gIH0pKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgZGlzdGFuY2VUb0EgPSBkaXN0YW5jZShwYWdlQm9yZGVyQm94Q2VudGVyLCB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50KGRlc3RpbmF0aW9uLCBnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlcihhLCBhZnRlckNyaXRpY2FsKSkpO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9CID0gZGlzdGFuY2UocGFnZUJvcmRlckJveENlbnRlciwgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudChkZXN0aW5hdGlvbiwgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIoYiwgYWZ0ZXJDcml0aWNhbCkpKTtcbiAgICBpZiAoZGlzdGFuY2VUb0EgPCBkaXN0YW5jZVRvQikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoZGlzdGFuY2VUb0IgPCBkaXN0YW5jZVRvQSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBhLmRlc2NyaXB0b3IuaW5kZXggLSBiLmRlc2NyaXB0b3IuaW5kZXg7XG4gIH0pO1xuICByZXR1cm4gc29ydGVkWzBdIHx8IG51bGw7XG59KTtcblxudmFyIGdldERpc3BsYWNlZEJ5ID0gbWVtb2l6ZU9uZShmdW5jdGlvbiBnZXREaXNwbGFjZWRCeShheGlzLCBkaXNwbGFjZUJ5KSB7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IGRpc3BsYWNlQnlbYXhpcy5saW5lXTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogZGlzcGxhY2VtZW50LFxuICAgIHBvaW50OiBwYXRjaChheGlzLmxpbmUsIGRpc3BsYWNlbWVudClcbiAgfTtcbn0pO1xuXG5jb25zdCBnZXRSZXF1aXJlZEdyb3d0aEZvclBsYWNlaG9sZGVyID0gKGRyb3BwYWJsZSwgcGxhY2Vob2xkZXJTaXplLCBkcmFnZ2FibGVzKSA9PiB7XG4gIGNvbnN0IGF4aXMgPSBkcm9wcGFibGUuYXhpcztcbiAgaWYgKGRyb3BwYWJsZS5kZXNjcmlwdG9yLm1vZGUgPT09ICd2aXJ0dWFsJykge1xuICAgIHJldHVybiBwYXRjaChheGlzLmxpbmUsIHBsYWNlaG9sZGVyU2l6ZVtheGlzLmxpbmVdKTtcbiAgfVxuICBjb25zdCBhdmFpbGFibGVTcGFjZSA9IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UuY29udGVudEJveFtheGlzLnNpemVdO1xuICBjb25zdCBpbnNpZGVEcm9wcGFibGUgPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3Qgc3BhY2VVc2VkID0gaW5zaWRlRHJvcHBhYmxlLnJlZHVjZSgoc3VtLCBkaW1lbnNpb24pID0+IHN1bSArIGRpbWVuc2lvbi5jbGllbnQubWFyZ2luQm94W2F4aXMuc2l6ZV0sIDApO1xuICBjb25zdCByZXF1aXJlZFNwYWNlID0gc3BhY2VVc2VkICsgcGxhY2Vob2xkZXJTaXplW2F4aXMubGluZV07XG4gIGNvbnN0IG5lZWRzVG9Hcm93QnkgPSByZXF1aXJlZFNwYWNlIC0gYXZhaWxhYmxlU3BhY2U7XG4gIGlmIChuZWVkc1RvR3Jvd0J5IDw9IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcGF0Y2goYXhpcy5saW5lLCBuZWVkc1RvR3Jvd0J5KTtcbn07XG5jb25zdCB3aXRoTWF4U2Nyb2xsID0gKGZyYW1lLCBtYXgpID0+ICh7XG4gIC4uLmZyYW1lLFxuICBzY3JvbGw6IHtcbiAgICAuLi5mcmFtZS5zY3JvbGwsXG4gICAgbWF4XG4gIH1cbn0pO1xuY29uc3QgYWRkUGxhY2Vob2xkZXIgPSAoZHJvcHBhYmxlLCBkcmFnZ2FibGUsIGRyYWdnYWJsZXMpID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gICEhaXNIb21lT2YoZHJhZ2dhYmxlLCBkcm9wcGFibGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIG5vdCBhZGQgcGxhY2Vob2xkZXIgc3BhY2UgdG8gaG9tZSBsaXN0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhIWRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBhZGQgcGxhY2Vob2xkZXIgc2l6ZSB0byBhIHN1YmplY3Qgd2hlbiBpdCBhbHJlYWR5IGhhcyBvbmUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGNvbnN0IHBsYWNlaG9sZGVyU2l6ZSA9IGdldERpc3BsYWNlZEJ5KGRyb3BwYWJsZS5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSkucG9pbnQ7XG4gIGNvbnN0IHJlcXVpcmVkR3Jvd3RoID0gZ2V0UmVxdWlyZWRHcm93dGhGb3JQbGFjZWhvbGRlcihkcm9wcGFibGUsIHBsYWNlaG9sZGVyU2l6ZSwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IGFkZGVkID0ge1xuICAgIHBsYWNlaG9sZGVyU2l6ZSxcbiAgICBpbmNyZWFzZWRCeTogcmVxdWlyZWRHcm93dGgsXG4gICAgb2xkRnJhbWVNYXhTY3JvbGw6IGRyb3BwYWJsZS5mcmFtZSA/IGRyb3BwYWJsZS5mcmFtZS5zY3JvbGwubWF4IDogbnVsbFxuICB9O1xuICBpZiAoIWZyYW1lKSB7XG4gICAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICAgIHdpdGhQbGFjZWhvbGRlcjogYWRkZWQsXG4gICAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICAgIGZyYW1lOiBkcm9wcGFibGUuZnJhbWVcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZHJvcHBhYmxlLFxuICAgICAgc3ViamVjdFxuICAgIH07XG4gIH1cbiAgY29uc3QgbWF4U2Nyb2xsID0gcmVxdWlyZWRHcm93dGggPyBhZGQoZnJhbWUuc2Nyb2xsLm1heCwgcmVxdWlyZWRHcm93dGgpIDogZnJhbWUuc2Nyb2xsLm1heDtcbiAgY29uc3QgbmV3RnJhbWUgPSB3aXRoTWF4U2Nyb2xsKGZyYW1lLCBtYXhTY3JvbGwpO1xuICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IGFkZGVkLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lOiBuZXdGcmFtZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kcm9wcGFibGUsXG4gICAgc3ViamVjdCxcbiAgICBmcmFtZTogbmV3RnJhbWVcbiAgfTtcbn07XG5jb25zdCByZW1vdmVQbGFjZWhvbGRlciA9IGRyb3BwYWJsZSA9PiB7XG4gIGNvbnN0IGFkZGVkID0gZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyO1xuICAhYWRkZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcmVtb3ZlIHBsYWNlaG9sZGVyIGZvcm0gc3ViamVjdCB3aGVuIHRoZXJlIHdhcyBub25lJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICAgIGZyYW1lOiBudWxsLFxuICAgICAgd2l0aFBsYWNlaG9sZGVyOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRyb3BwYWJsZSxcbiAgICAgIHN1YmplY3RcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9sZE1heFNjcm9sbCA9IGFkZGVkLm9sZEZyYW1lTWF4U2Nyb2xsO1xuICAhb2xkTWF4U2Nyb2xsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZHJvcHBhYmxlIHdpdGggZnJhbWUgdG8gaGF2ZSBvbGQgbWF4IGZyYW1lIHNjcm9sbCB3aGVuIHJlbW92aW5nIHBsYWNlaG9sZGVyJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBuZXdGcmFtZSA9IHdpdGhNYXhTY3JvbGwoZnJhbWUsIG9sZE1heFNjcm9sbCk7XG4gIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lOiBuZXdGcmFtZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IG51bGxcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uZHJvcHBhYmxlLFxuICAgIHN1YmplY3QsXG4gICAgZnJhbWU6IG5ld0ZyYW1lXG4gIH07XG59O1xuXG52YXIgbW92ZVRvTmV3RHJvcHBhYmxlID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBtb3ZlUmVsYXRpdmVUbyxcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0gPSBfcmVmO1xuICBpZiAoIW1vdmVSZWxhdGl2ZVRvKSB7XG4gICAgaWYgKGluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHByb3Bvc2VkID0ge1xuICAgICAgZGlzcGxhY2VkOiBlbXB0eUdyb3VwcyxcbiAgICAgIGRpc3BsYWNlZEJ5OiBub0Rpc3BsYWNlZEJ5LFxuICAgICAgYXQ6IHtcbiAgICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLFxuICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByb3Bvc2VkUGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICAgIGltcGFjdDogcHJvcG9zZWQsXG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uLFxuICAgICAgZHJhZ2dhYmxlcyxcbiAgICAgIGFmdGVyQ3JpdGljYWxcbiAgICB9KTtcbiAgICBjb25zdCB3aXRoUGxhY2Vob2xkZXIgPSBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKSA/IGRlc3RpbmF0aW9uIDogYWRkUGxhY2Vob2xkZXIoZGVzdGluYXRpb24sIGRyYWdnYWJsZSwgZHJhZ2dhYmxlcyk7XG4gICAgY29uc3QgaXNWaXNpYmxlSW5OZXdMb2NhdGlvbiA9IGlzVG90YWxseVZpc2libGVJbk5ld0xvY2F0aW9uKHtcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGRlc3RpbmF0aW9uOiB3aXRoUGxhY2Vob2xkZXIsXG4gICAgICBuZXdQYWdlQm9yZGVyQm94Q2VudGVyOiBwcm9wb3NlZFBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiBmYWxzZSxcbiAgICAgIG9ubHlPbk1haW5BeGlzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGlzVmlzaWJsZUluTmV3TG9jYXRpb24gPyBwcm9wb3NlZCA6IG51bGw7XG4gIH1cbiAgY29uc3QgaXNHb2luZ0JlZm9yZVRhcmdldCA9IEJvb2xlYW4ocHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyW2Rlc3RpbmF0aW9uLmF4aXMubGluZV0gPD0gbW92ZVJlbGF0aXZlVG8ucGFnZS5ib3JkZXJCb3guY2VudGVyW2Rlc3RpbmF0aW9uLmF4aXMubGluZV0pO1xuICBjb25zdCBwcm9wb3NlZEluZGV4ID0gKCgpID0+IHtcbiAgICBjb25zdCByZWxhdGl2ZVRvID0gbW92ZVJlbGF0aXZlVG8uZGVzY3JpcHRvci5pbmRleDtcbiAgICBpZiAobW92ZVJlbGF0aXZlVG8uZGVzY3JpcHRvci5pZCA9PT0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQpIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZVRvO1xuICAgIH1cbiAgICBpZiAoaXNHb2luZ0JlZm9yZVRhcmdldCkge1xuICAgICAgcmV0dXJuIHJlbGF0aXZlVG87XG4gICAgfVxuICAgIHJldHVybiByZWxhdGl2ZVRvICsgMTtcbiAgfSkoKTtcbiAgY29uc3QgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShkZXN0aW5hdGlvbi5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgbGFzdDogZW1wdHlHcm91cHMsXG4gICAgaW5kZXg6IHByb3Bvc2VkSW5kZXhcbiAgfSk7XG59KTtcblxudmFyIG1vdmVDcm9zc0F4aXMgPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgaXNPdmVyLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0gPSBfcmVmO1xuICBjb25zdCBkZXN0aW5hdGlvbiA9IGdldEJlc3RDcm9zc0F4aXNEcm9wcGFibGUoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyOiBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgc291cmNlOiBpc092ZXIsXG4gICAgZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydFxuICB9KTtcbiAgaWYgKCFkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgbW92ZVJlbGF0aXZlVG8gPSBnZXRDbG9zZXN0RHJhZ2dhYmxlKHtcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyOiBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgdmlld3BvcnQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgY29uc3QgaW1wYWN0ID0gbW92ZVRvTmV3RHJvcHBhYmxlKHtcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgbW92ZVJlbGF0aXZlVG8sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgaWYgKCFpbXBhY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBwYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IGNsaWVudFNlbGVjdGlvbiA9IGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyKHtcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZSxcbiAgICB2aWV3cG9ydFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgaW1wYWN0LFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsXG4gIH07XG59KTtcblxudmFyIHdoYXRJc0RyYWdnZWRPdmVyID0gKGltcGFjdCA9PiB7XG4gIGNvbnN0IGF0ID0gaW1wYWN0LmF0O1xuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiBhdC5kZXN0aW5hdGlvbi5kcm9wcGFibGVJZDtcbiAgfVxuICByZXR1cm4gYXQuY29tYmluZS5kcm9wcGFibGVJZDtcbn0pO1xuXG5jb25zdCBnZXREcm9wcGFibGVPdmVyJDEgPSAoaW1wYWN0LCBkcm9wcGFibGVzKSA9PiB7XG4gIGNvbnN0IGlkID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcbiAgcmV0dXJuIGlkID8gZHJvcHBhYmxlc1tpZF0gOiBudWxsO1xufTtcbnZhciBtb3ZlSW5EaXJlY3Rpb24gPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgc3RhdGUsXG4gICAgdHlwZVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNBY3R1YWxseU92ZXIgPSBnZXREcm9wcGFibGVPdmVyJDEoc3RhdGUuaW1wYWN0LCBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXMpO1xuICBjb25zdCBpc01haW5BeGlzTW92ZW1lbnRBbGxvd2VkID0gQm9vbGVhbihpc0FjdHVhbGx5T3Zlcik7XG4gIGNvbnN0IGhvbWUgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJvcHBhYmxlLmlkXTtcbiAgY29uc3QgaXNPdmVyID0gaXNBY3R1YWxseU92ZXIgfHwgaG9tZTtcbiAgY29uc3QgZGlyZWN0aW9uID0gaXNPdmVyLmF4aXMuZGlyZWN0aW9uO1xuICBjb25zdCBpc01vdmluZ09uTWFpbkF4aXMgPSBkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgJiYgKHR5cGUgPT09ICdNT1ZFX1VQJyB8fCB0eXBlID09PSAnTU9WRV9ET1dOJykgfHwgZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgKHR5cGUgPT09ICdNT1ZFX0xFRlQnIHx8IHR5cGUgPT09ICdNT1ZFX1JJR0hUJyk7XG4gIGlmIChpc01vdmluZ09uTWFpbkF4aXMgJiYgIWlzTWFpbkF4aXNNb3ZlbWVudEFsbG93ZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpc01vdmluZ0ZvcndhcmQgPSB0eXBlID09PSAnTU9WRV9ET1dOJyB8fCB0eXBlID09PSAnTU9WRV9SSUdIVCc7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIgPSBzdGF0ZS5jdXJyZW50LnBhZ2UuYm9yZGVyQm94Q2VudGVyO1xuICBjb25zdCB7XG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzXG4gIH0gPSBzdGF0ZS5kaW1lbnNpb25zO1xuICByZXR1cm4gaXNNb3ZpbmdPbk1haW5BeGlzID8gbW92ZVRvTmV4dFBsYWNlKHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbjogaXNPdmVyLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIHByZXZpb3VzQ2xpZW50U2VsZWN0aW9uOiBzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb24sXG4gICAgcHJldmlvdXNJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pIDogbW92ZUNyb3NzQXhpcyh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgaXNPdmVyLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KTtcbn0pO1xuXG5mdW5jdGlvbiBpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycgfHwgc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJztcbn1cblxuZnVuY3Rpb24gaXNQb3NpdGlvbkluRnJhbWUoZnJhbWUpIHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gZnVuY3Rpb24gcnVuKHBvaW50KSB7XG4gICAgcmV0dXJuIGlzV2l0aGluVmVydGljYWwocG9pbnQueSkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHBvaW50LngpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRIYXNPdmVybGFwKGZpcnN0LCBzZWNvbmQpIHtcbiAgcmV0dXJuIGZpcnN0LmxlZnQgPCBzZWNvbmQucmlnaHQgJiYgZmlyc3QucmlnaHQgPiBzZWNvbmQubGVmdCAmJiBmaXJzdC50b3AgPCBzZWNvbmQuYm90dG9tICYmIGZpcnN0LmJvdHRvbSA+IHNlY29uZC50b3A7XG59XG5mdW5jdGlvbiBnZXRGdXJ0aGVzdEF3YXkoX3JlZikge1xuICBsZXQge1xuICAgIHBhZ2VCb3JkZXJCb3gsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGNhbmRpZGF0ZXNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHN0YXJ0Q2VudGVyID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgY29uc3Qgc29ydGVkID0gY2FuZGlkYXRlcy5tYXAoY2FuZGlkYXRlID0+IHtcbiAgICBjb25zdCBheGlzID0gY2FuZGlkYXRlLmF4aXM7XG4gICAgY29uc3QgdGFyZ2V0ID0gcGF0Y2goY2FuZGlkYXRlLmF4aXMubGluZSwgcGFnZUJvcmRlckJveC5jZW50ZXJbYXhpcy5saW5lXSwgY2FuZGlkYXRlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltheGlzLmNyb3NzQXhpc0xpbmVdKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGNhbmRpZGF0ZS5kZXNjcmlwdG9yLmlkLFxuICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlKHN0YXJ0Q2VudGVyLCB0YXJnZXQpXG4gICAgfTtcbiAgfSkuc29ydCgoYSwgYikgPT4gYi5kaXN0YW5jZSAtIGEuZGlzdGFuY2UpO1xuICByZXR1cm4gc29ydGVkWzBdID8gc29ydGVkWzBdLmlkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERyb3BwYWJsZU92ZXIoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBwYWdlQm9yZGVyQm94LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGVzXG4gIH0gPSBfcmVmMjtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IHRvRHJvcHBhYmxlTGlzdChkcm9wcGFibGVzKS5maWx0ZXIoaXRlbSA9PiB7XG4gICAgaWYgKCFpdGVtLmlzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmUgPSBpdGVtLnN1YmplY3QuYWN0aXZlO1xuICAgIGlmICghYWN0aXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZ2V0SGFzT3ZlcmxhcChwYWdlQm9yZGVyQm94LCBhY3RpdmUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc1Bvc2l0aW9uSW5GcmFtZShhY3RpdmUpKHBhZ2VCb3JkZXJCb3guY2VudGVyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBpdGVtLmF4aXM7XG4gICAgY29uc3QgY2hpbGRDZW50ZXIgPSBhY3RpdmUuY2VudGVyW2F4aXMuY3Jvc3NBeGlzTGluZV07XG4gICAgY29uc3QgY3Jvc3NBeGlzU3RhcnQgPSBwYWdlQm9yZGVyQm94W2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICAgIGNvbnN0IGNyb3NzQXhpc0VuZCA9IHBhZ2VCb3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNFbmRdO1xuICAgIGNvbnN0IGlzQ29udGFpbmVkID0gaXNXaXRoaW4oYWN0aXZlW2F4aXMuY3Jvc3NBeGlzU3RhcnRdLCBhY3RpdmVbYXhpcy5jcm9zc0F4aXNFbmRdKTtcbiAgICBjb25zdCBpc1N0YXJ0Q29udGFpbmVkID0gaXNDb250YWluZWQoY3Jvc3NBeGlzU3RhcnQpO1xuICAgIGNvbnN0IGlzRW5kQ29udGFpbmVkID0gaXNDb250YWluZWQoY3Jvc3NBeGlzRW5kKTtcbiAgICBpZiAoIWlzU3RhcnRDb250YWluZWQgJiYgIWlzRW5kQ29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzU3RhcnRDb250YWluZWQpIHtcbiAgICAgIHJldHVybiBjcm9zc0F4aXNTdGFydCA8IGNoaWxkQ2VudGVyO1xuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NBeGlzRW5kID4gY2hpbGRDZW50ZXI7XG4gIH0pO1xuICBpZiAoIWNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF0uZGVzY3JpcHRvci5pZDtcbiAgfVxuICByZXR1cm4gZ2V0RnVydGhlc3RBd2F5KHtcbiAgICBwYWdlQm9yZGVyQm94LFxuICAgIGRyYWdnYWJsZSxcbiAgICBjYW5kaWRhdGVzXG4gIH0pO1xufVxuXG5jb25zdCBvZmZzZXRSZWN0QnlQb3NpdGlvbiA9IChyZWN0LCBwb2ludCkgPT4gZ2V0UmVjdChvZmZzZXRCeVBvc2l0aW9uKHJlY3QsIHBvaW50KSk7XG5cbnZhciB3aXRoRHJvcHBhYmxlU2Nyb2xsID0gKChkcm9wcGFibGUsIGFyZWEpID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gYXJlYTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UmVjdEJ5UG9zaXRpb24oYXJlYSwgZnJhbWUuc2Nyb2xsLmRpZmYudmFsdWUpO1xufSk7XG5cbmZ1bmN0aW9uIGdldElzRGlzcGxhY2VkKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBkaXNwbGFjZWQsXG4gICAgaWRcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBCb29sZWFuKGRpc3BsYWNlZC52aXNpYmxlW2lkXSB8fCBkaXNwbGFjZWQuaW52aXNpYmxlW2lkXSk7XG59XG5cbmZ1bmN0aW9uIGF0SW5kZXgoX3JlZikge1xuICBsZXQge1xuICAgIGRyYWdnYWJsZSxcbiAgICBjbG9zZXN0LFxuICAgIGluSG9tZUxpc3RcbiAgfSA9IF9yZWY7XG4gIGlmICghY2xvc2VzdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaW5Ib21lTGlzdCkge1xuICAgIHJldHVybiBjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXg7XG4gIH1cbiAgaWYgKGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleCA+IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmluZGV4KSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleCAtIDE7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleDtcbn1cbnZhciBnZXRSZW9yZGVySW1wYWN0ID0gKF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbDogdGFyZ2V0UmVjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgbGFzdCxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0gPSBfcmVmMjtcbiAgY29uc3QgYXhpcyA9IGRlc3RpbmF0aW9uLmF4aXM7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZWRCeS52YWx1ZTtcbiAgY29uc3QgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W2F4aXMuc3RhcnRdO1xuICBjb25zdCB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W2F4aXMuZW5kXTtcbiAgY29uc3Qgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIGNvbnN0IGNsb3Nlc3QgPSB3aXRob3V0RHJhZ2dpbmcuZmluZChjaGlsZCA9PiB7XG4gICAgY29uc3QgaWQgPSBjaGlsZC5kZXNjcmlwdG9yLmlkO1xuICAgIGNvbnN0IGNoaWxkQ2VudGVyID0gY2hpbGQucGFnZS5ib3JkZXJCb3guY2VudGVyW2F4aXMubGluZV07XG4gICAgY29uc3QgZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoaWQsIGFmdGVyQ3JpdGljYWwpO1xuICAgIGNvbnN0IGlzRGlzcGxhY2VkID0gZ2V0SXNEaXNwbGFjZWQoe1xuICAgICAgZGlzcGxhY2VkOiBsYXN0LFxuICAgICAgaWRcbiAgICB9KTtcbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEpIHtcbiAgICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0RW5kIDw9IGNoaWxkQ2VudGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFN0YXJ0IDwgY2hpbGRDZW50ZXIgLSBkaXNwbGFjZW1lbnQ7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgcmV0dXJuIHRhcmdldEVuZCA8PSBjaGlsZENlbnRlciArIGRpc3BsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFN0YXJ0IDwgY2hpbGRDZW50ZXI7XG4gIH0pIHx8IG51bGw7XG4gIGNvbnN0IG5ld0luZGV4ID0gYXRJbmRleCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGNsb3Nlc3QsXG4gICAgaW5Ib21lTGlzdDogaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbilcbiAgfSk7XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgbGFzdCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBpbmRleDogbmV3SW5kZXhcbiAgfSk7XG59KTtcblxuY29uc3QgY29tYmluZVRocmVzaG9sZERpdmlzb3IgPSA0O1xudmFyIGdldENvbWJpbmVJbXBhY3QgPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgZHJhZ2dhYmxlLFxuICAgIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsOiB0YXJnZXRSZWN0LFxuICAgIHByZXZpb3VzSW1wYWN0LFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSA9IF9yZWY7XG4gIGlmICghZGVzdGluYXRpb24uaXNDb21iaW5lRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGF4aXMgPSBkZXN0aW5hdGlvbi5heGlzO1xuICBjb25zdCBkaXNwbGFjZWRCeSA9IGdldERpc3BsYWNlZEJ5KGRlc3RpbmF0aW9uLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KTtcbiAgY29uc3QgZGlzcGxhY2VtZW50ID0gZGlzcGxhY2VkQnkudmFsdWU7XG4gIGNvbnN0IHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFtheGlzLnN0YXJ0XTtcbiAgY29uc3QgdGFyZ2V0RW5kID0gdGFyZ2V0UmVjdFtheGlzLmVuZF07XG4gIGNvbnN0IHdpdGhvdXREcmFnZ2luZyA9IHJlbW92ZURyYWdnYWJsZUZyb21MaXN0KGRyYWdnYWJsZSwgaW5zaWRlRGVzdGluYXRpb24pO1xuICBjb25zdCBjb21iaW5lV2l0aCA9IHdpdGhvdXREcmFnZ2luZy5maW5kKGNoaWxkID0+IHtcbiAgICBjb25zdCBpZCA9IGNoaWxkLmRlc2NyaXB0b3IuaWQ7XG4gICAgY29uc3QgY2hpbGRSZWN0ID0gY2hpbGQucGFnZS5ib3JkZXJCb3g7XG4gICAgY29uc3QgY2hpbGRTaXplID0gY2hpbGRSZWN0W2F4aXMuc2l6ZV07XG4gICAgY29uc3QgdGhyZXNob2xkID0gY2hpbGRTaXplIC8gY29tYmluZVRocmVzaG9sZERpdmlzb3I7XG4gICAgY29uc3QgZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoaWQsIGFmdGVyQ3JpdGljYWwpO1xuICAgIGNvbnN0IGlzRGlzcGxhY2VkID0gZ2V0SXNEaXNwbGFjZWQoe1xuICAgICAgZGlzcGxhY2VkOiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgICBpZFxuICAgIH0pO1xuICAgIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSkge1xuICAgICAgaWYgKGlzRGlzcGxhY2VkKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRFbmQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gKyB0aHJlc2hvbGQgJiYgdGFyZ2V0RW5kIDwgY2hpbGRSZWN0W2F4aXMuZW5kXSAtIHRocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRTdGFydCA+IGNoaWxkUmVjdFtheGlzLnN0YXJ0XSAtIGRpc3BsYWNlbWVudCArIHRocmVzaG9sZCAmJiB0YXJnZXRTdGFydCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gLSBkaXNwbGFjZW1lbnQgLSB0aHJlc2hvbGQ7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgcmV0dXJuIHRhcmdldEVuZCA+IGNoaWxkUmVjdFtheGlzLnN0YXJ0XSArIGRpc3BsYWNlbWVudCArIHRocmVzaG9sZCAmJiB0YXJnZXRFbmQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdICsgZGlzcGxhY2VtZW50IC0gdGhyZXNob2xkO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gKyB0aHJlc2hvbGQgJiYgdGFyZ2V0U3RhcnQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdIC0gdGhyZXNob2xkO1xuICB9KTtcbiAgaWYgKCFjb21iaW5lV2l0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGltcGFjdCA9IHtcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBkaXNwbGFjZWQ6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ0NPTUJJTkUnLFxuICAgICAgY29tYmluZToge1xuICAgICAgICBkcmFnZ2FibGVJZDogY29tYmluZVdpdGguZGVzY3JpcHRvci5pZCxcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBpbXBhY3Q7XG59KTtcblxudmFyIGdldERyYWdJbXBhY3QgPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgcGFnZU9mZnNldCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzLFxuICAgIHByZXZpb3VzSW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3ggPSBvZmZzZXRSZWN0QnlQb3NpdGlvbihkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3gsIHBhZ2VPZmZzZXQpO1xuICBjb25zdCBkZXN0aW5hdGlvbklkID0gZ2V0RHJvcHBhYmxlT3Zlcih7XG4gICAgcGFnZUJvcmRlckJveCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlc1xuICB9KTtcbiAgaWYgKCFkZXN0aW5hdGlvbklkKSB7XG4gICAgcmV0dXJuIG5vSW1wYWN0JDE7XG4gIH1cbiAgY29uc3QgZGVzdGluYXRpb24gPSBkcm9wcGFibGVzW2Rlc3RpbmF0aW9uSWRdO1xuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsID0gd2l0aERyb3BwYWJsZVNjcm9sbChkZXN0aW5hdGlvbiwgcGFnZUJvcmRlckJveCk7XG4gIHJldHVybiBnZXRDb21iaW5lSW1wYWN0KHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICBkcmFnZ2FibGUsXG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KSB8fCBnZXRSZW9yZGVySW1wYWN0KHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG59KTtcblxudmFyIHBhdGNoRHJvcHBhYmxlTWFwID0gKChkcm9wcGFibGVzLCB1cGRhdGVkKSA9PiAoe1xuICAuLi5kcm9wcGFibGVzLFxuICBbdXBkYXRlZC5kZXNjcmlwdG9yLmlkXTogdXBkYXRlZFxufSkpO1xuXG5jb25zdCBjbGVhclVudXNlZFBsYWNlaG9sZGVyID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgaW1wYWN0LFxuICAgIGRyb3BwYWJsZXNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGxhc3QgPSB3aGF0SXNEcmFnZ2VkT3ZlcihwcmV2aW91c0ltcGFjdCk7XG4gIGNvbnN0IG5vdyA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIGlmICghbGFzdCkge1xuICAgIHJldHVybiBkcm9wcGFibGVzO1xuICB9XG4gIGlmIChsYXN0ID09PSBub3cpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlcztcbiAgfVxuICBjb25zdCBsYXN0RHJvcHBhYmxlID0gZHJvcHBhYmxlc1tsYXN0XTtcbiAgaWYgKCFsYXN0RHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZXM7XG4gIH1cbiAgY29uc3QgdXBkYXRlZCA9IHJlbW92ZVBsYWNlaG9sZGVyKGxhc3REcm9wcGFibGUpO1xuICByZXR1cm4gcGF0Y2hEcm9wcGFibGVNYXAoZHJvcHBhYmxlcywgdXBkYXRlZCk7XG59O1xudmFyIHJlY29tcHV0ZVBsYWNlaG9sZGVycyA9IChfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlcyxcbiAgICBwcmV2aW91c0ltcGFjdCxcbiAgICBpbXBhY3RcbiAgfSA9IF9yZWYyO1xuICBjb25zdCBjbGVhbmVkID0gY2xlYXJVbnVzZWRQbGFjZWhvbGRlcih7XG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgaW1wYWN0LFxuICAgIGRyb3BwYWJsZXNcbiAgfSk7XG4gIGNvbnN0IGlzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIGlmICghaXNPdmVyKSB7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cbiAgY29uc3QgZHJvcHBhYmxlID0gZHJvcHBhYmxlc1tpc092ZXJdO1xuICBpZiAoaXNIb21lT2YoZHJhZ2dhYmxlLCBkcm9wcGFibGUpKSB7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cbiAgaWYgKGRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBjbGVhbmVkO1xuICB9XG4gIGNvbnN0IHBhdGNoZWQgPSBhZGRQbGFjZWhvbGRlcihkcm9wcGFibGUsIGRyYWdnYWJsZSwgZHJhZ2dhYmxlcyk7XG4gIHJldHVybiBwYXRjaERyb3BwYWJsZU1hcChjbGVhbmVkLCBwYXRjaGVkKTtcbn0pO1xuXG52YXIgdXBkYXRlID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHN0YXRlLFxuICAgIGNsaWVudFNlbGVjdGlvbjogZm9yY2VkQ2xpZW50U2VsZWN0aW9uLFxuICAgIGRpbWVuc2lvbnM6IGZvcmNlZERpbWVuc2lvbnMsXG4gICAgdmlld3BvcnQ6IGZvcmNlZFZpZXdwb3J0LFxuICAgIGltcGFjdDogZm9yY2VkSW1wYWN0LFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCB2aWV3cG9ydCA9IGZvcmNlZFZpZXdwb3J0IHx8IHN0YXRlLnZpZXdwb3J0O1xuICBjb25zdCBkaW1lbnNpb25zID0gZm9yY2VkRGltZW5zaW9ucyB8fCBzdGF0ZS5kaW1lbnNpb25zO1xuICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBmb3JjZWRDbGllbnRTZWxlY3Rpb24gfHwgc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uO1xuICBjb25zdCBvZmZzZXQgPSBzdWJ0cmFjdChjbGllbnRTZWxlY3Rpb24sIHN0YXRlLmluaXRpYWwuY2xpZW50LnNlbGVjdGlvbik7XG4gIGNvbnN0IGNsaWVudCA9IHtcbiAgICBvZmZzZXQsXG4gICAgc2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgYm9yZGVyQm94Q2VudGVyOiBhZGQoc3RhdGUuaW5pdGlhbC5jbGllbnQuYm9yZGVyQm94Q2VudGVyLCBvZmZzZXQpXG4gIH07XG4gIGNvbnN0IHBhZ2UgPSB7XG4gICAgc2VsZWN0aW9uOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQpLFxuICAgIGJvcmRlckJveENlbnRlcjogYWRkKGNsaWVudC5ib3JkZXJCb3hDZW50ZXIsIHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50KSxcbiAgICBvZmZzZXQ6IGFkZChjbGllbnQub2Zmc2V0LCB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZSlcbiAgfTtcbiAgY29uc3QgY3VycmVudCA9IHtcbiAgICBjbGllbnQsXG4gICAgcGFnZVxuICB9O1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGN1cnJlbnRcbiAgICB9O1xuICB9XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBuZXdJbXBhY3QgPSBmb3JjZWRJbXBhY3QgfHwgZ2V0RHJhZ0ltcGFjdCh7XG4gICAgcGFnZU9mZnNldDogcGFnZS5vZmZzZXQsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgcHJldmlvdXNJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCB3aXRoVXBkYXRlZFBsYWNlaG9sZGVycyA9IHJlY29tcHV0ZVBsYWNlaG9sZGVycyh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGltcGFjdDogbmV3SW1wYWN0LFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1xuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGN1cnJlbnQsXG4gICAgZGltZW5zaW9uczoge1xuICAgICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlczogd2l0aFVwZGF0ZWRQbGFjZWhvbGRlcnNcbiAgICB9LFxuICAgIGltcGFjdDogbmV3SW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBzY3JvbGxKdW1wUmVxdWVzdCB8fCBudWxsLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogc2Nyb2xsSnVtcFJlcXVlc3QgPyBmYWxzZSA6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5mdW5jdGlvbiBnZXREcmFnZ2FibGVzKGlkcywgZHJhZ2dhYmxlcykge1xuICByZXR1cm4gaWRzLm1hcChpZCA9PiBkcmFnZ2FibGVzW2lkXSk7XG59XG52YXIgcmVjb21wdXRlID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZVxuICB9ID0gX3JlZjtcbiAgY29uc3QgbGFzdCA9IGltcGFjdC5kaXNwbGFjZWQ7XG4gIGNvbnN0IGFmdGVyRHJhZ2dpbmcgPSBnZXREcmFnZ2FibGVzKGxhc3QuYWxsLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgZGlzcGxhY2VkID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgICBsYXN0XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmltcGFjdCxcbiAgICBkaXNwbGFjZWRcbiAgfTtcbn0pO1xuXG52YXIgZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9ID0gX3JlZjtcbiAgY29uc3QgcGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHJldHVybiBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlcih7XG4gICAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgdmlld3BvcnRcbiAgfSk7XG59KTtcblxudmFyIHJlZnJlc2hTbmFwID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHN0YXRlLFxuICAgIGRpbWVuc2lvbnM6IGZvcmNlZERpbWVuc2lvbnMsXG4gICAgdmlld3BvcnQ6IGZvcmNlZFZpZXdwb3J0XG4gIH0gPSBfcmVmO1xuICAhKHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBuZWVkc1Zpc2liaWxpdHlDaGVjayA9IHN0YXRlLmltcGFjdDtcbiAgY29uc3Qgdmlld3BvcnQgPSBmb3JjZWRWaWV3cG9ydCB8fCBzdGF0ZS52aWV3cG9ydDtcbiAgY29uc3QgZGltZW5zaW9ucyA9IGZvcmNlZERpbWVuc2lvbnMgfHwgc3RhdGUuZGltZW5zaW9ucztcbiAgY29uc3Qge1xuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlc1xuICB9ID0gZGltZW5zaW9ucztcbiAgY29uc3QgZHJhZ2dhYmxlID0gZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBpc092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihuZWVkc1Zpc2liaWxpdHlDaGVjayk7XG4gICFpc092ZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IGJlIG92ZXIgYSBkZXN0aW5hdGlvbiBpbiBTTkFQIG1vdmVtZW50IG1vZGUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gZHJvcHBhYmxlc1tpc092ZXJdO1xuICBjb25zdCBpbXBhY3QgPSByZWNvbXB1dGUoe1xuICAgIGltcGFjdDogbmVlZHNWaXNpYmlsaXR5Q2hlY2ssXG4gICAgdmlld3BvcnQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlc1xuICB9KTtcbiAgY29uc3QgY2xpZW50U2VsZWN0aW9uID0gZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyKHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlcyxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xuICByZXR1cm4gdXBkYXRlKHtcbiAgICBpbXBhY3QsXG4gICAgY2xpZW50U2VsZWN0aW9uLFxuICAgIHN0YXRlLFxuICAgIGRpbWVuc2lvbnMsXG4gICAgdmlld3BvcnRcbiAgfSk7XG59KTtcblxudmFyIGdldEhvbWVMb2NhdGlvbiA9IChkZXNjcmlwdG9yID0+ICh7XG4gIGluZGV4OiBkZXNjcmlwdG9yLmluZGV4LFxuICBkcm9wcGFibGVJZDogZGVzY3JpcHRvci5kcm9wcGFibGVJZFxufSkpO1xuXG52YXIgZ2V0TGlmdEVmZmVjdCA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaG9tZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBkaXNwbGFjZWRCeSA9IGdldERpc3BsYWNlZEJ5KGhvbWUuYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICBjb25zdCBpbnNpZGVIb21lID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShob21lLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCByYXdJbmRleCA9IGluc2lkZUhvbWUuaW5kZXhPZihkcmFnZ2FibGUpO1xuICAhKHJhd0luZGV4ICE9PSAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBkcmFnZ2FibGUgdG8gYmUgaW5zaWRlIGhvbWUgbGlzdCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgY29uc3QgYWZ0ZXJEcmFnZ2luZyA9IGluc2lkZUhvbWUuc2xpY2UocmF3SW5kZXggKyAxKTtcbiAgY29uc3QgZWZmZWN0ZWQgPSBhZnRlckRyYWdnaW5nLnJlZHVjZSgocHJldmlvdXMsIGl0ZW0pID0+IHtcbiAgICBwcmV2aW91c1tpdGVtLmRlc2NyaXB0b3IuaWRdID0gdHJ1ZTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH0sIHt9KTtcbiAgY29uc3QgYWZ0ZXJDcml0aWNhbCA9IHtcbiAgICBpblZpcnR1YWxMaXN0OiBob21lLmRlc2NyaXB0b3IubW9kZSA9PT0gJ3ZpcnR1YWwnLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGVmZmVjdGVkXG4gIH07XG4gIGNvbnN0IGRpc3BsYWNlZCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZyxcbiAgICBkZXN0aW5hdGlvbjogaG9tZSxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBsYXN0OiBudWxsLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBpbXBhY3QgPSB7XG4gICAgZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICBkZXN0aW5hdGlvbjogZ2V0SG9tZUxvY2F0aW9uKGRyYWdnYWJsZS5kZXNjcmlwdG9yKVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBpbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9O1xufSk7XG5cbnZhciBwYXRjaERpbWVuc2lvbk1hcCA9ICgoZGltZW5zaW9ucywgdXBkYXRlZCkgPT4gKHtcbiAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICBkcm9wcGFibGVzOiBwYXRjaERyb3BwYWJsZU1hcChkaW1lbnNpb25zLmRyb3BwYWJsZXMsIHVwZGF0ZWQpXG59KSk7XG5cbmNvbnN0IHN0YXJ0ID0ga2V5ID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuY29uc3QgZmluaXNoID0ga2V5ID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuXG52YXIgb2Zmc2V0RHJhZ2dhYmxlID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGRyYWdnYWJsZSxcbiAgICBvZmZzZXQ6IG9mZnNldCQxLFxuICAgIGluaXRpYWxXaW5kb3dTY3JvbGxcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGNsaWVudCA9IG9mZnNldChkcmFnZ2FibGUuY2xpZW50LCBvZmZzZXQkMSk7XG4gIGNvbnN0IHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgaW5pdGlhbFdpbmRvd1Njcm9sbCk7XG4gIGNvbnN0IG1vdmVkID0ge1xuICAgIC4uLmRyYWdnYWJsZSxcbiAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgLi4uZHJhZ2dhYmxlLnBsYWNlaG9sZGVyLFxuICAgICAgY2xpZW50XG4gICAgfSxcbiAgICBjbGllbnQsXG4gICAgcGFnZVxuICB9O1xuICByZXR1cm4gbW92ZWQ7XG59KTtcblxudmFyIGdldEZyYW1lID0gKGRyb3BwYWJsZSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICAhZnJhbWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBEcm9wcGFibGUgdG8gaGF2ZSBhIGZyYW1lJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gZnJhbWU7XG59KTtcblxudmFyIGFkanVzdEFkZGl0aW9uc0ZvclNjcm9sbENoYW5nZXMgPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgYWRkaXRpb25zLFxuICAgIHVwZGF0ZWREcm9wcGFibGVzLFxuICAgIHZpZXdwb3J0XG4gIH0gPSBfcmVmO1xuICBjb25zdCB3aW5kb3dTY3JvbGxDaGFuZ2UgPSB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZTtcbiAgcmV0dXJuIGFkZGl0aW9ucy5tYXAoZHJhZ2dhYmxlID0+IHtcbiAgICBjb25zdCBkcm9wcGFibGVJZCA9IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkO1xuICAgIGNvbnN0IG1vZGlmaWVkID0gdXBkYXRlZERyb3BwYWJsZXNbZHJvcHBhYmxlSWRdO1xuICAgIGNvbnN0IGZyYW1lID0gZ2V0RnJhbWUobW9kaWZpZWQpO1xuICAgIGNvbnN0IGRyb3BwYWJsZVNjcm9sbENoYW5nZSA9IGZyYW1lLnNjcm9sbC5kaWZmLnZhbHVlO1xuICAgIGNvbnN0IHRvdGFsQ2hhbmdlID0gYWRkKHdpbmRvd1Njcm9sbENoYW5nZSwgZHJvcHBhYmxlU2Nyb2xsQ2hhbmdlKTtcbiAgICBjb25zdCBtb3ZlZCA9IG9mZnNldERyYWdnYWJsZSh7XG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBvZmZzZXQ6IHRvdGFsQ2hhbmdlLFxuICAgICAgaW5pdGlhbFdpbmRvd1Njcm9sbDogdmlld3BvcnQuc2Nyb2xsLmluaXRpYWxcbiAgICB9KTtcbiAgICByZXR1cm4gbW92ZWQ7XG4gIH0pO1xufSk7XG5cbmNvbnN0IHRpbWluZ3NLZXkgPSAnUHJvY2Vzc2luZyBkeW5hbWljIGNoYW5nZXMnO1xudmFyIHB1Ymxpc2hXaGlsZURyYWdnaW5nSW5WaXJ0dWFsID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHN0YXRlLFxuICAgIHB1Ymxpc2hlZFxuICB9ID0gX3JlZjtcbiAgc3RhcnQodGltaW5nc0tleSk7XG4gIGNvbnN0IHdpdGhTY3JvbGxDaGFuZ2UgPSBwdWJsaXNoZWQubW9kaWZpZWQubWFwKHVwZGF0ZSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbdXBkYXRlLmRyb3BwYWJsZUlkXTtcbiAgICBjb25zdCBzY3JvbGxlZCA9IHNjcm9sbERyb3BwYWJsZShleGlzdGluZywgdXBkYXRlLnNjcm9sbCk7XG4gICAgcmV0dXJuIHNjcm9sbGVkO1xuICB9KTtcbiAgY29uc3QgZHJvcHBhYmxlcyA9IHtcbiAgICAuLi5zdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgLi4udG9Ecm9wcGFibGVNYXAod2l0aFNjcm9sbENoYW5nZSlcbiAgfTtcbiAgY29uc3QgdXBkYXRlZEFkZGl0aW9ucyA9IHRvRHJhZ2dhYmxlTWFwKGFkanVzdEFkZGl0aW9uc0ZvclNjcm9sbENoYW5nZXMoe1xuICAgIGFkZGl0aW9uczogcHVibGlzaGVkLmFkZGl0aW9ucyxcbiAgICB1cGRhdGVkRHJvcHBhYmxlczogZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnRcbiAgfSkpO1xuICBjb25zdCBkcmFnZ2FibGVzID0ge1xuICAgIC4uLnN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICAuLi51cGRhdGVkQWRkaXRpb25zXG4gIH07XG4gIHB1Ymxpc2hlZC5yZW1vdmFscy5mb3JFYWNoKGlkID0+IHtcbiAgICBkZWxldGUgZHJhZ2dhYmxlc1tpZF07XG4gIH0pO1xuICBjb25zdCBkaW1lbnNpb25zID0ge1xuICAgIGRyb3BwYWJsZXMsXG4gICAgZHJhZ2dhYmxlc1xuICB9O1xuICBjb25zdCB3YXNPdmVySWQgPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICBjb25zdCB3YXNPdmVyID0gd2FzT3ZlcklkID8gZGltZW5zaW9ucy5kcm9wcGFibGVzW3dhc092ZXJJZF0gOiBudWxsO1xuICBjb25zdCBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3QgaG9tZSA9IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcm9wcGFibGUuaWRdO1xuICBjb25zdCB7XG4gICAgaW1wYWN0OiBvbkxpZnRJbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9ID0gZ2V0TGlmdEVmZmVjdCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGhvbWUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnRcbiAgfSk7XG4gIGNvbnN0IHByZXZpb3VzSW1wYWN0ID0gd2FzT3ZlciAmJiB3YXNPdmVyLmlzQ29tYmluZUVuYWJsZWQgPyBzdGF0ZS5pbXBhY3QgOiBvbkxpZnRJbXBhY3Q7XG4gIGNvbnN0IGltcGFjdCA9IGdldERyYWdJbXBhY3Qoe1xuICAgIHBhZ2VPZmZzZXQ6IHN0YXRlLmN1cnJlbnQucGFnZS5vZmZzZXQsXG4gICAgZHJhZ2dhYmxlOiBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXSxcbiAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlczogZGltZW5zaW9ucy5kcm9wcGFibGVzLFxuICAgIHByZXZpb3VzSW1wYWN0LFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBmaW5pc2godGltaW5nc0tleSk7XG4gIGNvbnN0IGRyYWdnaW5nU3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgcGhhc2U6ICdEUkFHR0lORycsXG4gICAgaW1wYWN0LFxuICAgIG9uTGlmdEltcGFjdCxcbiAgICBkaW1lbnNpb25zLFxuICAgIGFmdGVyQ3JpdGljYWwsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9O1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgIHJldHVybiBkcmFnZ2luZ1N0YXRlO1xuICB9XG4gIGNvbnN0IGRyb3BQZW5kaW5nID0ge1xuICAgIC4uLmRyYWdnaW5nU3RhdGUsXG4gICAgcGhhc2U6ICdEUk9QX1BFTkRJTkcnLFxuICAgIHJlYXNvbjogc3RhdGUucmVhc29uLFxuICAgIGlzV2FpdGluZzogZmFsc2VcbiAgfTtcbiAgcmV0dXJuIGRyb3BQZW5kaW5nO1xufSk7XG5cbmNvbnN0IGlzU25hcHBpbmcgPSBzdGF0ZSA9PiBzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdTTkFQJztcbmNvbnN0IHBvc3REcm9wcGFibGVDaGFuZ2UgPSAoc3RhdGUsIHVwZGF0ZWQsIGlzRW5hYmxlZENoYW5naW5nKSA9PiB7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBwYXRjaERpbWVuc2lvbk1hcChzdGF0ZS5kaW1lbnNpb25zLCB1cGRhdGVkKTtcbiAgaWYgKCFpc1NuYXBwaW5nKHN0YXRlKSB8fCBpc0VuYWJsZWRDaGFuZ2luZykge1xuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICBkaW1lbnNpb25zXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZnJlc2hTbmFwKHtcbiAgICBzdGF0ZSxcbiAgICBkaW1lbnNpb25zXG4gIH0pO1xufTtcbmZ1bmN0aW9uIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5pc0RyYWdnaW5nICYmIHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IGlkbGUkMiA9IHtcbiAgcGhhc2U6ICdJRExFJyxcbiAgY29tcGxldGVkOiBudWxsLFxuICBzaG91bGRGbHVzaDogZmFsc2Vcbn07XG52YXIgcmVkdWNlciA9IChmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgIHN0YXRlID0gaWRsZSQyO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pZGxlJDIsXG4gICAgICBzaG91bGRGbHVzaDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTklUSUFMX1BVQkxJU0ggbXVzdCBjb21lIGFmdGVyIGEgSURMRSBwaGFzZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBjcml0aWNhbCxcbiAgICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIG1vdmVtZW50TW9kZVxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgICBjb25zdCBob21lID0gZGltZW5zaW9ucy5kcm9wcGFibGVzW2NyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gICAgY29uc3QgY2xpZW50ID0ge1xuICAgICAgc2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBib3JkZXJCb3hDZW50ZXI6IGRyYWdnYWJsZS5jbGllbnQuYm9yZGVyQm94LmNlbnRlcixcbiAgICAgIG9mZnNldDogb3JpZ2luXG4gICAgfTtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgY2xpZW50LFxuICAgICAgcGFnZToge1xuICAgICAgICBzZWxlY3Rpb246IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCksXG4gICAgICAgIGJvcmRlckJveENlbnRlcjogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsKSxcbiAgICAgICAgb2Zmc2V0OiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmRpZmYudmFsdWUpXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1dpbmRvd1Njcm9sbEFsbG93ZWQgPSB0b0Ryb3BwYWJsZUxpc3QoZGltZW5zaW9ucy5kcm9wcGFibGVzKS5ldmVyeShpdGVtID0+ICFpdGVtLmlzRml4ZWRPblBhZ2UpO1xuICAgIGNvbnN0IHtcbiAgICAgIGltcGFjdCxcbiAgICAgIGFmdGVyQ3JpdGljYWxcbiAgICB9ID0gZ2V0TGlmdEVmZmVjdCh7XG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBob21lLFxuICAgICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgdmlld3BvcnRcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwaGFzZTogJ0RSQUdHSU5HJyxcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWUsXG4gICAgICBjcml0aWNhbCxcbiAgICAgIG1vdmVtZW50TW9kZSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICBpbml0aWFsLFxuICAgICAgY3VycmVudDogaW5pdGlhbCxcbiAgICAgIGlzV2luZG93U2Nyb2xsQWxsb3dlZCxcbiAgICAgIGltcGFjdCxcbiAgICAgIGFmdGVyQ3JpdGljYWwsXG4gICAgICBvbkxpZnRJbXBhY3Q6IGltcGFjdCxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGwsXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGU6IG51bGxcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnQ09MTEVDVElPTl9TVEFSVElORycpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDb2xsZWN0aW9uIGNhbm5vdCBzdGFydCBmcm9tIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcGhhc2U6ICdDT0xMRUNUSU5HJ1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdQVUJMSVNIX1dISUxFX0RSQUdHSU5HJykge1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVW5leHBlY3RlZCAke2FjdGlvbi50eXBlfSByZWNlaXZlZCBpbiBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gcHVibGlzaFdoaWxlRHJhZ2dpbmdJblZpcnR1YWwoe1xuICAgICAgc3RhdGUsXG4gICAgICBwdWJsaXNoZWQ6IGFjdGlvbi5wYXlsb2FkXG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnTU9WRScpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke2FjdGlvbi50eXBlfSBub3QgcGVybWl0dGVkIGluIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGNsaWVudDogY2xpZW50U2VsZWN0aW9uXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGlmIChpc0VxdWFsJDEoY2xpZW50U2VsZWN0aW9uLCBzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBpbXBhY3Q6IGlzU25hcHBpbmcoc3RhdGUpID8gc3RhdGUuaW1wYWN0IDogbnVsbFxuICAgIH0pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9EUk9QUEFCTEVfU0NST0xMJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHthY3Rpb24udHlwZX0gbm90IHBlcm1pdHRlZCBpbiBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIG5ld1Njcm9sbFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCB0YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbaWRdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IHNjcm9sbGVkID0gc2Nyb2xsRHJvcHBhYmxlKHRhcmdldCwgbmV3U2Nyb2xsKTtcbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgc2Nyb2xsZWQsIGZhbHNlKTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfRFJPUFBBQkxFX0lTX0VOQUJMRUQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQXR0ZW1wdGluZyB0byBtb3ZlIGluIGFuIHVuc3VwcG9ydGVkIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgaXNFbmFibGVkXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IHRhcmdldCA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tpZF07XG4gICAgIXRhcmdldCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBmaW5kIERyb3BwYWJsZVtpZDogJHtpZH1dIHRvIHRvZ2dsZSBpdHMgZW5hYmxlZCBzdGF0ZWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHRhcmdldC5pc0VuYWJsZWQgIT09IGlzRW5hYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBUcnlpbmcgdG8gc2V0IGRyb3BwYWJsZSBpc0VuYWJsZWQgdG8gJHtTdHJpbmcoaXNFbmFibGVkKX1cbiAgICAgIGJ1dCBpdCBpcyBhbHJlYWR5ICR7U3RyaW5nKHRhcmdldC5pc0VuYWJsZWQpfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCB1cGRhdGVkID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgaXNFbmFibGVkXG4gICAgfTtcbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgdXBkYXRlZCwgdHJ1ZSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX0RST1BQQUJMRV9JU19DT01CSU5FX0VOQUJMRUQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQXR0ZW1wdGluZyB0byBtb3ZlIGluIGFuIHVuc3VwcG9ydGVkIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgaXNDb21iaW5lRW5hYmxlZFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCB0YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbaWRdO1xuICAgICF0YXJnZXQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBEcm9wcGFibGVbaWQ6ICR7aWR9XSB0byB0b2dnbGUgaXRzIGlzQ29tYmluZUVuYWJsZWQgc3RhdGVgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISh0YXJnZXQuaXNDb21iaW5lRW5hYmxlZCAhPT0gaXNDb21iaW5lRW5hYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBUcnlpbmcgdG8gc2V0IGRyb3BwYWJsZSBpc0NvbWJpbmVFbmFibGVkIHRvICR7U3RyaW5nKGlzQ29tYmluZUVuYWJsZWQpfVxuICAgICAgYnV0IGl0IGlzIGFscmVhZHkgJHtTdHJpbmcodGFyZ2V0LmlzQ29tYmluZUVuYWJsZWQpfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCB1cGRhdGVkID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgaXNDb21iaW5lRW5hYmxlZFxuICAgIH07XG4gICAgcmV0dXJuIHBvc3REcm9wcGFibGVDaGFuZ2Uoc3RhdGUsIHVwZGF0ZWQsIHRydWUpO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkVfQllfV0lORE9XX1NDUk9MTCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgbW92ZSBieSB3aW5kb3cgaW4gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIXN0YXRlLmlzV2luZG93U2Nyb2xsQWxsb3dlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1dpbmRvdyBzY3JvbGxpbmcgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgZm9yIGZpeGVkIGxpc3RzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IG5ld1Njcm9sbCA9IGFjdGlvbi5wYXlsb2FkLm5ld1Njcm9sbDtcbiAgICBpZiAoaXNFcXVhbCQxKHN0YXRlLnZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LCBuZXdTY3JvbGwpKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCB2aWV3cG9ydCA9IHNjcm9sbFZpZXdwb3J0KHN0YXRlLnZpZXdwb3J0LCBuZXdTY3JvbGwpO1xuICAgIGlmIChpc1NuYXBwaW5nKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHJlZnJlc2hTbmFwKHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHZpZXdwb3J0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIHZpZXdwb3J0XG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX1ZJRVdQT1JUX01BWF9TQ1JPTEwnKSB7XG4gICAgaWYgKCFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3QgbWF4U2Nyb2xsID0gYWN0aW9uLnBheWxvYWQubWF4U2Nyb2xsO1xuICAgIGlmIChpc0VxdWFsJDEobWF4U2Nyb2xsLCBzdGF0ZS52aWV3cG9ydC5zY3JvbGwubWF4KSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCB3aXRoTWF4U2Nyb2xsID0ge1xuICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICBzY3JvbGw6IHtcbiAgICAgICAgLi4uc3RhdGUudmlld3BvcnQuc2Nyb2xsLFxuICAgICAgICBtYXg6IG1heFNjcm9sbFxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgdmlld3BvcnQ6IHdpdGhNYXhTY3JvbGxcbiAgICB9O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkVfVVAnIHx8IGFjdGlvbi50eXBlID09PSAnTU9WRV9ET1dOJyB8fCBhY3Rpb24udHlwZSA9PT0gJ01PVkVfTEVGVCcgfHwgYWN0aW9uLnR5cGUgPT09ICdNT1ZFX1JJR0hUJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYCR7YWN0aW9uLnR5cGV9IHJlY2VpdmVkIHdoaWxlIG5vdCBpbiBEUkFHR0lORyBwaGFzZWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCByZXN1bHQgPSBtb3ZlSW5EaXJlY3Rpb24oe1xuICAgICAgc3RhdGUsXG4gICAgICB0eXBlOiBhY3Rpb24udHlwZVxuICAgIH0pO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICBpbXBhY3Q6IHJlc3VsdC5pbXBhY3QsXG4gICAgICBjbGllbnRTZWxlY3Rpb246IHJlc3VsdC5jbGllbnRTZWxlY3Rpb24sXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogcmVzdWx0LnNjcm9sbEp1bXBSZXF1ZXN0XG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgIGNvbnN0IHJlYXNvbiA9IGFjdGlvbi5wYXlsb2FkLnJlYXNvbjtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgbW92ZSBpbnRvIHRoZSBEUk9QX1BFTkRJTkcgcGhhc2UgZnJvbSB0aGUgQ09MTEVDVElORyBwaGFzZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcGhhc2U6ICdEUk9QX1BFTkRJTkcnLFxuICAgICAgaXNXYWl0aW5nOiB0cnVlLFxuICAgICAgcmVhc29uXG4gICAgfTtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXBsZXRlZCxcbiAgICAgIGRyb3BEdXJhdGlvbixcbiAgICAgIG5ld0hvbWVDbGllbnRPZmZzZXRcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGFuaW1hdGUgZHJvcCBmcm9tIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHBoYXNlOiAnRFJPUF9BTklNQVRJTkcnLFxuICAgICAgY29tcGxldGVkLFxuICAgICAgZHJvcER1cmF0aW9uLFxuICAgICAgbmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgIGRpbWVuc2lvbnM6IHN0YXRlLmRpbWVuc2lvbnNcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21wbGV0ZWRcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBoYXNlOiAnSURMRScsXG4gICAgICBjb21wbGV0ZWQsXG4gICAgICBzaG91bGRGbHVzaDogZmFsc2VcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn0pO1xuXG5jb25zdCBiZWZvcmVJbml0aWFsQ2FwdHVyZSA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0JFRk9SRV9JTklUSUFMX0NBUFRVUkUnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGxpZnQkMSA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0xJRlQnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGluaXRpYWxQdWJsaXNoID0gYXJncyA9PiAoe1xuICB0eXBlOiAnSU5JVElBTF9QVUJMSVNIJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBwdWJsaXNoV2hpbGVEcmFnZ2luZyA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGNvbGxlY3Rpb25TdGFydGluZyA9ICgpID0+ICh7XG4gIHR5cGU6ICdDT0xMRUNUSU9OX1NUQVJUSU5HJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCB1cGRhdGVEcm9wcGFibGVTY3JvbGwgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdVUERBVEVfRFJPUFBBQkxFX1NDUk9MTCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9JU19FTkFCTEVEJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9JU19DT01CSU5FX0VOQUJMRUQnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IG1vdmUgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdNT1ZFJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBtb3ZlQnlXaW5kb3dTY3JvbGwgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdNT1ZFX0JZX1dJTkRPV19TQ1JPTEwnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX1ZJRVdQT1JUX01BWF9TQ1JPTEwnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IG1vdmVVcCA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX1VQJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBtb3ZlRG93biA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX0RPV04nLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IG1vdmVSaWdodCA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX1JJR0hUJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBtb3ZlTGVmdCA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX0xFRlQnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IGZsdXNoID0gKCkgPT4gKHtcbiAgdHlwZTogJ0ZMVVNIJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBhbmltYXRlRHJvcCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0RST1BfQU5JTUFURScsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgY29tcGxldGVEcm9wID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUF9DT01QTEVURScsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgZHJvcCQxID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgZHJvcFBlbmRpbmcgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdEUk9QX1BFTkRJTkcnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGRyb3BBbmltYXRpb25GaW5pc2hlZCA9ICgpID0+ICh7XG4gIHR5cGU6ICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuXG5mdW5jdGlvbiBjaGVja0luZGV4ZXMoaW5zaWRlRGVzdGluYXRpb24pIHtcbiAgaWYgKGluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGluZGV4ZXMgPSBpbnNpZGVEZXN0aW5hdGlvbi5tYXAoZCA9PiBkLmRlc2NyaXB0b3IuaW5kZXgpO1xuICBjb25zdCBlcnJvcnMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudCA9IGluZGV4ZXNbaV07XG4gICAgY29uc3QgcHJldmlvdXMgPSBpbmRleGVzW2kgLSAxXTtcbiAgICBpZiAoY3VycmVudCAhPT0gcHJldmlvdXMgKyAxKSB7XG4gICAgICBlcnJvcnNbY3VycmVudF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoIU9iamVjdC5rZXlzKGVycm9ycykubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGluZGV4ZXMubWFwKGluZGV4ID0+IHtcbiAgICBjb25zdCBoYXNFcnJvciA9IEJvb2xlYW4oZXJyb3JzW2luZGV4XSk7XG4gICAgcmV0dXJuIGhhc0Vycm9yID8gYFvwn5SlJHtpbmRleH1dYCA6IGAke2luZGV4fWA7XG4gIH0pLmpvaW4oJywgJyk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIERldGVjdGVkIG5vbi1jb25zZWN1dGl2ZSA8RHJhZ2dhYmxlIC8+IGluZGV4ZXMuXG5cbiAgICAoVGhpcyBjYW4gY2F1c2UgdW5leHBlY3RlZCBidWdzKVxuXG4gICAgJHtmb3JtYXR0ZWR9XG4gIGApIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVEaW1lbnNpb25zKGNyaXRpY2FsLCBkaW1lbnNpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGNyaXRpY2FsLmRyb3BwYWJsZS5pZCwgZGltZW5zaW9ucy5kcmFnZ2FibGVzKTtcbiAgICBjaGVja0luZGV4ZXMoaW5zaWRlRGVzdGluYXRpb24pO1xuICB9XG59XG5cbnZhciBsaWZ0ID0gKG1hcnNoYWwgPT4gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgZ2V0U3RhdGUsXG4gICAgZGlzcGF0Y2hcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGFjdGlvbi50eXBlICE9PSAnTElGVCcpIHtcbiAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBtb3ZlbWVudE1vZGVcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgY29uc3QgaW5pdGlhbCA9IGdldFN0YXRlKCk7XG4gICAgaWYgKGluaXRpYWwucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIGRpc3BhdGNoKGNvbXBsZXRlRHJvcCh7XG4gICAgICAgIGNvbXBsZXRlZDogaW5pdGlhbC5jb21wbGV0ZWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgIShnZXRTdGF0ZSgpLnBoYXNlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBwaGFzZSB0byBzdGFydCBhIGRyYWcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgZGlzcGF0Y2goZmx1c2goKSk7XG4gICAgZGlzcGF0Y2goYmVmb3JlSW5pdGlhbENhcHR1cmUoe1xuICAgICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgICAgbW92ZW1lbnRNb2RlXG4gICAgfSkpO1xuICAgIGNvbnN0IHNjcm9sbE9wdGlvbnMgPSB7XG4gICAgICBzaG91bGRQdWJsaXNoSW1tZWRpYXRlbHk6IG1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnXG4gICAgfTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgICAgc2Nyb2xsT3B0aW9uc1xuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgY3JpdGljYWwsXG4gICAgICBkaW1lbnNpb25zLFxuICAgICAgdmlld3BvcnRcbiAgICB9ID0gbWFyc2hhbC5zdGFydFB1Ymxpc2hpbmcocmVxdWVzdCk7XG4gICAgdmFsaWRhdGVEaW1lbnNpb25zKGNyaXRpY2FsLCBkaW1lbnNpb25zKTtcbiAgICBkaXNwYXRjaChpbml0aWFsUHVibGlzaCh7XG4gICAgICBjcml0aWNhbCxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBtb3ZlbWVudE1vZGUsXG4gICAgICB2aWV3cG9ydFxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG52YXIgc3R5bGUgPSAobWFyc2hhbCA9PiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICBtYXJzaGFsLmRyYWdnaW5nKCk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJykge1xuICAgIG1hcnNoYWwuZHJvcHBpbmcoYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdC5yZWFzb24pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnKSB7XG4gICAgbWFyc2hhbC5yZXN0aW5nKCk7XG4gIH1cbiAgbmV4dChhY3Rpb24pO1xufSk7XG5cbmNvbnN0IGN1cnZlcyA9IHtcbiAgb3V0T2ZUaGVXYXk6ICdjdWJpYy1iZXppZXIoMC4yLCAwLCAwLCAxKScsXG4gIGRyb3A6ICdjdWJpYy1iZXppZXIoLjIsMSwuMSwxKSdcbn07XG5jb25zdCBjb21iaW5lID0ge1xuICBvcGFjaXR5OiB7XG4gICAgZHJvcDogMCxcbiAgICBjb21iaW5pbmc6IDAuN1xuICB9LFxuICBzY2FsZToge1xuICAgIGRyb3A6IDAuNzVcbiAgfVxufTtcbmNvbnN0IHRpbWluZ3MgPSB7XG4gIG91dE9mVGhlV2F5OiAwLjIsXG4gIG1pbkRyb3BUaW1lOiAwLjMzLFxuICBtYXhEcm9wVGltZTogMC41NVxufTtcbmNvbnN0IG91dE9mVGhlV2F5VGltaW5nID0gYCR7dGltaW5ncy5vdXRPZlRoZVdheX1zICR7Y3VydmVzLm91dE9mVGhlV2F5fWA7XG5jb25zdCB0cmFuc2l0aW9ucyA9IHtcbiAgZmx1aWQ6IGBvcGFjaXR5ICR7b3V0T2ZUaGVXYXlUaW1pbmd9YCxcbiAgc25hcDogYHRyYW5zZm9ybSAke291dE9mVGhlV2F5VGltaW5nfSwgb3BhY2l0eSAke291dE9mVGhlV2F5VGltaW5nfWAsXG4gIGRyb3A6IGR1cmF0aW9uID0+IHtcbiAgICBjb25zdCB0aW1pbmcgPSBgJHtkdXJhdGlvbn1zICR7Y3VydmVzLmRyb3B9YDtcbiAgICByZXR1cm4gYHRyYW5zZm9ybSAke3RpbWluZ30sIG9wYWNpdHkgJHt0aW1pbmd9YDtcbiAgfSxcbiAgb3V0T2ZUaGVXYXk6IGB0cmFuc2Zvcm0gJHtvdXRPZlRoZVdheVRpbWluZ31gLFxuICBwbGFjZWhvbGRlcjogYGhlaWdodCAke291dE9mVGhlV2F5VGltaW5nfSwgd2lkdGggJHtvdXRPZlRoZVdheVRpbWluZ30sIG1hcmdpbiAke291dE9mVGhlV2F5VGltaW5nfWBcbn07XG5jb25zdCBtb3ZlVG8gPSBvZmZzZXQgPT4gaXNFcXVhbCQxKG9mZnNldCwgb3JpZ2luKSA/IHVuZGVmaW5lZCA6IGB0cmFuc2xhdGUoJHtvZmZzZXQueH1weCwgJHtvZmZzZXQueX1weClgO1xuY29uc3QgdHJhbnNmb3JtcyA9IHtcbiAgbW92ZVRvLFxuICBkcm9wOiAob2Zmc2V0LCBpc0NvbWJpbmluZykgPT4ge1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IG1vdmVUbyhvZmZzZXQpO1xuICAgIGlmICghdHJhbnNsYXRlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWlzQ29tYmluaW5nKSB7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dHJhbnNsYXRlfSBzY2FsZSgke2NvbWJpbmUuc2NhbGUuZHJvcH0pYDtcbiAgfVxufTtcblxuY29uc3Qge1xuICBtaW5Ecm9wVGltZSxcbiAgbWF4RHJvcFRpbWVcbn0gPSB0aW1pbmdzO1xuY29uc3QgZHJvcFRpbWVSYW5nZSA9IG1heERyb3BUaW1lIC0gbWluRHJvcFRpbWU7XG5jb25zdCBtYXhEcm9wVGltZUF0RGlzdGFuY2UgPSAxNTAwO1xuY29uc3QgY2FuY2VsRHJvcE1vZGlmaWVyID0gMC42O1xudmFyIGdldERyb3BEdXJhdGlvbiA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjdXJyZW50LFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHJlYXNvblxuICB9ID0gX3JlZjtcbiAgY29uc3QgZGlzdGFuY2UkMSA9IGRpc3RhbmNlKGN1cnJlbnQsIGRlc3RpbmF0aW9uKTtcbiAgaWYgKGRpc3RhbmNlJDEgPD0gMCkge1xuICAgIHJldHVybiBtaW5Ecm9wVGltZTtcbiAgfVxuICBpZiAoZGlzdGFuY2UkMSA+PSBtYXhEcm9wVGltZUF0RGlzdGFuY2UpIHtcbiAgICByZXR1cm4gbWF4RHJvcFRpbWU7XG4gIH1cbiAgY29uc3QgcGVyY2VudGFnZSA9IGRpc3RhbmNlJDEgLyBtYXhEcm9wVGltZUF0RGlzdGFuY2U7XG4gIGNvbnN0IGR1cmF0aW9uID0gbWluRHJvcFRpbWUgKyBkcm9wVGltZVJhbmdlICogcGVyY2VudGFnZTtcbiAgY29uc3Qgd2l0aER1cmF0aW9uID0gcmVhc29uID09PSAnQ0FOQ0VMJyA/IGR1cmF0aW9uICogY2FuY2VsRHJvcE1vZGlmaWVyIDogZHVyYXRpb247XG4gIHJldHVybiBOdW1iZXIod2l0aER1cmF0aW9uLnRvRml4ZWQoMikpO1xufSk7XG5cbnZhciBnZXROZXdIb21lQ2xpZW50T2Zmc2V0ID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGltZW5zaW9ucyxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzXG4gIH0gPSBkaW1lbnNpb25zO1xuICBjb25zdCBkcm9wcGFibGVJZCA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gZHJvcHBhYmxlSWQgPyBkcm9wcGFibGVzW2Ryb3BwYWJsZUlkXSA6IG51bGw7XG4gIGNvbnN0IGhvbWUgPSBkcm9wcGFibGVzW2RyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkXTtcbiAgY29uc3QgbmV3Q2xpZW50Q2VudGVyID0gZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyKHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbCxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uIHx8IGhvbWUsXG4gICAgdmlld3BvcnRcbiAgfSk7XG4gIGNvbnN0IG9mZnNldCA9IHN1YnRyYWN0KG5ld0NsaWVudENlbnRlciwgZHJhZ2dhYmxlLmNsaWVudC5ib3JkZXJCb3guY2VudGVyKTtcbiAgcmV0dXJuIG9mZnNldDtcbn0pO1xuXG52YXIgZ2V0RHJvcEltcGFjdCA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBkcmFnZ2FibGVzLFxuICAgIHJlYXNvbixcbiAgICBsYXN0SW1wYWN0LFxuICAgIGhvbWUsXG4gICAgdmlld3BvcnQsXG4gICAgb25MaWZ0SW1wYWN0XG4gIH0gPSBfcmVmO1xuICBpZiAoIWxhc3RJbXBhY3QuYXQgfHwgcmVhc29uICE9PSAnRFJPUCcpIHtcbiAgICBjb25zdCByZWNvbXB1dGVkSG9tZUltcGFjdCA9IHJlY29tcHV0ZSh7XG4gICAgICBkcmFnZ2FibGVzLFxuICAgICAgaW1wYWN0OiBvbkxpZnRJbXBhY3QsXG4gICAgICBkZXN0aW5hdGlvbjogaG9tZSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGltcGFjdDogcmVjb21wdXRlZEhvbWVJbXBhY3QsXG4gICAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgaWYgKGxhc3RJbXBhY3QuYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGltcGFjdDogbGFzdEltcGFjdCxcbiAgICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGU6IHRydWVcbiAgICB9O1xuICB9XG4gIGNvbnN0IHdpdGhvdXRNb3ZlbWVudCA9IHtcbiAgICAuLi5sYXN0SW1wYWN0LFxuICAgIGRpc3BsYWNlZDogZW1wdHlHcm91cHNcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBpbXBhY3Q6IHdpdGhvdXRNb3ZlbWVudCxcbiAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlOiB0cnVlXG4gIH07XG59KTtcblxuY29uc3QgZHJvcE1pZGRsZXdhcmUgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBnZXRTdGF0ZSxcbiAgICBkaXNwYXRjaFxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgIT09ICdEUk9QJykge1xuICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgcmVhc29uID0gYWN0aW9uLnBheWxvYWQucmVhc29uO1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgICBkaXNwYXRjaChkcm9wUGVuZGluZyh7XG4gICAgICAgIHJlYXNvblxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc1dhaXRpbmdGb3JEcm9wID0gc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnICYmIHN0YXRlLmlzV2FpdGluZztcbiAgICAhIWlzV2FpdGluZ0ZvckRyb3AgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdBIERST1AgYWN0aW9uIG9jY3VycmVkIHdoaWxlIERST1BfUEVORElORyBhbmQgc3RpbGwgd2FpdGluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZHJvcCBpbiBwaGFzZTogJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgY3JpdGljYWwgPSBzdGF0ZS5jcml0aWNhbDtcbiAgICBjb25zdCBkaW1lbnNpb25zID0gc3RhdGUuZGltZW5zaW9ucztcbiAgICBjb25zdCBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgICBjb25zdCB7XG4gICAgICBpbXBhY3QsXG4gICAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlXG4gICAgfSA9IGdldERyb3BJbXBhY3Qoe1xuICAgICAgcmVhc29uLFxuICAgICAgbGFzdEltcGFjdDogc3RhdGUuaW1wYWN0LFxuICAgICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbCxcbiAgICAgIG9uTGlmdEltcGFjdDogc3RhdGUub25MaWZ0SW1wYWN0LFxuICAgICAgaG9tZTogc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF0sXG4gICAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgICBkcmFnZ2FibGVzOiBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNcbiAgICB9KTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IGRpZERyb3BJbnNpZGVEcm9wcGFibGUgPyB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpIDogbnVsbDtcbiAgICBjb25zdCBjb21iaW5lID0gZGlkRHJvcEluc2lkZURyb3BwYWJsZSA/IHRyeUdldENvbWJpbmUoaW1wYWN0KSA6IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0ge1xuICAgICAgaW5kZXg6IGNyaXRpY2FsLmRyYWdnYWJsZS5pbmRleCxcbiAgICAgIGRyb3BwYWJsZUlkOiBjcml0aWNhbC5kcm9wcGFibGUuaWRcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCxcbiAgICAgIHR5cGU6IGRyYWdnYWJsZS5kZXNjcmlwdG9yLnR5cGUsXG4gICAgICBzb3VyY2UsXG4gICAgICByZWFzb24sXG4gICAgICBtb2RlOiBzdGF0ZS5tb3ZlbWVudE1vZGUsXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIGNvbWJpbmVcbiAgICB9O1xuICAgIGNvbnN0IG5ld0hvbWVDbGllbnRPZmZzZXQgPSBnZXROZXdIb21lQ2xpZW50T2Zmc2V0KHtcbiAgICAgIGltcGFjdCxcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gICAgfSk7XG4gICAgY29uc3QgY29tcGxldGVkID0ge1xuICAgICAgY3JpdGljYWw6IHN0YXRlLmNyaXRpY2FsLFxuICAgICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIGltcGFjdFxuICAgIH07XG4gICAgY29uc3QgaXNBbmltYXRpb25SZXF1aXJlZCA9ICFpc0VxdWFsJDEoc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0LCBuZXdIb21lQ2xpZW50T2Zmc2V0KSB8fCBCb29sZWFuKHJlc3VsdC5jb21iaW5lKTtcbiAgICBpZiAoIWlzQW5pbWF0aW9uUmVxdWlyZWQpIHtcbiAgICAgIGRpc3BhdGNoKGNvbXBsZXRlRHJvcCh7XG4gICAgICAgIGNvbXBsZXRlZFxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkcm9wRHVyYXRpb24gPSBnZXREcm9wRHVyYXRpb24oe1xuICAgICAgY3VycmVudDogc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0LFxuICAgICAgZGVzdGluYXRpb246IG5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICByZWFzb25cbiAgICB9KTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgbmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgIGRyb3BEdXJhdGlvbixcbiAgICAgIGNvbXBsZXRlZFxuICAgIH07XG4gICAgZGlzcGF0Y2goYW5pbWF0ZURyb3AoYXJncykpO1xuICB9O1xufTtcbnZhciBkcm9wID0gZHJvcE1pZGRsZXdhcmU7XG5cbnZhciBnZXRXaW5kb3dTY3JvbGwgPSAoKCkgPT4gKHtcbiAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbn0pKTtcblxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmluZGluZyh1cGRhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICBldmVudE5hbWU6ICdzY3JvbGwnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgIT09IHdpbmRvdyAmJiBldmVudC50YXJnZXQgIT09IHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxMaXN0ZW5lcihfcmVmKSB7XG4gIGxldCB7XG4gICAgb25XaW5kb3dTY3JvbGxcbiAgfSA9IF9yZWY7XG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpIHtcbiAgICBvbldpbmRvd1Njcm9sbChnZXRXaW5kb3dTY3JvbGwoKSk7XG4gIH1cbiAgY29uc3Qgc2NoZWR1bGVkID0gcmFmU2NoZCh1cGRhdGVTY3JvbGwpO1xuICBjb25zdCBiaW5kaW5nID0gZ2V0V2luZG93U2Nyb2xsQmluZGluZyhzY2hlZHVsZWQpO1xuICBsZXQgdW5iaW5kID0gbm9vcCQyO1xuICBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdW5iaW5kICE9PSBub29wJDI7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgISFpc0FjdGl2ZSgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IHNjcm9sbCBsaXN0ZW5lciB3aGVuIGFscmVhZHkgYWN0aXZlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbYmluZGluZ10pO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgIWlzQWN0aXZlKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBzY3JvbGwgbGlzdGVuZXIgd2hlbiBub3QgYWN0aXZlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHNjaGVkdWxlZC5jYW5jZWwoKTtcbiAgICB1bmJpbmQoKTtcbiAgICB1bmJpbmQgPSBub29wJDI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICBzdG9wLFxuICAgIGlzQWN0aXZlXG4gIH07XG59XG5cbmNvbnN0IHNob3VsZEVuZCA9IGFjdGlvbiA9PiBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJztcbmNvbnN0IHNjcm9sbExpc3RlbmVyID0gc3RvcmUgPT4ge1xuICBjb25zdCBsaXN0ZW5lciA9IGdldFNjcm9sbExpc3RlbmVyKHtcbiAgICBvbldpbmRvd1Njcm9sbDogbmV3U2Nyb2xsID0+IHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKG1vdmVCeVdpbmRvd1Njcm9sbCh7XG4gICAgICAgIG5ld1Njcm9sbFxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKCFsaXN0ZW5lci5pc0FjdGl2ZSgpICYmIGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgICAgbGlzdGVuZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVyLmlzQWN0aXZlKCkgJiYgc2hvdWxkRW5kKGFjdGlvbikpIHtcbiAgICAgIGxpc3RlbmVyLnN0b3AoKTtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICB9O1xufTtcbnZhciBzY3JvbGxMaXN0ZW5lciQxID0gc2Nyb2xsTGlzdGVuZXI7XG5cbnZhciBnZXRFeHBpcmluZ0Fubm91bmNlID0gKGFubm91bmNlID0+IHtcbiAgbGV0IHdhc0NhbGxlZCA9IGZhbHNlO1xuICBsZXQgaXNFeHBpcmVkID0gZmFsc2U7XG4gIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlzRXhwaXJlZCA9IHRydWU7XG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSBtZXNzYWdlID0+IHtcbiAgICBpZiAod2FzQ2FsbGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdBbm5vdW5jZW1lbnQgYWxyZWFkeSBtYWRlLiBOb3QgbWFraW5nIGEgc2Vjb25kIGFubm91bmNlbWVudCcpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNFeHBpcmVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgICAgQW5ub3VuY2VtZW50cyBjYW5ub3QgYmUgbWFkZSBhc3luY2hyb25vdXNseS5cbiAgICAgICAgRGVmYXVsdCBtZXNzYWdlIGhhcyBhbHJlYWR5IGJlZW4gYW5ub3VuY2VkLlxuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhc0NhbGxlZCA9IHRydWU7XG4gICAgYW5ub3VuY2UobWVzc2FnZSk7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH07XG4gIHJlc3VsdC53YXNDYWxsZWQgPSAoKSA9PiB3YXNDYWxsZWQ7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxudmFyIGdldEFzeW5jTWFyc2hhbCA9ICgoKSA9PiB7XG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgY29uc3QgZXhlY3V0ZSA9IHRpbWVySWQgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gZW50cmllcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLnRpbWVySWQgPT09IHRpbWVySWQpO1xuICAgICEoaW5kZXggIT09IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHRpbWVyJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IFtlbnRyeV0gPSBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgZW50cnkuY2FsbGJhY2soKTtcbiAgfTtcbiAgY29uc3QgYWRkID0gZm4gPT4ge1xuICAgIGNvbnN0IHRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IGV4ZWN1dGUodGltZXJJZCkpO1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgdGltZXJJZCxcbiAgICAgIGNhbGxiYWNrOiBmblxuICAgIH07XG4gICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfTtcbiAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgaWYgKCFlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaGFsbG93ID0gWy4uLmVudHJpZXNdO1xuICAgIGVudHJpZXMubGVuZ3RoID0gMDtcbiAgICBzaGFsbG93LmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KGVudHJ5LnRpbWVySWQpO1xuICAgICAgZW50cnkuY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBhZGQsXG4gICAgZmx1c2hcbiAgfTtcbn0pO1xuXG5jb25zdCBhcmVMb2NhdGlvbnNFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gIGlmIChmaXJzdCA9PSBudWxsICYmIHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGZpcnN0ID09IG51bGwgfHwgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZpcnN0LmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJvcHBhYmxlSWQgJiYgZmlyc3QuaW5kZXggPT09IHNlY29uZC5pbmRleDtcbn07XG5jb25zdCBpc0NvbWJpbmVFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gIGlmIChmaXJzdCA9PSBudWxsICYmIHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGZpcnN0ID09IG51bGwgfHwgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZpcnN0LmRyYWdnYWJsZUlkID09PSBzZWNvbmQuZHJhZ2dhYmxlSWQgJiYgZmlyc3QuZHJvcHBhYmxlSWQgPT09IHNlY29uZC5kcm9wcGFibGVJZDtcbn07XG5jb25zdCBpc0NyaXRpY2FsRXF1YWwgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGlzRHJhZ2dhYmxlRXF1YWwgPSBmaXJzdC5kcmFnZ2FibGUuaWQgPT09IHNlY29uZC5kcmFnZ2FibGUuaWQgJiYgZmlyc3QuZHJhZ2dhYmxlLmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJhZ2dhYmxlLmRyb3BwYWJsZUlkICYmIGZpcnN0LmRyYWdnYWJsZS50eXBlID09PSBzZWNvbmQuZHJhZ2dhYmxlLnR5cGUgJiYgZmlyc3QuZHJhZ2dhYmxlLmluZGV4ID09PSBzZWNvbmQuZHJhZ2dhYmxlLmluZGV4O1xuICBjb25zdCBpc0Ryb3BwYWJsZUVxdWFsID0gZmlyc3QuZHJvcHBhYmxlLmlkID09PSBzZWNvbmQuZHJvcHBhYmxlLmlkICYmIGZpcnN0LmRyb3BwYWJsZS50eXBlID09PSBzZWNvbmQuZHJvcHBhYmxlLnR5cGU7XG4gIHJldHVybiBpc0RyYWdnYWJsZUVxdWFsICYmIGlzRHJvcHBhYmxlRXF1YWw7XG59O1xuXG5jb25zdCB3aXRoVGltaW5ncyA9IChrZXksIGZuKSA9PiB7XG4gIHN0YXJ0KCk7XG4gIGZuKCk7XG4gIGZpbmlzaCgpO1xufTtcbmNvbnN0IGdldERyYWdTdGFydCA9IChjcml0aWNhbCwgbW9kZSkgPT4gKHtcbiAgZHJhZ2dhYmxlSWQ6IGNyaXRpY2FsLmRyYWdnYWJsZS5pZCxcbiAgdHlwZTogY3JpdGljYWwuZHJvcHBhYmxlLnR5cGUsXG4gIHNvdXJjZToge1xuICAgIGRyb3BwYWJsZUlkOiBjcml0aWNhbC5kcm9wcGFibGUuaWQsXG4gICAgaW5kZXg6IGNyaXRpY2FsLmRyYWdnYWJsZS5pbmRleFxuICB9LFxuICBtb2RlXG59KTtcbmZ1bmN0aW9uIGV4ZWN1dGUocmVzcG9uZGVyLCBkYXRhLCBhbm5vdW5jZSwgZ2V0RGVmYXVsdE1lc3NhZ2UpIHtcbiAgaWYgKCFyZXNwb25kZXIpIHtcbiAgICBhbm5vdW5jZShnZXREZWZhdWx0TWVzc2FnZShkYXRhKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdpbGxFeHBpcmUgPSBnZXRFeHBpcmluZ0Fubm91bmNlKGFubm91bmNlKTtcbiAgY29uc3QgcHJvdmlkZWQgPSB7XG4gICAgYW5ub3VuY2U6IHdpbGxFeHBpcmVcbiAgfTtcbiAgcmVzcG9uZGVyKGRhdGEsIHByb3ZpZGVkKTtcbiAgaWYgKCF3aWxsRXhwaXJlLndhc0NhbGxlZCgpKSB7XG4gICAgYW5ub3VuY2UoZ2V0RGVmYXVsdE1lc3NhZ2UoZGF0YSkpO1xuICB9XG59XG52YXIgZ2V0UHVibGlzaGVyID0gKChnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSkgPT4ge1xuICBjb25zdCBhc3luY01hcnNoYWwgPSBnZXRBc3luY01hcnNoYWwoKTtcbiAgbGV0IGRyYWdnaW5nID0gbnVsbDtcbiAgY29uc3QgYmVmb3JlQ2FwdHVyZSA9IChkcmFnZ2FibGVJZCwgbW9kZSkgPT4ge1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkJlZm9yZUNhcHR1cmUgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHdpdGhUaW1pbmdzKCdvbkJlZm9yZUNhcHR1cmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBmbiA9IGdldFJlc3BvbmRlcnMoKS5vbkJlZm9yZUNhcHR1cmU7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgY29uc3QgYmVmb3JlID0ge1xuICAgICAgICAgIGRyYWdnYWJsZUlkLFxuICAgICAgICAgIG1vZGVcbiAgICAgICAgfTtcbiAgICAgICAgZm4oYmVmb3JlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgYmVmb3JlU3RhcnQgPSAoY3JpdGljYWwsIG1vZGUpID0+IHtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25CZWZvcmVEcmFnU3RhcnQgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHdpdGhUaW1pbmdzKCdvbkJlZm9yZURyYWdTdGFydCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGZuID0gZ2V0UmVzcG9uZGVycygpLm9uQmVmb3JlRHJhZ1N0YXJ0O1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKGdldERyYWdTdGFydChjcml0aWNhbCwgbW9kZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBzdGFydCA9IChjcml0aWNhbCwgbW9kZSkgPT4ge1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkJlZm9yZURyYWdTdGFydCBhcyBhIGRyYWcgc3RhcnQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgZGF0YSA9IGdldERyYWdTdGFydChjcml0aWNhbCwgbW9kZSk7XG4gICAgZHJhZ2dpbmcgPSB7XG4gICAgICBtb2RlLFxuICAgICAgbGFzdENyaXRpY2FsOiBjcml0aWNhbCxcbiAgICAgIGxhc3RMb2NhdGlvbjogZGF0YS5zb3VyY2UsXG4gICAgICBsYXN0Q29tYmluZTogbnVsbFxuICAgIH07XG4gICAgYXN5bmNNYXJzaGFsLmFkZCgoKSA9PiB7XG4gICAgICB3aXRoVGltaW5ncygnb25EcmFnU3RhcnQnLCAoKSA9PiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdTdGFydCwgZGF0YSwgYW5ub3VuY2UsIHByZXNldCQxLm9uRHJhZ1N0YXJ0KSk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZSA9IChjcml0aWNhbCwgaW1wYWN0KSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpO1xuICAgIGNvbnN0IGNvbWJpbmUgPSB0cnlHZXRDb21iaW5lKGltcGFjdCk7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25EcmFnTW92ZSB3aGVuIG9uRHJhZ1N0YXJ0IGhhcyBub3QgYmVlbiBjYWxsZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgaGFzQ3JpdGljYWxDaGFuZ2VkID0gIWlzQ3JpdGljYWxFcXVhbChjcml0aWNhbCwgZHJhZ2dpbmcubGFzdENyaXRpY2FsKTtcbiAgICBpZiAoaGFzQ3JpdGljYWxDaGFuZ2VkKSB7XG4gICAgICBkcmFnZ2luZy5sYXN0Q3JpdGljYWwgPSBjcml0aWNhbDtcbiAgICB9XG4gICAgY29uc3QgaGFzTG9jYXRpb25DaGFuZ2VkID0gIWFyZUxvY2F0aW9uc0VxdWFsKGRyYWdnaW5nLmxhc3RMb2NhdGlvbiwgbG9jYXRpb24pO1xuICAgIGlmIChoYXNMb2NhdGlvbkNoYW5nZWQpIHtcbiAgICAgIGRyYWdnaW5nLmxhc3RMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIH1cbiAgICBjb25zdCBoYXNHcm91cGluZ0NoYW5nZWQgPSAhaXNDb21iaW5lRXF1YWwoZHJhZ2dpbmcubGFzdENvbWJpbmUsIGNvbWJpbmUpO1xuICAgIGlmIChoYXNHcm91cGluZ0NoYW5nZWQpIHtcbiAgICAgIGRyYWdnaW5nLmxhc3RDb21iaW5lID0gY29tYmluZTtcbiAgICB9XG4gICAgaWYgKCFoYXNDcml0aWNhbENoYW5nZWQgJiYgIWhhc0xvY2F0aW9uQ2hhbmdlZCAmJiAhaGFzR3JvdXBpbmdDaGFuZ2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAuLi5nZXREcmFnU3RhcnQoY3JpdGljYWwsIGRyYWdnaW5nLm1vZGUpLFxuICAgICAgY29tYmluZSxcbiAgICAgIGRlc3RpbmF0aW9uOiBsb2NhdGlvblxuICAgIH07XG4gICAgYXN5bmNNYXJzaGFsLmFkZCgoKSA9PiB7XG4gICAgICB3aXRoVGltaW5ncygnb25EcmFnVXBkYXRlJywgKCkgPT4gZXhlY3V0ZShnZXRSZXNwb25kZXJzKCkub25EcmFnVXBkYXRlLCBkYXRhLCBhbm5vdW5jZSwgcHJlc2V0JDEub25EcmFnVXBkYXRlKSk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IGZsdXNoIHJlc3BvbmRlcnMgd2hpbGUgZHJhZ2dpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgYXN5bmNNYXJzaGFsLmZsdXNoKCk7XG4gIH07XG4gIGNvbnN0IGRyb3AgPSByZXN1bHQgPT4ge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uRHJhZ0VuZCB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIG9uRHJhZ1N0YXJ0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGRyYWdnaW5nID0gbnVsbDtcbiAgICB3aXRoVGltaW5ncygnb25EcmFnRW5kJywgKCkgPT4gZXhlY3V0ZShnZXRSZXNwb25kZXJzKCkub25EcmFnRW5kLCByZXN1bHQsIGFubm91bmNlLCBwcmVzZXQkMS5vbkRyYWdFbmQpKTtcbiAgfTtcbiAgY29uc3QgYWJvcnQgPSAoKSA9PiB7XG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAuLi5nZXREcmFnU3RhcnQoZHJhZ2dpbmcubGFzdENyaXRpY2FsLCBkcmFnZ2luZy5tb2RlKSxcbiAgICAgIGNvbWJpbmU6IG51bGwsXG4gICAgICBkZXN0aW5hdGlvbjogbnVsbCxcbiAgICAgIHJlYXNvbjogJ0NBTkNFTCdcbiAgICB9O1xuICAgIGRyb3AocmVzdWx0KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBiZWZvcmVDYXB0dXJlLFxuICAgIGJlZm9yZVN0YXJ0LFxuICAgIHN0YXJ0LFxuICAgIHVwZGF0ZSxcbiAgICBmbHVzaCxcbiAgICBkcm9wLFxuICAgIGFib3J0XG4gIH07XG59KTtcblxudmFyIHJlc3BvbmRlcnMgPSAoKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSA9PiB7XG4gIGNvbnN0IHB1Ymxpc2hlciA9IGdldFB1Ymxpc2hlcihnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSk7XG4gIHJldHVybiBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSAnQkVGT1JFX0lOSVRJQUxfQ0FQVFVSRScpIHtcbiAgICAgIHB1Ymxpc2hlci5iZWZvcmVDYXB0dXJlKGFjdGlvbi5wYXlsb2FkLmRyYWdnYWJsZUlkLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgICBjb25zdCBjcml0aWNhbCA9IGFjdGlvbi5wYXlsb2FkLmNyaXRpY2FsO1xuICAgICAgcHVibGlzaGVyLmJlZm9yZVN0YXJ0KGNyaXRpY2FsLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgcHVibGlzaGVyLnN0YXJ0KGNyaXRpY2FsLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdDtcbiAgICAgIHB1Ymxpc2hlci5mbHVzaCgpO1xuICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgcHVibGlzaGVyLmRyb3AocmVzdWx0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJykge1xuICAgICAgcHVibGlzaGVyLmFib3J0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHB1Ymxpc2hlci51cGRhdGUoc3RhdGUuY3JpdGljYWwsIHN0YXRlLmltcGFjdCk7XG4gICAgfVxuICB9O1xufSk7XG5cbmNvbnN0IGRyb3BBbmltYXRpb25GaW5pc2hNaWRkbGV3YXJlID0gc3RvcmUgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoYWN0aW9uLnR5cGUgIT09ICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcpIHtcbiAgICBuZXh0KGFjdGlvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgIShzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluaXNoIGEgZHJvcCBhbmltYXRpbmcgd2hlbiBubyBkcm9wIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgc3RvcmUuZGlzcGF0Y2goY29tcGxldGVEcm9wKHtcbiAgICBjb21wbGV0ZWQ6IHN0YXRlLmNvbXBsZXRlZFxuICB9KSk7XG59O1xudmFyIGRyb3BBbmltYXRpb25GaW5pc2ggPSBkcm9wQW5pbWF0aW9uRmluaXNoTWlkZGxld2FyZTtcblxuY29uc3QgZHJvcEFuaW1hdGlvbkZsdXNoT25TY3JvbGxNaWRkbGV3YXJlID0gc3RvcmUgPT4ge1xuICBsZXQgdW5iaW5kID0gbnVsbDtcbiAgbGV0IGZyYW1lSWQgPSBudWxsO1xuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgICBmcmFtZUlkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHVuYmluZCkge1xuICAgICAgdW5iaW5kKCk7XG4gICAgICB1bmJpbmQgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRJT05fRklOSVNIRUQnKSB7XG4gICAgICBjbGVhcigpO1xuICAgIH1cbiAgICBuZXh0KGFjdGlvbik7XG4gICAgaWYgKGFjdGlvbi50eXBlICE9PSAnRFJPUF9BTklNQVRFJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiaW5kaW5nID0ge1xuICAgICAgZXZlbnROYW1lOiAnc2Nyb2xsJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0sXG4gICAgICBmbjogZnVuY3Rpb24gZmx1c2hEcm9wQW5pbWF0aW9uKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKGRyb3BBbmltYXRpb25GaW5pc2hlZCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBmcmFtZUlkID0gbnVsbDtcbiAgICAgIHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbYmluZGluZ10pO1xuICAgIH0pO1xuICB9O1xufTtcbnZhciBkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbCA9IGRyb3BBbmltYXRpb25GbHVzaE9uU2Nyb2xsTWlkZGxld2FyZTtcblxudmFyIGRpbWVuc2lvbk1hcnNoYWxTdG9wcGVyID0gKG1hcnNoYWwgPT4gKCkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQU5JTUFURScpIHtcbiAgICBtYXJzaGFsLnN0b3BQdWJsaXNoaW5nKCk7XG4gIH1cbiAgbmV4dChhY3Rpb24pO1xufSk7XG5cbnZhciBmb2N1cyA9IChtYXJzaGFsID0+IHtcbiAgbGV0IGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgcmV0dXJuICgpID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgICBpc1dhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIG1hcnNoYWwudHJ5UmVjb3JkRm9jdXMoYWN0aW9uLnBheWxvYWQuY3JpdGljYWwuZHJhZ2dhYmxlLmlkKTtcbiAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGlmICghaXNXYXRjaGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdGTFVTSCcpIHtcbiAgICAgIGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScpIHtcbiAgICAgIGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFjdGlvbi5wYXlsb2FkLmNvbXBsZXRlZC5yZXN1bHQ7XG4gICAgICBpZiAocmVzdWx0LmNvbWJpbmUpIHtcbiAgICAgICAgbWFyc2hhbC50cnlTaGlmdFJlY29yZChyZXN1bHQuZHJhZ2dhYmxlSWQsIHJlc3VsdC5jb21iaW5lLmRyYWdnYWJsZUlkKTtcbiAgICAgIH1cbiAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICB9XG4gIH07XG59KTtcblxuY29uc3Qgc2hvdWxkU3RvcCA9IGFjdGlvbiA9PiBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJztcbnZhciBhdXRvU2Nyb2xsID0gKGF1dG9TY3JvbGxlciA9PiBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChzaG91bGRTdG9wKGFjdGlvbikpIHtcbiAgICBhdXRvU2Nyb2xsZXIuc3RvcCgpO1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwaGFzZSB0byBiZSBEUkFHR0lORyBhZnRlciBJTklUSUFMX1BVQkxJU0gnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgYXV0b1Njcm9sbGVyLnN0YXJ0KHN0YXRlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbmV4dChhY3Rpb24pO1xuICBhdXRvU2Nyb2xsZXIuc2Nyb2xsKHN0b3JlLmdldFN0YXRlKCkpO1xufSk7XG5cbmNvbnN0IHBlbmRpbmdEcm9wID0gc3RvcmUgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBuZXh0KGFjdGlvbik7XG4gIGlmIChhY3Rpb24udHlwZSAhPT0gJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBvc3RBY3Rpb25TdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGlmIChwb3N0QWN0aW9uU3RhdGUucGhhc2UgIT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwb3N0QWN0aW9uU3RhdGUuaXNXYWl0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0b3JlLmRpc3BhdGNoKGRyb3AkMSh7XG4gICAgcmVhc29uOiBwb3N0QWN0aW9uU3RhdGUucmVhc29uXG4gIH0pKTtcbn07XG52YXIgcGVuZGluZ0Ryb3AkMSA9IHBlbmRpbmdEcm9wO1xuXG5jb25zdCBjb21wb3NlRW5oYW5jZXJzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyh7XG4gIG5hbWU6ICdAaGVsbG8tcGFuZ2VhL2RuZCdcbn0pIDogY29tcG9zZTtcbnZhciBjcmVhdGVTdG9yZSA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBkaW1lbnNpb25NYXJzaGFsLFxuICAgIGZvY3VzTWFyc2hhbCxcbiAgICBzdHlsZU1hcnNoYWwsXG4gICAgZ2V0UmVzcG9uZGVycyxcbiAgICBhbm5vdW5jZSxcbiAgICBhdXRvU2Nyb2xsZXJcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBjcmVhdGVTdG9yZSQxKHJlZHVjZXIsIGNvbXBvc2VFbmhhbmNlcnMoYXBwbHlNaWRkbGV3YXJlKHN0eWxlKHN0eWxlTWFyc2hhbCksIGRpbWVuc2lvbk1hcnNoYWxTdG9wcGVyKGRpbWVuc2lvbk1hcnNoYWwpLCBsaWZ0KGRpbWVuc2lvbk1hcnNoYWwpLCBkcm9wLCBkcm9wQW5pbWF0aW9uRmluaXNoLCBkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbCwgcGVuZGluZ0Ryb3AkMSwgYXV0b1Njcm9sbChhdXRvU2Nyb2xsZXIpLCBzY3JvbGxMaXN0ZW5lciQxLCBmb2N1cyhmb2N1c01hcnNoYWwpLCByZXNwb25kZXJzKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSkpKTtcbn0pO1xuXG5jb25zdCBjbGVhbiQxID0gKCkgPT4gKHtcbiAgYWRkaXRpb25zOiB7fSxcbiAgcmVtb3ZhbHM6IHt9LFxuICBtb2RpZmllZDoge31cbn0pO1xuZnVuY3Rpb24gY3JlYXRlUHVibGlzaGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICByZWdpc3RyeSxcbiAgICBjYWxsYmFja3NcbiAgfSA9IF9yZWY7XG4gIGxldCBzdGFnaW5nID0gY2xlYW4kMSgpO1xuICBsZXQgZnJhbWVJZCA9IG51bGw7XG4gIGNvbnN0IGNvbGxlY3QgPSAoKSA9PiB7XG4gICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLmNvbGxlY3Rpb25TdGFydGluZygpO1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgICBzdGFydCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhZGRpdGlvbnMsXG4gICAgICAgIHJlbW92YWxzLFxuICAgICAgICBtb2RpZmllZFxuICAgICAgfSA9IHN0YWdpbmc7XG4gICAgICBjb25zdCBhZGRlZCA9IE9iamVjdC5rZXlzKGFkZGl0aW9ucykubWFwKGlkID0+IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKGlkKS5nZXREaW1lbnNpb24ob3JpZ2luKSkuc29ydCgoYSwgYikgPT4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4KTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhtb2RpZmllZCkubWFwKGlkID0+IHtcbiAgICAgICAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChpZCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbCA9IGVudHJ5LmNhbGxiYWNrcy5nZXRTY3JvbGxXaGlsZURyYWdnaW5nKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZHJvcHBhYmxlSWQ6IGlkLFxuICAgICAgICAgIHNjcm9sbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGFkZGl0aW9uczogYWRkZWQsXG4gICAgICAgIHJlbW92YWxzOiBPYmplY3Qua2V5cyhyZW1vdmFscyksXG4gICAgICAgIG1vZGlmaWVkOiB1cGRhdGVkXG4gICAgICB9O1xuICAgICAgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgICAgIGZpbmlzaCgpO1xuICAgICAgY2FsbGJhY2tzLnB1Ymxpc2gocmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgYWRkID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IGlkID0gZW50cnkuZGVzY3JpcHRvci5pZDtcbiAgICBzdGFnaW5nLmFkZGl0aW9uc1tpZF0gPSBlbnRyeTtcbiAgICBzdGFnaW5nLm1vZGlmaWVkW2VudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWRdID0gdHJ1ZTtcbiAgICBpZiAoc3RhZ2luZy5yZW1vdmFsc1tpZF0pIHtcbiAgICAgIGRlbGV0ZSBzdGFnaW5nLnJlbW92YWxzW2lkXTtcbiAgICB9XG4gICAgY29sbGVjdCgpO1xuICB9O1xuICBjb25zdCByZW1vdmUgPSBlbnRyeSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IGVudHJ5LmRlc2NyaXB0b3I7XG4gICAgc3RhZ2luZy5yZW1vdmFsc1tkZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgc3RhZ2luZy5tb2RpZmllZFtkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXSA9IHRydWU7XG4gICAgaWYgKHN0YWdpbmcuYWRkaXRpb25zW2Rlc2NyaXB0b3IuaWRdKSB7XG4gICAgICBkZWxldGUgc3RhZ2luZy5hZGRpdGlvbnNbZGVzY3JpcHRvci5pZF07XG4gICAgfVxuICAgIGNvbGxlY3QoKTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBpZiAoIWZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgZnJhbWVJZCA9IG51bGw7XG4gICAgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBhZGQsXG4gICAgcmVtb3ZlLFxuICAgIHN0b3BcbiAgfTtcbn1cblxudmFyIGdldE1heFNjcm9sbCA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBzY3JvbGxIZWlnaHQsXG4gICAgc2Nyb2xsV2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoXG4gIH0gPSBfcmVmO1xuICBjb25zdCBtYXhTY3JvbGwgPSBzdWJ0cmFjdCh7XG4gICAgeDogc2Nyb2xsV2lkdGgsXG4gICAgeTogc2Nyb2xsSGVpZ2h0XG4gIH0sIHtcbiAgICB4OiB3aWR0aCxcbiAgICB5OiBoZWlnaHRcbiAgfSk7XG4gIGNvbnN0IGFkanVzdGVkTWF4U2Nyb2xsID0ge1xuICAgIHg6IE1hdGgubWF4KDAsIG1heFNjcm9sbC54KSxcbiAgICB5OiBNYXRoLm1heCgwLCBtYXhTY3JvbGwueSlcbiAgfTtcbiAgcmV0dXJuIGFkanVzdGVkTWF4U2Nyb2xsO1xufSk7XG5cbnZhciBnZXREb2N1bWVudEVsZW1lbnQgPSAoKCkgPT4ge1xuICBjb25zdCBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICFkb2MgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBkb2M7XG59KTtcblxudmFyIGdldE1heFdpbmRvd1Njcm9sbCA9ICgoKSA9PiB7XG4gIGNvbnN0IGRvYyA9IGdldERvY3VtZW50RWxlbWVudCgpO1xuICBjb25zdCBtYXhTY3JvbGwgPSBnZXRNYXhTY3JvbGwoe1xuICAgIHNjcm9sbEhlaWdodDogZG9jLnNjcm9sbEhlaWdodCxcbiAgICBzY3JvbGxXaWR0aDogZG9jLnNjcm9sbFdpZHRoLFxuICAgIHdpZHRoOiBkb2MuY2xpZW50V2lkdGgsXG4gICAgaGVpZ2h0OiBkb2MuY2xpZW50SGVpZ2h0XG4gIH0pO1xuICByZXR1cm4gbWF4U2Nyb2xsO1xufSk7XG5cbnZhciBnZXRWaWV3cG9ydCA9ICgoKSA9PiB7XG4gIGNvbnN0IHNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbCgpO1xuICBjb25zdCBtYXhTY3JvbGwgPSBnZXRNYXhXaW5kb3dTY3JvbGwoKTtcbiAgY29uc3QgdG9wID0gc2Nyb2xsLnk7XG4gIGNvbnN0IGxlZnQgPSBzY3JvbGwueDtcbiAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnRFbGVtZW50KCk7XG4gIGNvbnN0IHdpZHRoID0gZG9jLmNsaWVudFdpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBkb2MuY2xpZW50SGVpZ2h0O1xuICBjb25zdCByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBjb25zdCBmcmFtZSA9IGdldFJlY3Qoe1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbVxuICB9KTtcbiAgY29uc3Qgdmlld3BvcnQgPSB7XG4gICAgZnJhbWUsXG4gICAgc2Nyb2xsOiB7XG4gICAgICBpbml0aWFsOiBzY3JvbGwsXG4gICAgICBjdXJyZW50OiBzY3JvbGwsXG4gICAgICBtYXg6IG1heFNjcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IG9yaWdpbixcbiAgICAgICAgZGlzcGxhY2VtZW50OiBvcmlnaW5cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB2aWV3cG9ydDtcbn0pO1xuXG52YXIgZ2V0SW5pdGlhbFB1Ymxpc2ggPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY3JpdGljYWwsXG4gICAgc2Nyb2xsT3B0aW9ucyxcbiAgICByZWdpc3RyeVxuICB9ID0gX3JlZjtcbiAgc3RhcnQoKTtcbiAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydCgpO1xuICBjb25zdCB3aW5kb3dTY3JvbGwgPSB2aWV3cG9ydC5zY3JvbGwuY3VycmVudDtcbiAgY29uc3QgaG9tZSA9IGNyaXRpY2FsLmRyb3BwYWJsZTtcbiAgY29uc3QgZHJvcHBhYmxlcyA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRBbGxCeVR5cGUoaG9tZS50eXBlKS5tYXAoZW50cnkgPT4gZW50cnkuY2FsbGJhY2tzLmdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsKHdpbmRvd1Njcm9sbCwgc2Nyb2xsT3B0aW9ucykpO1xuICBjb25zdCBkcmFnZ2FibGVzID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEFsbEJ5VHlwZShjcml0aWNhbC5kcmFnZ2FibGUudHlwZSkubWFwKGVudHJ5ID0+IGVudHJ5LmdldERpbWVuc2lvbih3aW5kb3dTY3JvbGwpKTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IHtcbiAgICBkcmFnZ2FibGVzOiB0b0RyYWdnYWJsZU1hcChkcmFnZ2FibGVzKSxcbiAgICBkcm9wcGFibGVzOiB0b0Ryb3BwYWJsZU1hcChkcm9wcGFibGVzKVxuICB9O1xuICBmaW5pc2goKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGRpbWVuc2lvbnMsXG4gICAgY3JpdGljYWwsXG4gICAgdmlld3BvcnRcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5mdW5jdGlvbiBzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZW50cnkpIHtcbiAgaWYgKGVudHJ5LmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnaW5nLmlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlbnRyeS5kZXNjcmlwdG9yLnR5cGUgIT09IGRyYWdnaW5nLnR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaG9tZSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGVudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpO1xuICBpZiAoaG9tZS5kZXNjcmlwdG9yLm1vZGUgIT09ICd2aXJ0dWFsJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgWW91IGFyZSBhdHRlbXB0aW5nIHRvIGFkZCBvciByZW1vdmUgYSBEcmFnZ2FibGUgW2lkOiAke2VudHJ5LmRlc2NyaXB0b3IuaWR9XVxuICAgICAgd2hpbGUgYSBkcmFnIGlzIG9jY3VycmluZy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgdmlydHVhbCBsaXN0cy5cblxuICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL3BhdHRlcm5zL3ZpcnR1YWwtbGlzdHMubWRcbiAgICBgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YXIgY3JlYXRlRGltZW5zaW9uTWFyc2hhbCA9ICgocmVnaXN0cnksIGNhbGxiYWNrcykgPT4ge1xuICBsZXQgY29sbGVjdGlvbiA9IG51bGw7XG4gIGNvbnN0IHB1Ymxpc2hlciA9IGNyZWF0ZVB1Ymxpc2hlcih7XG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBwdWJsaXNoOiBjYWxsYmFja3MucHVibGlzaFdoaWxlRHJhZ2dpbmcsXG4gICAgICBjb2xsZWN0aW9uU3RhcnRpbmc6IGNhbGxiYWNrcy5jb2xsZWN0aW9uU3RhcnRpbmdcbiAgICB9LFxuICAgIHJlZ2lzdHJ5XG4gIH0pO1xuICBjb25zdCB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQgPSAoaWQsIGlzRW5hYmxlZCkgPT4ge1xuICAgICFyZWdpc3RyeS5kcm9wcGFibGUuZXhpc3RzKGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCB1cGRhdGUgaXMgZW5hYmxlZCBmbGFnIG9mIERyb3BwYWJsZSAke2lkfSBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZGApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLnVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCh7XG4gICAgICBpZCxcbiAgICAgIGlzRW5hYmxlZFxuICAgIH0pO1xuICB9O1xuICBjb25zdCB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkID0gKGlkLCBpc0NvbWJpbmVFbmFibGVkKSA9PiB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICFyZWdpc3RyeS5kcm9wcGFibGUuZXhpc3RzKGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCB1cGRhdGUgaXNDb21iaW5lRW5hYmxlZCBmbGFnIG9mIERyb3BwYWJsZSAke2lkfSBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZGApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjYWxsYmFja3MudXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCh7XG4gICAgICBpZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWRcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsID0gKGlkLCBuZXdTY3JvbGwpID0+IHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgIXJlZ2lzdHJ5LmRyb3BwYWJsZS5leGlzdHMoaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IHVwZGF0ZSB0aGUgc2Nyb2xsIG9uIERyb3BwYWJsZSAke2lkfSBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZGApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjYWxsYmFja3MudXBkYXRlRHJvcHBhYmxlU2Nyb2xsKHtcbiAgICAgIGlkLFxuICAgICAgbmV3U2Nyb2xsXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHNjcm9sbERyb3BwYWJsZSA9IChpZCwgY2hhbmdlKSA9PiB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGlkKS5jYWxsYmFja3Muc2Nyb2xsKGNoYW5nZSk7XG4gIH07XG4gIGNvbnN0IHN0b3BQdWJsaXNoaW5nID0gKCkgPT4ge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwdWJsaXNoZXIuc3RvcCgpO1xuICAgIGNvbnN0IGhvbWUgPSBjb2xsZWN0aW9uLmNyaXRpY2FsLmRyb3BwYWJsZTtcbiAgICByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QWxsQnlUeXBlKGhvbWUudHlwZSkuZm9yRWFjaChlbnRyeSA9PiBlbnRyeS5jYWxsYmFja3MuZHJhZ1N0b3BwZWQoKSk7XG4gICAgY29sbGVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIGNvbGxlY3Rpb24gPSBudWxsO1xuICB9O1xuICBjb25zdCBzdWJzY3JpYmVyID0gZXZlbnQgPT4ge1xuICAgICFjb2xsZWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIG9ubHkgYmUgc3Vic2NyaWJlZCB3aGVuIGEgY29sbGVjdGlvbiBpcyBvY2N1cnJpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSBjb2xsZWN0aW9uLmNyaXRpY2FsLmRyYWdnYWJsZTtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ0FERElUSU9OJykge1xuICAgICAgaWYgKHNob3VsZFB1Ymxpc2hVcGRhdGUocmVnaXN0cnksIGRyYWdnaW5nLCBldmVudC52YWx1ZSkpIHtcbiAgICAgICAgcHVibGlzaGVyLmFkZChldmVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAnUkVNT1ZBTCcpIHtcbiAgICAgIGlmIChzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZXZlbnQudmFsdWUpKSB7XG4gICAgICAgIHB1Ymxpc2hlci5yZW1vdmUoZXZlbnQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RhcnRQdWJsaXNoaW5nID0gcmVxdWVzdCA9PiB7XG4gICAgISFjb2xsZWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IGNhcHR1cmluZyBjcml0aWNhbCBkaW1lbnNpb25zIGFzIHRoZXJlIGlzIGFscmVhZHkgYSBjb2xsZWN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQocmVxdWVzdC5kcmFnZ2FibGVJZCk7XG4gICAgY29uc3QgaG9tZSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGVudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpO1xuICAgIGNvbnN0IGNyaXRpY2FsID0ge1xuICAgICAgZHJhZ2dhYmxlOiBlbnRyeS5kZXNjcmlwdG9yLFxuICAgICAgZHJvcHBhYmxlOiBob21lLmRlc2NyaXB0b3JcbiAgICB9O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gcmVnaXN0cnkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIGNvbGxlY3Rpb24gPSB7XG4gICAgICBjcml0aWNhbCxcbiAgICAgIHVuc3Vic2NyaWJlXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0SW5pdGlhbFB1Ymxpc2goe1xuICAgICAgY3JpdGljYWwsXG4gICAgICByZWdpc3RyeSxcbiAgICAgIHNjcm9sbE9wdGlvbnM6IHJlcXVlc3Quc2Nyb2xsT3B0aW9uc1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBtYXJzaGFsID0ge1xuICAgIHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCxcbiAgICB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkLFxuICAgIHNjcm9sbERyb3BwYWJsZSxcbiAgICB1cGRhdGVEcm9wcGFibGVTY3JvbGwsXG4gICAgc3RhcnRQdWJsaXNoaW5nLFxuICAgIHN0b3BQdWJsaXNoaW5nXG4gIH07XG4gIHJldHVybiBtYXJzaGFsO1xufSk7XG5cbnZhciBjYW5TdGFydERyYWcgPSAoKHN0YXRlLCBpZCkgPT4ge1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChzdGF0ZS5waGFzZSAhPT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc3RhdGUuY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCA9PT0gaWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmNvbXBsZXRlZC5yZXN1bHQucmVhc29uID09PSAnRFJPUCc7XG59KTtcblxudmFyIHNjcm9sbFdpbmRvdyA9IChjaGFuZ2UgPT4ge1xuICB3aW5kb3cuc2Nyb2xsQnkoY2hhbmdlLngsIGNoYW5nZS55KTtcbn0pO1xuXG5jb25zdCBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlcyA9IG1lbW9pemVPbmUoZHJvcHBhYmxlcyA9PiB0b0Ryb3BwYWJsZUxpc3QoZHJvcHBhYmxlcykuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gIGlmICghZHJvcHBhYmxlLmlzRW5hYmxlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWRyb3BwYWJsZS5mcmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pKTtcbmNvbnN0IGdldFNjcm9sbGFibGVEcm9wcGFibGVPdmVyID0gKHRhcmdldCwgZHJvcHBhYmxlcykgPT4ge1xuICBjb25zdCBtYXliZSA9IGdldFNjcm9sbGFibGVEcm9wcGFibGVzKGRyb3BwYWJsZXMpLmZpbmQoZHJvcHBhYmxlID0+IHtcbiAgICAhZHJvcHBhYmxlLmZyYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCByZXN1bHQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGlzUG9zaXRpb25JbkZyYW1lKGRyb3BwYWJsZS5mcmFtZS5wYWdlTWFyZ2luQm94KSh0YXJnZXQpO1xuICB9KSB8fCBudWxsO1xuICByZXR1cm4gbWF5YmU7XG59O1xudmFyIGdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGNlbnRlcixcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkcm9wcGFibGVzXG4gIH0gPSBfcmVmO1xuICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICBjb25zdCBkaW1lbnNpb24gPSBkcm9wcGFibGVzW2Rlc3RpbmF0aW9uXTtcbiAgICBpZiAoIWRpbWVuc2lvbi5mcmFtZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkaW1lbnNpb247XG4gIH1cbiAgY29uc3QgZGltZW5zaW9uID0gZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIoY2VudGVyLCBkcm9wcGFibGVzKTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn0pO1xuXG5jb25zdCBkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucyA9IHtcbiAgc3RhcnRGcm9tUGVyY2VudGFnZTogMC4yNSxcbiAgbWF4U2Nyb2xsQXRQZXJjZW50YWdlOiAwLjA1LFxuICBtYXhQaXhlbFNjcm9sbDogMjgsXG4gIGVhc2U6IHBlcmNlbnRhZ2UgPT4gcGVyY2VudGFnZSAqKiAyLFxuICBkdXJhdGlvbkRhbXBlbmluZzoge1xuICAgIHN0b3BEYW1wZW5pbmdBdDogMTIwMCxcbiAgICBhY2NlbGVyYXRlQXQ6IDM2MFxuICB9LFxuICBkaXNhYmxlZDogZmFsc2Vcbn07XG5cbnZhciBnZXREaXN0YW5jZVRocmVzaG9sZHMgPSAoZnVuY3Rpb24gKGNvbnRhaW5lciwgYXhpcywgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucykge1xuICBpZiAoZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyA9ICgpID0+IGRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zO1xuICB9XG4gIGNvbnN0IGF1dG9TY3JvbGxlck9wdGlvbnMgPSBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCk7XG4gIGNvbnN0IHN0YXJ0U2Nyb2xsaW5nRnJvbSA9IGNvbnRhaW5lcltheGlzLnNpemVdICogYXV0b1Njcm9sbGVyT3B0aW9ucy5zdGFydEZyb21QZXJjZW50YWdlO1xuICBjb25zdCBtYXhTY3JvbGxWYWx1ZUF0ID0gY29udGFpbmVyW2F4aXMuc2l6ZV0gKiBhdXRvU2Nyb2xsZXJPcHRpb25zLm1heFNjcm9sbEF0UGVyY2VudGFnZTtcbiAgY29uc3QgdGhyZXNob2xkcyA9IHtcbiAgICBzdGFydFNjcm9sbGluZ0Zyb20sXG4gICAgbWF4U2Nyb2xsVmFsdWVBdFxuICB9O1xuICByZXR1cm4gdGhyZXNob2xkcztcbn0pO1xuXG52YXIgZ2V0UGVyY2VudGFnZSA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBzdGFydE9mUmFuZ2UsXG4gICAgZW5kT2ZSYW5nZSxcbiAgICBjdXJyZW50XG4gIH0gPSBfcmVmO1xuICBjb25zdCByYW5nZSA9IGVuZE9mUmFuZ2UgLSBzdGFydE9mUmFuZ2U7XG4gIGlmIChyYW5nZSA9PT0gMCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgRGV0ZWN0ZWQgZGlzdGFuY2UgcmFuZ2Ugb2YgMCBpbiB0aGUgZmx1aWQgYXV0byBzY3JvbGxlclxuICAgICAgVGhpcyBpcyB1bmV4cGVjdGVkIGFuZCB3b3VsZCBjYXVzZSBhIGRpdmlkZSBieSAwIGlzc3VlLlxuICAgICAgTm90IGFsbG93aW5nIGFuIGF1dG8gc2Nyb2xsXG4gICAgYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgY3VycmVudEluUmFuZ2UgPSBjdXJyZW50IC0gc3RhcnRPZlJhbmdlO1xuICBjb25zdCBwZXJjZW50YWdlID0gY3VycmVudEluUmFuZ2UgLyByYW5nZTtcbiAgcmV0dXJuIHBlcmNlbnRhZ2U7XG59KTtcblxudmFyIG1pblNjcm9sbCA9IDE7XG5cbnZhciBnZXRWYWx1ZUZyb21EaXN0YW5jZSA9IChmdW5jdGlvbiAoZGlzdGFuY2VUb0VkZ2UsIHRocmVzaG9sZHMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpIHtcbiAgaWYgKGdldEF1dG9TY3JvbGxlck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnMgPSAoKSA9PiBkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucztcbiAgfVxuICBjb25zdCBhdXRvU2Nyb2xsZXJPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICBpZiAoZGlzdGFuY2VUb0VkZ2UgPiB0aHJlc2hvbGRzLnN0YXJ0U2Nyb2xsaW5nRnJvbSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChkaXN0YW5jZVRvRWRnZSA8PSB0aHJlc2hvbGRzLm1heFNjcm9sbFZhbHVlQXQpIHtcbiAgICByZXR1cm4gYXV0b1Njcm9sbGVyT3B0aW9ucy5tYXhQaXhlbFNjcm9sbDtcbiAgfVxuICBpZiAoZGlzdGFuY2VUb0VkZ2UgPT09IHRocmVzaG9sZHMuc3RhcnRTY3JvbGxpbmdGcm9tKSB7XG4gICAgcmV0dXJuIG1pblNjcm9sbDtcbiAgfVxuICBjb25zdCBwZXJjZW50YWdlRnJvbU1heFNjcm9sbFZhbHVlQXQgPSBnZXRQZXJjZW50YWdlKHtcbiAgICBzdGFydE9mUmFuZ2U6IHRocmVzaG9sZHMubWF4U2Nyb2xsVmFsdWVBdCxcbiAgICBlbmRPZlJhbmdlOiB0aHJlc2hvbGRzLnN0YXJ0U2Nyb2xsaW5nRnJvbSxcbiAgICBjdXJyZW50OiBkaXN0YW5jZVRvRWRnZVxuICB9KTtcbiAgY29uc3QgcGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20gPSAxIC0gcGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0O1xuICBjb25zdCBzY3JvbGwgPSBhdXRvU2Nyb2xsZXJPcHRpb25zLm1heFBpeGVsU2Nyb2xsICogYXV0b1Njcm9sbGVyT3B0aW9ucy5lYXNlKHBlcmNlbnRhZ2VGcm9tU3RhcnRTY3JvbGxpbmdGcm9tKTtcbiAgcmV0dXJuIE1hdGguY2VpbChzY3JvbGwpO1xufSk7XG5cbnZhciBkYW1wZW5WYWx1ZUJ5VGltZSA9ICgocHJvcG9zZWRTY3JvbGwsIGRyYWdTdGFydFRpbWUsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpID0+IHtcbiAgY29uc3QgYXV0b1Njcm9sbGVyT3B0aW9ucyA9IGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKTtcbiAgY29uc3QgYWNjZWxlcmF0ZUF0ID0gYXV0b1Njcm9sbGVyT3B0aW9ucy5kdXJhdGlvbkRhbXBlbmluZy5hY2NlbGVyYXRlQXQ7XG4gIGNvbnN0IHN0b3BBdCA9IGF1dG9TY3JvbGxlck9wdGlvbnMuZHVyYXRpb25EYW1wZW5pbmcuc3RvcERhbXBlbmluZ0F0O1xuICBjb25zdCBzdGFydE9mUmFuZ2UgPSBkcmFnU3RhcnRUaW1lO1xuICBjb25zdCBlbmRPZlJhbmdlID0gc3RvcEF0O1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICBjb25zdCBydW5UaW1lID0gbm93IC0gc3RhcnRPZlJhbmdlO1xuICBpZiAocnVuVGltZSA+PSBzdG9wQXQpIHtcbiAgICByZXR1cm4gcHJvcG9zZWRTY3JvbGw7XG4gIH1cbiAgaWYgKHJ1blRpbWUgPCBhY2NlbGVyYXRlQXQpIHtcbiAgICByZXR1cm4gbWluU2Nyb2xsO1xuICB9XG4gIGNvbnN0IGJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlID0gZ2V0UGVyY2VudGFnZSh7XG4gICAgc3RhcnRPZlJhbmdlOiBhY2NlbGVyYXRlQXQsXG4gICAgZW5kT2ZSYW5nZSxcbiAgICBjdXJyZW50OiBydW5UaW1lXG4gIH0pO1xuICBjb25zdCBzY3JvbGwgPSBwcm9wb3NlZFNjcm9sbCAqIGF1dG9TY3JvbGxlck9wdGlvbnMuZWFzZShiZXR3ZWVuQWNjZWxlcmF0ZUF0QW5kU3RvcEF0UGVyY2VudGFnZSk7XG4gIHJldHVybiBNYXRoLmNlaWwoc2Nyb2xsKTtcbn0pO1xuXG52YXIgZ2V0VmFsdWUgPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgZGlzdGFuY2VUb0VkZ2UsXG4gICAgdGhyZXNob2xkcyxcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9ID0gX3JlZjtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0VmFsdWVGcm9tRGlzdGFuY2UoZGlzdGFuY2VUb0VkZ2UsIHRocmVzaG9sZHMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpO1xuICBpZiAoc2Nyb2xsID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKCFzaG91bGRVc2VUaW1lRGFtcGVuaW5nKSB7XG4gICAgcmV0dXJuIHNjcm9sbDtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoZGFtcGVuVmFsdWVCeVRpbWUoc2Nyb2xsLCBkcmFnU3RhcnRUaW1lLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKSwgbWluU2Nyb2xsKTtcbn0pO1xuXG52YXIgZ2V0U2Nyb2xsT25BeGlzID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGNvbnRhaW5lcixcbiAgICBkaXN0YW5jZVRvRWRnZXMsXG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBheGlzLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9ID0gX3JlZjtcbiAgY29uc3QgdGhyZXNob2xkcyA9IGdldERpc3RhbmNlVGhyZXNob2xkcyhjb250YWluZXIsIGF4aXMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpO1xuICBjb25zdCBpc0Nsb3NlclRvRW5kID0gZGlzdGFuY2VUb0VkZ2VzW2F4aXMuZW5kXSA8IGRpc3RhbmNlVG9FZGdlc1theGlzLnN0YXJ0XTtcbiAgaWYgKGlzQ2xvc2VyVG9FbmQpIHtcbiAgICByZXR1cm4gZ2V0VmFsdWUoe1xuICAgICAgZGlzdGFuY2VUb0VkZ2U6IGRpc3RhbmNlVG9FZGdlc1theGlzLmVuZF0sXG4gICAgICB0aHJlc2hvbGRzLFxuICAgICAgZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC0xICogZ2V0VmFsdWUoe1xuICAgIGRpc3RhbmNlVG9FZGdlOiBkaXN0YW5jZVRvRWRnZXNbYXhpcy5zdGFydF0sXG4gICAgdGhyZXNob2xkcyxcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbn0pO1xuXG52YXIgYWRqdXN0Rm9yU2l6ZUxpbWl0cyA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjb250YWluZXIsXG4gICAgc3ViamVjdCxcbiAgICBwcm9wb3NlZFNjcm9sbFxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNUb29CaWdWZXJ0aWNhbGx5ID0gc3ViamVjdC5oZWlnaHQgPiBjb250YWluZXIuaGVpZ2h0O1xuICBjb25zdCBpc1Rvb0JpZ0hvcml6b250YWxseSA9IHN1YmplY3Qud2lkdGggPiBjb250YWluZXIud2lkdGg7XG4gIGlmICghaXNUb29CaWdIb3Jpem9udGFsbHkgJiYgIWlzVG9vQmlnVmVydGljYWxseSkge1xuICAgIHJldHVybiBwcm9wb3NlZFNjcm9sbDtcbiAgfVxuICBpZiAoaXNUb29CaWdIb3Jpem9udGFsbHkgJiYgaXNUb29CaWdWZXJ0aWNhbGx5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBpc1Rvb0JpZ0hvcml6b250YWxseSA/IDAgOiBwcm9wb3NlZFNjcm9sbC54LFxuICAgIHk6IGlzVG9vQmlnVmVydGljYWxseSA/IDAgOiBwcm9wb3NlZFNjcm9sbC55XG4gIH07XG59KTtcblxuY29uc3QgY2xlYW4gPSBhcHBseSh2YWx1ZSA9PiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSk7XG52YXIgZ2V0U2Nyb2xsJDEgPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBjb250YWluZXIsXG4gICAgc3ViamVjdCxcbiAgICBjZW50ZXIsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0gPSBfcmVmO1xuICBjb25zdCBkaXN0YW5jZVRvRWRnZXMgPSB7XG4gICAgdG9wOiBjZW50ZXIueSAtIGNvbnRhaW5lci50b3AsXG4gICAgcmlnaHQ6IGNvbnRhaW5lci5yaWdodCAtIGNlbnRlci54LFxuICAgIGJvdHRvbTogY29udGFpbmVyLmJvdHRvbSAtIGNlbnRlci55LFxuICAgIGxlZnQ6IGNlbnRlci54IC0gY29udGFpbmVyLmxlZnRcbiAgfTtcbiAgY29uc3QgeSA9IGdldFNjcm9sbE9uQXhpcyh7XG4gICAgY29udGFpbmVyLFxuICAgIGRpc3RhbmNlVG9FZGdlcyxcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGF4aXM6IHZlcnRpY2FsLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgY29uc3QgeCA9IGdldFNjcm9sbE9uQXhpcyh7XG4gICAgY29udGFpbmVyLFxuICAgIGRpc3RhbmNlVG9FZGdlcyxcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGF4aXM6IGhvcml6b250YWwsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBjb25zdCByZXF1aXJlZCA9IGNsZWFuKHtcbiAgICB4LFxuICAgIHlcbiAgfSk7XG4gIGlmIChpc0VxdWFsJDEocmVxdWlyZWQsIG9yaWdpbikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsaW1pdGVkID0gYWRqdXN0Rm9yU2l6ZUxpbWl0cyh7XG4gICAgY29udGFpbmVyLFxuICAgIHN1YmplY3QsXG4gICAgcHJvcG9zZWRTY3JvbGw6IHJlcXVpcmVkXG4gIH0pO1xuICBpZiAoIWxpbWl0ZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaXNFcXVhbCQxKGxpbWl0ZWQsIG9yaWdpbikgPyBudWxsIDogbGltaXRlZDtcbn0pO1xuXG5jb25zdCBzbWFsbGVzdFNpZ25lZCA9IGFwcGx5KHZhbHVlID0+IHtcbiAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID4gMCA/IDEgOiAtMTtcbn0pO1xuY29uc3QgZ2V0T3ZlcmxhcCA9ICgoKSA9PiB7XG4gIGNvbnN0IGdldFJlbWFpbmRlciA9ICh0YXJnZXQsIG1heCkgPT4ge1xuICAgIGlmICh0YXJnZXQgPCAwKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0ID4gbWF4KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0IC0gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgcmV0dXJuIF9yZWYgPT4ge1xuICAgIGxldCB7XG4gICAgICBjdXJyZW50LFxuICAgICAgbWF4LFxuICAgICAgY2hhbmdlXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgdGFyZ2V0U2Nyb2xsID0gYWRkKGN1cnJlbnQsIGNoYW5nZSk7XG4gICAgY29uc3Qgb3ZlcmxhcCA9IHtcbiAgICAgIHg6IGdldFJlbWFpbmRlcih0YXJnZXRTY3JvbGwueCwgbWF4LngpLFxuICAgICAgeTogZ2V0UmVtYWluZGVyKHRhcmdldFNjcm9sbC55LCBtYXgueSlcbiAgICB9O1xuICAgIGlmIChpc0VxdWFsJDEob3ZlcmxhcCwgb3JpZ2luKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBvdmVybGFwO1xuICB9O1xufSkoKTtcbmNvbnN0IGNhblBhcnRpYWxseVNjcm9sbCA9IF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICBtYXg6IHJhd01heCxcbiAgICBjdXJyZW50LFxuICAgIGNoYW5nZVxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IG1heCA9IHtcbiAgICB4OiBNYXRoLm1heChjdXJyZW50LngsIHJhd01heC54KSxcbiAgICB5OiBNYXRoLm1heChjdXJyZW50LnksIHJhd01heC55KVxuICB9O1xuICBjb25zdCBzbWFsbGVzdENoYW5nZSA9IHNtYWxsZXN0U2lnbmVkKGNoYW5nZSk7XG4gIGNvbnN0IG92ZXJsYXAgPSBnZXRPdmVybGFwKHtcbiAgICBtYXgsXG4gICAgY3VycmVudCxcbiAgICBjaGFuZ2U6IHNtYWxsZXN0Q2hhbmdlXG4gIH0pO1xuICBpZiAoIW92ZXJsYXApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc21hbGxlc3RDaGFuZ2UueCAhPT0gMCAmJiBvdmVybGFwLnggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc21hbGxlc3RDaGFuZ2UueSAhPT0gMCAmJiBvdmVybGFwLnkgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgY2FuU2Nyb2xsV2luZG93ID0gKHZpZXdwb3J0LCBjaGFuZ2UpID0+IGNhblBhcnRpYWxseVNjcm9sbCh7XG4gIGN1cnJlbnQ6IHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LFxuICBtYXg6IHZpZXdwb3J0LnNjcm9sbC5tYXgsXG4gIGNoYW5nZVxufSk7XG5jb25zdCBnZXRXaW5kb3dPdmVybGFwID0gKHZpZXdwb3J0LCBjaGFuZ2UpID0+IHtcbiAgaWYgKCFjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIGNoYW5nZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBtYXggPSB2aWV3cG9ydC5zY3JvbGwubWF4O1xuICBjb25zdCBjdXJyZW50ID0gdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQ7XG4gIHJldHVybiBnZXRPdmVybGFwKHtcbiAgICBjdXJyZW50LFxuICAgIG1heCxcbiAgICBjaGFuZ2VcbiAgfSk7XG59O1xuY29uc3QgY2FuU2Nyb2xsRHJvcHBhYmxlID0gKGRyb3BwYWJsZSwgY2hhbmdlKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBjYW5QYXJ0aWFsbHlTY3JvbGwoe1xuICAgIGN1cnJlbnQ6IGZyYW1lLnNjcm9sbC5jdXJyZW50LFxuICAgIG1heDogZnJhbWUuc2Nyb2xsLm1heCxcbiAgICBjaGFuZ2VcbiAgfSk7XG59O1xuY29uc3QgZ2V0RHJvcHBhYmxlT3ZlcmxhcCA9IChkcm9wcGFibGUsIGNoYW5nZSkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgY2hhbmdlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBnZXRPdmVybGFwKHtcbiAgICBjdXJyZW50OiBmcmFtZS5zY3JvbGwuY3VycmVudCxcbiAgICBtYXg6IGZyYW1lLnNjcm9sbC5tYXgsXG4gICAgY2hhbmdlXG4gIH0pO1xufTtcblxudmFyIGdldFdpbmRvd1Njcm9sbENoYW5nZSA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICB2aWV3cG9ydCxcbiAgICBzdWJqZWN0LFxuICAgIGNlbnRlcixcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9ID0gX3JlZjtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0U2Nyb2xsJDEoe1xuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgY29udGFpbmVyOiB2aWV3cG9ydC5mcmFtZSxcbiAgICBzdWJqZWN0LFxuICAgIGNlbnRlcixcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiBzY3JvbGwgJiYgY2FuU2Nyb2xsV2luZG93KHZpZXdwb3J0LCBzY3JvbGwpID8gc2Nyb2xsIDogbnVsbDtcbn0pO1xuXG52YXIgZ2V0RHJvcHBhYmxlU2Nyb2xsQ2hhbmdlID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGRyb3BwYWJsZSxcbiAgICBzdWJqZWN0LFxuICAgIGNlbnRlcixcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9ID0gX3JlZjtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzY3JvbGwgPSBnZXRTY3JvbGwkMSh7XG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBjb250YWluZXI6IGZyYW1lLnBhZ2VNYXJnaW5Cb3gsXG4gICAgc3ViamVjdCxcbiAgICBjZW50ZXIsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICByZXR1cm4gc2Nyb2xsICYmIGNhblNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUsIHNjcm9sbCkgPyBzY3JvbGwgOiBudWxsO1xufSk7XG5cbnZhciBzY3JvbGwgPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgc3RhdGUsXG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIHNjcm9sbFdpbmRvdyxcbiAgICBzY3JvbGxEcm9wcGFibGUsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9ID0gX3JlZjtcbiAgY29uc3QgY2VudGVyID0gc3RhdGUuY3VycmVudC5wYWdlLmJvcmRlckJveENlbnRlcjtcbiAgY29uc3QgZHJhZ2dhYmxlID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IHN1YmplY3QgPSBkcmFnZ2FibGUucGFnZS5tYXJnaW5Cb3g7XG4gIGlmIChzdGF0ZS5pc1dpbmRvd1Njcm9sbEFsbG93ZWQpIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHN0YXRlLnZpZXdwb3J0O1xuICAgIGNvbnN0IGNoYW5nZSA9IGdldFdpbmRvd1Njcm9sbENoYW5nZSh7XG4gICAgICBkcmFnU3RhcnRUaW1lLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBzdWJqZWN0LFxuICAgICAgY2VudGVyLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICBzY3JvbGxXaW5kb3coY2hhbmdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgZHJvcHBhYmxlID0gZ2V0QmVzdFNjcm9sbGFibGVEcm9wcGFibGUoe1xuICAgIGNlbnRlcixcbiAgICBkZXN0aW5hdGlvbjogd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KSxcbiAgICBkcm9wcGFibGVzOiBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNcbiAgfSk7XG4gIGlmICghZHJvcHBhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNoYW5nZSA9IGdldERyb3BwYWJsZVNjcm9sbENoYW5nZSh7XG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBkcm9wcGFibGUsXG4gICAgc3ViamVjdCxcbiAgICBjZW50ZXIsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBpZiAoY2hhbmdlKSB7XG4gICAgc2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBjaGFuZ2UpO1xuICB9XG59KTtcblxudmFyIGNyZWF0ZUZsdWlkU2Nyb2xsZXIgPSAoX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZSxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zID0gKCkgPT4gZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNjaGVkdWxlV2luZG93U2Nyb2xsID0gcmFmU2NoZChzY3JvbGxXaW5kb3cpO1xuICBjb25zdCBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbCA9IHJhZlNjaGQoc2Nyb2xsRHJvcHBhYmxlKTtcbiAgbGV0IGRyYWdnaW5nID0gbnVsbDtcbiAgY29uc3QgdHJ5U2Nyb2xsID0gc3RhdGUgPT4ge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmbHVpZCBzY3JvbGwgaWYgbm90IGRyYWdnaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBkcmFnU3RhcnRUaW1lXG4gICAgfSA9IGRyYWdnaW5nO1xuICAgIHNjcm9sbCh7XG4gICAgICBzdGF0ZSxcbiAgICAgIHNjcm9sbFdpbmRvdzogc2NoZWR1bGVXaW5kb3dTY3JvbGwsXG4gICAgICBzY3JvbGxEcm9wcGFibGU6IHNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsLFxuICAgICAgZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHN0YXJ0JDEgPSBzdGF0ZSA9PiB7XG4gICAgc3RhcnQoKTtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IGF1dG8gc2Nyb2xsaW5nIHdoZW4gYWxyZWFkeSBzdGFydGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGRyYWdTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCB3YXNTY3JvbGxOZWVkZWQgPSBmYWxzZTtcbiAgICBjb25zdCBmYWtlU2Nyb2xsQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB3YXNTY3JvbGxOZWVkZWQgPSB0cnVlO1xuICAgIH07XG4gICAgc2Nyb2xsKHtcbiAgICAgIHN0YXRlLFxuICAgICAgZHJhZ1N0YXJ0VGltZTogMCxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IGZhbHNlLFxuICAgICAgc2Nyb2xsV2luZG93OiBmYWtlU2Nyb2xsQ2FsbGJhY2ssXG4gICAgICBzY3JvbGxEcm9wcGFibGU6IGZha2VTY3JvbGxDYWxsYmFjayxcbiAgICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgICB9KTtcbiAgICBkcmFnZ2luZyA9IHtcbiAgICAgIGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiB3YXNTY3JvbGxOZWVkZWRcbiAgICB9O1xuICAgIGZpbmlzaCgpO1xuICAgIGlmICh3YXNTY3JvbGxOZWVkZWQpIHtcbiAgICAgIHRyeVNjcm9sbChzdGF0ZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGVXaW5kb3dTY3JvbGwuY2FuY2VsKCk7XG4gICAgc2NoZWR1bGVEcm9wcGFibGVTY3JvbGwuY2FuY2VsKCk7XG4gICAgZHJhZ2dpbmcgPSBudWxsO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCQxLFxuICAgIHN0b3AsXG4gICAgc2Nyb2xsOiB0cnlTY3JvbGxcbiAgfTtcbn0pO1xuXG52YXIgY3JlYXRlSnVtcFNjcm9sbGVyID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIG1vdmUsXG4gICAgc2Nyb2xsRHJvcHBhYmxlLFxuICAgIHNjcm9sbFdpbmRvd1xuICB9ID0gX3JlZjtcbiAgY29uc3QgbW92ZUJ5T2Zmc2V0ID0gKHN0YXRlLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBjbGllbnQgPSBhZGQoc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uLCBvZmZzZXQpO1xuICAgIG1vdmUoe1xuICAgICAgY2xpZW50XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4gPSAoZHJvcHBhYmxlLCBjaGFuZ2UpID0+IHtcbiAgICBpZiAoIWNhblNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUsIGNoYW5nZSkpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IG92ZXJsYXAgPSBnZXREcm9wcGFibGVPdmVybGFwKGRyb3BwYWJsZSwgY2hhbmdlKTtcbiAgICBpZiAoIW92ZXJsYXApIHtcbiAgICAgIHNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgY2hhbmdlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsID0gc3VidHJhY3QoY2hhbmdlLCBvdmVybGFwKTtcbiAgICBzY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIHdoYXRUaGVEcm9wcGFibGVDYW5TY3JvbGwpO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IHN1YnRyYWN0KGNoYW5nZSwgd2hhdFRoZURyb3BwYWJsZUNhblNjcm9sbCk7XG4gICAgcmV0dXJuIHJlbWFpbmRlcjtcbiAgfTtcbiAgY29uc3Qgc2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbiA9IChpc1dpbmRvd1Njcm9sbEFsbG93ZWQsIHZpZXdwb3J0LCBjaGFuZ2UpID0+IHtcbiAgICBpZiAoIWlzV2luZG93U2Nyb2xsQWxsb3dlZCkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgaWYgKCFjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIGNoYW5nZSkpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IG92ZXJsYXAgPSBnZXRXaW5kb3dPdmVybGFwKHZpZXdwb3J0LCBjaGFuZ2UpO1xuICAgIGlmICghb3ZlcmxhcCkge1xuICAgICAgc2Nyb2xsV2luZG93KGNoYW5nZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgd2hhdFRoZVdpbmRvd0NhblNjcm9sbCA9IHN1YnRyYWN0KGNoYW5nZSwgb3ZlcmxhcCk7XG4gICAgc2Nyb2xsV2luZG93KHdoYXRUaGVXaW5kb3dDYW5TY3JvbGwpO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IHN1YnRyYWN0KGNoYW5nZSwgd2hhdFRoZVdpbmRvd0NhblNjcm9sbCk7XG4gICAgcmV0dXJuIHJlbWFpbmRlcjtcbiAgfTtcbiAgY29uc3QganVtcFNjcm9sbGVyID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBzdGF0ZS5zY3JvbGxKdW1wUmVxdWVzdDtcbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICAgICFkZXN0aW5hdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwZXJmb3JtIGEganVtcCBzY3JvbGwgd2hlbiB0aGVyZSBpcyBubyBkZXN0aW5hdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBkcm9wcGFibGVSZW1haW5kZXIgPSBzY3JvbGxEcm9wcGFibGVBc011Y2hBc0l0Q2FuKHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tkZXN0aW5hdGlvbl0sIHJlcXVlc3QpO1xuICAgIGlmICghZHJvcHBhYmxlUmVtYWluZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZXdwb3J0ID0gc3RhdGUudmlld3BvcnQ7XG4gICAgY29uc3Qgd2luZG93UmVtYWluZGVyID0gc2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbihzdGF0ZS5pc1dpbmRvd1Njcm9sbEFsbG93ZWQsIHZpZXdwb3J0LCBkcm9wcGFibGVSZW1haW5kZXIpO1xuICAgIGlmICghd2luZG93UmVtYWluZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1vdmVCeU9mZnNldChzdGF0ZSwgd2luZG93UmVtYWluZGVyKTtcbiAgfTtcbiAgcmV0dXJuIGp1bXBTY3JvbGxlcjtcbn0pO1xuXG52YXIgY3JlYXRlQXV0b1Njcm9sbGVyID0gKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHNjcm9sbERyb3BwYWJsZSxcbiAgICBzY3JvbGxXaW5kb3csXG4gICAgbW92ZSxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0gPSBfcmVmO1xuICBjb25zdCBmbHVpZFNjcm9sbGVyID0gY3JlYXRlRmx1aWRTY3JvbGxlcih7XG4gICAgc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZSxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBjb25zdCBqdW1wU2Nyb2xsID0gY3JlYXRlSnVtcFNjcm9sbGVyKHtcbiAgICBtb3ZlLFxuICAgIHNjcm9sbFdpbmRvdyxcbiAgICBzY3JvbGxEcm9wcGFibGVcbiAgfSk7XG4gIGNvbnN0IHNjcm9sbCA9IHN0YXRlID0+IHtcbiAgICBjb25zdCBhdXRvU2Nyb2xsZXJPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICAgIGlmIChhdXRvU2Nyb2xsZXJPcHRpb25zLmRpc2FibGVkIHx8IHN0YXRlLnBoYXNlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdGTFVJRCcpIHtcbiAgICAgIGZsdWlkU2Nyb2xsZXIuc2Nyb2xsKHN0YXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5zY3JvbGxKdW1wUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBqdW1wU2Nyb2xsKHN0YXRlKTtcbiAgfTtcbiAgY29uc3Qgc2Nyb2xsZXIgPSB7XG4gICAgc2Nyb2xsLFxuICAgIHN0YXJ0OiBmbHVpZFNjcm9sbGVyLnN0YXJ0LFxuICAgIHN0b3A6IGZsdWlkU2Nyb2xsZXIuc3RvcFxuICB9O1xuICByZXR1cm4gc2Nyb2xsZXI7XG59KTtcblxuY29uc3QgcHJlZml4ID0gJ2RhdGEtcmZkJztcbmNvbnN0IGRyYWdIYW5kbGUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gYCR7cHJlZml4fS1kcmFnLWhhbmRsZWA7XG4gIHJldHVybiB7XG4gICAgYmFzZSxcbiAgICBkcmFnZ2FibGVJZDogYCR7YmFzZX0tZHJhZ2dhYmxlLWlkYCxcbiAgICBjb250ZXh0SWQ6IGAke2Jhc2V9LWNvbnRleHQtaWRgXG4gIH07XG59KSgpO1xuY29uc3QgZHJhZ2dhYmxlID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9IGAke3ByZWZpeH0tZHJhZ2dhYmxlYDtcbiAgcmV0dXJuIHtcbiAgICBiYXNlLFxuICAgIGNvbnRleHRJZDogYCR7YmFzZX0tY29udGV4dC1pZGAsXG4gICAgaWQ6IGAke2Jhc2V9LWlkYFxuICB9O1xufSkoKTtcbmNvbnN0IGRyb3BwYWJsZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBgJHtwcmVmaXh9LWRyb3BwYWJsZWA7XG4gIHJldHVybiB7XG4gICAgYmFzZSxcbiAgICBjb250ZXh0SWQ6IGAke2Jhc2V9LWNvbnRleHQtaWRgLFxuICAgIGlkOiBgJHtiYXNlfS1pZGBcbiAgfTtcbn0pKCk7XG5jb25zdCBzY3JvbGxDb250YWluZXIgPSB7XG4gIGNvbnRleHRJZDogYCR7cHJlZml4fS1zY3JvbGwtY29udGFpbmVyLWNvbnRleHQtaWRgXG59O1xuXG5jb25zdCBtYWtlR2V0U2VsZWN0b3IgPSBjb250ZXh0ID0+IGF0dHJpYnV0ZSA9PiBgWyR7YXR0cmlidXRlfT1cIiR7Y29udGV4dH1cIl1gO1xuY29uc3QgZ2V0U3R5bGVzID0gKHJ1bGVzLCBwcm9wZXJ0eSkgPT4gcnVsZXMubWFwKHJ1bGUgPT4ge1xuICBjb25zdCB2YWx1ZSA9IHJ1bGUuc3R5bGVzW3Byb3BlcnR5XTtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gYCR7cnVsZS5zZWxlY3Rvcn0geyAke3ZhbHVlfSB9YDtcbn0pLmpvaW4oJyAnKTtcbmNvbnN0IG5vUG9pbnRlckV2ZW50cyA9ICdwb2ludGVyLWV2ZW50czogbm9uZTsnO1xudmFyIGdldFN0eWxlcyQxID0gKGNvbnRleHRJZCA9PiB7XG4gIGNvbnN0IGdldFNlbGVjdG9yID0gbWFrZUdldFNlbGVjdG9yKGNvbnRleHRJZCk7XG4gIGNvbnN0IGRyYWdIYW5kbGUkMSA9ICgoKSA9PiB7XG4gICAgY29uc3QgZ3JhYkN1cnNvciA9IGBcbiAgICAgIGN1cnNvcjogLXdlYmtpdC1ncmFiO1xuICAgICAgY3Vyc29yOiBncmFiO1xuICAgIGA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdG9yOiBnZXRTZWxlY3RvcihkcmFnSGFuZGxlLmNvbnRleHRJZCksXG4gICAgICBzdHlsZXM6IHtcbiAgICAgICAgYWx3YXlzOiBgXG4gICAgICAgICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xuICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLDAsMCwwKTtcbiAgICAgICAgICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcbiAgICAgICAgYCxcbiAgICAgICAgcmVzdGluZzogZ3JhYkN1cnNvcixcbiAgICAgICAgZHJhZ2dpbmc6IG5vUG9pbnRlckV2ZW50cyxcbiAgICAgICAgZHJvcEFuaW1hdGluZzogZ3JhYkN1cnNvclxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG4gIGNvbnN0IGRyYWdnYWJsZSQxID0gKCgpID0+IHtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gYFxuICAgICAgdHJhbnNpdGlvbjogJHt0cmFuc2l0aW9ucy5vdXRPZlRoZVdheX07XG4gICAgYDtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyYWdnYWJsZS5jb250ZXh0SWQpLFxuICAgICAgc3R5bGVzOiB7XG4gICAgICAgIGRyYWdnaW5nOiB0cmFuc2l0aW9uLFxuICAgICAgICBkcm9wQW5pbWF0aW5nOiB0cmFuc2l0aW9uLFxuICAgICAgICB1c2VyQ2FuY2VsOiB0cmFuc2l0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbiAgY29uc3QgZHJvcHBhYmxlJDEgPSB7XG4gICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyb3BwYWJsZS5jb250ZXh0SWQpLFxuICAgIHN0eWxlczoge1xuICAgICAgYWx3YXlzOiBgb3ZlcmZsb3ctYW5jaG9yOiBub25lO2BcbiAgICB9XG4gIH07XG4gIGNvbnN0IGJvZHkgPSB7XG4gICAgc2VsZWN0b3I6ICdib2R5JyxcbiAgICBzdHlsZXM6IHtcbiAgICAgIGRyYWdnaW5nOiBgXG4gICAgICAgIGN1cnNvcjogZ3JhYmJpbmc7XG4gICAgICAgIGN1cnNvcjogLXdlYmtpdC1ncmFiYmluZztcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgb3ZlcmZsb3ctYW5jaG9yOiBub25lO1xuICAgICAgYFxuICAgIH1cbiAgfTtcbiAgY29uc3QgcnVsZXMgPSBbZHJhZ2dhYmxlJDEsIGRyYWdIYW5kbGUkMSwgZHJvcHBhYmxlJDEsIGJvZHldO1xuICByZXR1cm4ge1xuICAgIGFsd2F5czogZ2V0U3R5bGVzKHJ1bGVzLCAnYWx3YXlzJyksXG4gICAgcmVzdGluZzogZ2V0U3R5bGVzKHJ1bGVzLCAncmVzdGluZycpLFxuICAgIGRyYWdnaW5nOiBnZXRTdHlsZXMocnVsZXMsICdkcmFnZ2luZycpLFxuICAgIGRyb3BBbmltYXRpbmc6IGdldFN0eWxlcyhydWxlcywgJ2Ryb3BBbmltYXRpbmcnKSxcbiAgICB1c2VyQ2FuY2VsOiBnZXRTdHlsZXMocnVsZXMsICd1c2VyQ2FuY2VsJylcbiAgfTtcbn0pO1xuXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCQxIDogdXNlRWZmZWN0O1xudmFyIHVzZUxheW91dEVmZmVjdCA9IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q7XG5cbmNvbnN0IGdldEhlYWQgPSAoKSA9PiB7XG4gIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJyk7XG4gICFoZWFkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpbmQgdGhlIGhlYWQgdG8gYXBwZW5kIGEgc3R5bGUgdG8nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBoZWFkO1xufTtcbmNvbnN0IGNyZWF0ZVN0eWxlRWwgPSBub25jZSA9PiB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgaWYgKG5vbmNlKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgfVxuICBlbC50eXBlID0gJ3RleHQvY3NzJztcbiAgcmV0dXJuIGVsO1xufTtcbmZ1bmN0aW9uIHVzZVN0eWxlTWFyc2hhbChjb250ZXh0SWQsIG5vbmNlKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZU1lbW8oKCkgPT4gZ2V0U3R5bGVzJDEoY29udGV4dElkKSwgW2NvbnRleHRJZF0pO1xuICBjb25zdCBhbHdheXNSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGR5bmFtaWNSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldER5bmFtaWNTdHlsZSA9IHVzZUNhbGxiYWNrKG1lbW9pemVPbmUocHJvcG9zZWQgPT4ge1xuICAgIGNvbnN0IGVsID0gZHluYW1pY1JlZi5jdXJyZW50O1xuICAgICFlbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzZXQgZHluYW1pYyBzdHlsZSBlbGVtZW50IGlmIGl0IGlzIG5vdCBzZXQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgZWwudGV4dENvbnRlbnQgPSBwcm9wb3NlZDtcbiAgfSksIFtdKTtcbiAgY29uc3Qgc2V0QWx3YXlzU3R5bGUgPSB1c2VDYWxsYmFjayhwcm9wb3NlZCA9PiB7XG4gICAgY29uc3QgZWwgPSBhbHdheXNSZWYuY3VycmVudDtcbiAgICAhZWwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2V0IGR5bmFtaWMgc3R5bGUgZWxlbWVudCBpZiBpdCBpcyBub3Qgc2V0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGVsLnRleHRDb250ZW50ID0gcHJvcG9zZWQ7XG4gIH0sIFtdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAhKCFhbHdheXNSZWYuY3VycmVudCAmJiAhZHluYW1pY1JlZi5jdXJyZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ3N0eWxlIGVsZW1lbnRzIGFscmVhZHkgbW91bnRlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBhbHdheXMgPSBjcmVhdGVTdHlsZUVsKG5vbmNlKTtcbiAgICBjb25zdCBkeW5hbWljID0gY3JlYXRlU3R5bGVFbChub25jZSk7XG4gICAgYWx3YXlzUmVmLmN1cnJlbnQgPSBhbHdheXM7XG4gICAgZHluYW1pY1JlZi5jdXJyZW50ID0gZHluYW1pYztcbiAgICBhbHdheXMuc2V0QXR0cmlidXRlKGAke3ByZWZpeH0tYWx3YXlzYCwgY29udGV4dElkKTtcbiAgICBkeW5hbWljLnNldEF0dHJpYnV0ZShgJHtwcmVmaXh9LWR5bmFtaWNgLCBjb250ZXh0SWQpO1xuICAgIGdldEhlYWQoKS5hcHBlbmRDaGlsZChhbHdheXMpO1xuICAgIGdldEhlYWQoKS5hcHBlbmRDaGlsZChkeW5hbWljKTtcbiAgICBzZXRBbHdheXNTdHlsZShzdHlsZXMuYWx3YXlzKTtcbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnJlc3RpbmcpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCByZW1vdmUgPSByZWYgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgICFjdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHVubW91bnQgcmVmIGFzIGl0IGlzIG5vdCBzZXQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAgIGdldEhlYWQoKS5yZW1vdmVDaGlsZChjdXJyZW50KTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIHJlbW92ZShhbHdheXNSZWYpO1xuICAgICAgcmVtb3ZlKGR5bmFtaWNSZWYpO1xuICAgIH07XG4gIH0sIFtub25jZSwgc2V0QWx3YXlzU3R5bGUsIHNldER5bmFtaWNTdHlsZSwgc3R5bGVzLmFsd2F5cywgc3R5bGVzLnJlc3RpbmcsIGNvbnRleHRJZF0pO1xuICBjb25zdCBkcmFnZ2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHNldER5bmFtaWNTdHlsZShzdHlsZXMuZHJhZ2dpbmcpLCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMuZHJhZ2dpbmddKTtcbiAgY29uc3QgZHJvcHBpbmcgPSB1c2VDYWxsYmFjayhyZWFzb24gPT4ge1xuICAgIGlmIChyZWFzb24gPT09ICdEUk9QJykge1xuICAgICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5kcm9wQW5pbWF0aW5nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy51c2VyQ2FuY2VsKTtcbiAgfSwgW3NldER5bmFtaWNTdHlsZSwgc3R5bGVzLmRyb3BBbmltYXRpbmcsIHN0eWxlcy51c2VyQ2FuY2VsXSk7XG4gIGNvbnN0IHJlc3RpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFkeW5hbWljUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5yZXN0aW5nKTtcbiAgfSwgW3NldER5bmFtaWNTdHlsZSwgc3R5bGVzLnJlc3RpbmddKTtcbiAgY29uc3QgbWFyc2hhbCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBkcmFnZ2luZyxcbiAgICBkcm9wcGluZyxcbiAgICByZXN0aW5nXG4gIH0pLCBbZHJhZ2dpbmcsIGRyb3BwaW5nLCByZXN0aW5nXSk7XG4gIHJldHVybiBtYXJzaGFsO1xufVxuXG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKHBhcmVudE5vZGUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuXG52YXIgZ2V0V2luZG93RnJvbUVsID0gKGVsID0+IGVsPy5vd25lckRvY3VtZW50Py5kZWZhdWx0VmlldyB8fCB3aW5kb3cpO1xuXG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KGVsKSB7XG4gIHJldHVybiBlbCBpbnN0YW5jZW9mIGdldFdpbmRvd0Zyb21FbChlbCkuSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGZpbmREcmFnSGFuZGxlKGNvbnRleHRJZCwgZHJhZ2dhYmxlSWQpIHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBgWyR7ZHJhZ0hhbmRsZS5jb250ZXh0SWR9PVwiJHtjb250ZXh0SWR9XCJdYDtcbiAgY29uc3QgcG9zc2libGUgPSBxdWVyeVNlbGVjdG9yQWxsKGRvY3VtZW50LCBzZWxlY3Rvcik7XG4gIGlmICghcG9zc2libGUubGVuZ3RoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgVW5hYmxlIHRvIGZpbmQgYW55IGRyYWcgaGFuZGxlcyBpbiB0aGUgY29udGV4dCBcIiR7Y29udGV4dElkfVwiYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaGFuZGxlID0gcG9zc2libGUuZmluZChlbCA9PiB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShkcmFnSGFuZGxlLmRyYWdnYWJsZUlkKSA9PT0gZHJhZ2dhYmxlSWQ7XG4gIH0pO1xuICBpZiAoIWhhbmRsZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFVuYWJsZSB0byBmaW5kIGRyYWcgaGFuZGxlIHdpdGggaWQgXCIke2RyYWdnYWJsZUlkfVwiIGFzIG5vIGhhbmRsZSB3aXRoIGEgbWF0Y2hpbmcgaWQgd2FzIGZvdW5kYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpc0h0bWxFbGVtZW50KGhhbmRsZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdkcmFnIGhhbmRsZSBuZWVkcyB0byBiZSBhIEhUTUxFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZTtcbn1cblxuZnVuY3Rpb24gdXNlRm9jdXNNYXJzaGFsKGNvbnRleHRJZCkge1xuICBjb25zdCBlbnRyaWVzUmVmID0gdXNlUmVmKHt9KTtcbiAgY29uc3QgcmVjb3JkUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCByZXN0b3JlRm9jdXNGcmFtZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcmVnaXN0ZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiByZWdpc3RlcihpZCwgZm9jdXMpIHtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIGlkLFxuICAgICAgZm9jdXNcbiAgICB9O1xuICAgIGVudHJpZXNSZWYuY3VycmVudFtpZF0gPSBlbnRyeTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5yZWdpc3RlcigpIHtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBlbnRyaWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZW50cmllc1tpZF07XG4gICAgICBpZiAoY3VycmVudCAhPT0gZW50cnkpIHtcbiAgICAgICAgZGVsZXRlIGVudHJpZXNbaWRdO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgdHJ5R2l2ZUZvY3VzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5R2l2ZUZvY3VzKHRyeUdpdmVGb2N1c1RvKSB7XG4gICAgY29uc3QgaGFuZGxlID0gZmluZERyYWdIYW5kbGUoY29udGV4dElkLCB0cnlHaXZlRm9jdXNUbyk7XG4gICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIGhhbmRsZS5mb2N1cygpO1xuICAgIH1cbiAgfSwgW2NvbnRleHRJZF0pO1xuICBjb25zdCB0cnlTaGlmdFJlY29yZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVNoaWZ0UmVjb3JkKHByZXZpb3VzLCByZWRpcmVjdFRvKSB7XG4gICAgaWYgKHJlY29yZFJlZi5jdXJyZW50ID09PSBwcmV2aW91cykge1xuICAgICAgcmVjb3JkUmVmLmN1cnJlbnQgPSByZWRpcmVjdFRvO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCkge1xuICAgIGlmIChyZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICByZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIGNvbnN0IHJlY29yZCA9IHJlY29yZFJlZi5jdXJyZW50O1xuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICB0cnlHaXZlRm9jdXMocmVjb3JkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3RyeUdpdmVGb2N1c10pO1xuICBjb25zdCB0cnlSZWNvcmRGb2N1cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlY29yZEZvY3VzKGlkKSB7XG4gICAgcmVjb3JkUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIGNvbnN0IGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmICghZm9jdXNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZm9jdXNlZC5nZXRBdHRyaWJ1dGUoZHJhZ0hhbmRsZS5kcmFnZ2FibGVJZCkgIT09IGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlY29yZFJlZi5jdXJyZW50ID0gaWQ7XG4gIH0sIFtdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyRnJhbWVPblVubW91bnQoKSB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgY29uc3QgZnJhbWVJZCA9IHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IG1hcnNoYWwgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcmVnaXN0ZXIsXG4gICAgdHJ5UmVjb3JkRm9jdXMsXG4gICAgdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQsXG4gICAgdHJ5U2hpZnRSZWNvcmRcbiAgfSksIFtyZWdpc3RlciwgdHJ5UmVjb3JkRm9jdXMsIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkLCB0cnlTaGlmdFJlY29yZF0pO1xuICByZXR1cm4gbWFyc2hhbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVnaXN0cnkoKSB7XG4gIGNvbnN0IGVudHJpZXMgPSB7XG4gICAgZHJhZ2dhYmxlczoge30sXG4gICAgZHJvcHBhYmxlczoge31cbiAgfTtcbiAgY29uc3Qgc3Vic2NyaWJlcnMgPSBbXTtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNiKSB7XG4gICAgc3Vic2NyaWJlcnMucHVzaChjYik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgY29uc3QgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGNiKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeShldmVudCkge1xuICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGgpIHtcbiAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goY2IgPT4gY2IoZXZlbnQpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZmluZERyYWdnYWJsZUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZW50cmllcy5kcmFnZ2FibGVzW2lkXSB8fCBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldERyYWdnYWJsZUJ5SWQoaWQpIHtcbiAgICBjb25zdCBlbnRyeSA9IGZpbmREcmFnZ2FibGVCeUlkKGlkKTtcbiAgICAhZW50cnkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBkcmFnZ2FibGUgZW50cnkgd2l0aCBpZCBbJHtpZH1dYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuICBjb25zdCBkcmFnZ2FibGVBUEkgPSB7XG4gICAgcmVnaXN0ZXI6IGVudHJ5ID0+IHtcbiAgICAgIGVudHJpZXMuZHJhZ2dhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgICAgbm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ0FERElUSU9OJyxcbiAgICAgICAgdmFsdWU6IGVudHJ5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZTogKGVudHJ5LCBsYXN0KSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZW50cmllcy5kcmFnZ2FibGVzW2xhc3QuZGVzY3JpcHRvci5pZF07XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQudW5pcXVlSWQgIT09IGVudHJ5LnVuaXF1ZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBlbnRyaWVzLmRyYWdnYWJsZXNbbGFzdC5kZXNjcmlwdG9yLmlkXTtcbiAgICAgIGVudHJpZXMuZHJhZ2dhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgIH0sXG4gICAgdW5yZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBlbnRyeS5kZXNjcmlwdG9yLmlkO1xuICAgICAgY29uc3QgY3VycmVudCA9IGZpbmREcmFnZ2FibGVCeUlkKGRyYWdnYWJsZUlkKTtcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZW50cnkudW5pcXVlSWQgIT09IGN1cnJlbnQudW5pcXVlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGVudHJpZXMuZHJhZ2dhYmxlc1tkcmFnZ2FibGVJZF07XG4gICAgICBpZiAoZW50cmllcy5kcm9wcGFibGVzW2VudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWRdKSB7XG4gICAgICAgIG5vdGlmeSh7XG4gICAgICAgICAgdHlwZTogJ1JFTU9WQUwnLFxuICAgICAgICAgIHZhbHVlOiBlbnRyeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEJ5SWQ6IGdldERyYWdnYWJsZUJ5SWQsXG4gICAgZmluZEJ5SWQ6IGZpbmREcmFnZ2FibGVCeUlkLFxuICAgIGV4aXN0czogaWQgPT4gQm9vbGVhbihmaW5kRHJhZ2dhYmxlQnlJZChpZCkpLFxuICAgIGdldEFsbEJ5VHlwZTogdHlwZSA9PiBPYmplY3QudmFsdWVzKGVudHJpZXMuZHJhZ2dhYmxlcykuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LmRlc2NyaXB0b3IudHlwZSA9PT0gdHlwZSlcbiAgfTtcbiAgZnVuY3Rpb24gZmluZERyb3BwYWJsZUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZW50cmllcy5kcm9wcGFibGVzW2lkXSB8fCBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldERyb3BwYWJsZUJ5SWQoaWQpIHtcbiAgICBjb25zdCBlbnRyeSA9IGZpbmREcm9wcGFibGVCeUlkKGlkKTtcbiAgICAhZW50cnkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBkcm9wcGFibGUgZW50cnkgd2l0aCBpZCBbJHtpZH1dYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuICBjb25zdCBkcm9wcGFibGVBUEkgPSB7XG4gICAgcmVnaXN0ZXI6IGVudHJ5ID0+IHtcbiAgICAgIGVudHJpZXMuZHJvcHBhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgIH0sXG4gICAgdW5yZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGZpbmREcm9wcGFibGVCeUlkKGVudHJ5LmRlc2NyaXB0b3IuaWQpO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeS51bmlxdWVJZCAhPT0gY3VycmVudC51bmlxdWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWxldGUgZW50cmllcy5kcm9wcGFibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdO1xuICAgIH0sXG4gICAgZ2V0QnlJZDogZ2V0RHJvcHBhYmxlQnlJZCxcbiAgICBmaW5kQnlJZDogZmluZERyb3BwYWJsZUJ5SWQsXG4gICAgZXhpc3RzOiBpZCA9PiBCb29sZWFuKGZpbmREcm9wcGFibGVCeUlkKGlkKSksXG4gICAgZ2V0QWxsQnlUeXBlOiB0eXBlID0+IE9iamVjdC52YWx1ZXMoZW50cmllcy5kcm9wcGFibGVzKS5maWx0ZXIoZW50cnkgPT4gZW50cnkuZGVzY3JpcHRvci50eXBlID09PSB0eXBlKVxuICB9O1xuICBmdW5jdGlvbiBjbGVhbigpIHtcbiAgICBlbnRyaWVzLmRyYWdnYWJsZXMgPSB7fTtcbiAgICBlbnRyaWVzLmRyb3BwYWJsZXMgPSB7fTtcbiAgICBzdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGVBUEksXG4gICAgZHJvcHBhYmxlOiBkcm9wcGFibGVBUEksXG4gICAgc3Vic2NyaWJlLFxuICAgIGNsZWFuXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVJlZ2lzdHJ5KCkge1xuICBjb25zdCByZWdpc3RyeSA9IHVzZU1lbW8oY3JlYXRlUmVnaXN0cnksIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIGlmIChSZWFjdC52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE2JykgfHwgUmVhY3QudmVyc2lvbi5zdGFydHNXaXRoKCcxNycpKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZWdpc3RyeS5jbGVhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWdpc3RyeS5jbGVhbigpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtyZWdpc3RyeV0pO1xuICByZXR1cm4gcmVnaXN0cnk7XG59XG5cbnZhciBTdG9yZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG52YXIgZ2V0Qm9keUVsZW1lbnQgPSAoKCkgPT4ge1xuICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgIWJvZHkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCBkb2N1bWVudC5ib2R5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gYm9keTtcbn0pO1xuXG5jb25zdCB2aXN1YWxseUhpZGRlbiA9IHtcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHdpZHRoOiAnMXB4JyxcbiAgaGVpZ2h0OiAnMXB4JyxcbiAgbWFyZ2luOiAnLTFweCcsXG4gIGJvcmRlcjogJzAnLFxuICBwYWRkaW5nOiAnMCcsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgY2xpcDogJ3JlY3QoMCAwIDAgMCknLFxuICAnY2xpcC1wYXRoJzogJ2luc2V0KDEwMCUpJ1xufTtcbnZhciB2aXN1YWxseUhpZGRlbiQxID0gdmlzdWFsbHlIaWRkZW47XG5cbmNvbnN0IGdldElkID0gY29udGV4dElkID0+IGByZmQtYW5ub3VuY2VtZW50LSR7Y29udGV4dElkfWA7XG5mdW5jdGlvbiB1c2VBbm5vdW5jZXIoY29udGV4dElkKSB7XG4gIGNvbnN0IGlkID0gdXNlTWVtbygoKSA9PiBnZXRJZChjb250ZXh0SWQpLCBbY29udGV4dElkXSk7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIHNldHVwKCkge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmVmLmN1cnJlbnQgPSBlbDtcbiAgICBlbC5pZCA9IGlkO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ2Fzc2VydGl2ZScpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1hdG9taWMnLCAndHJ1ZScpO1xuICAgIF9leHRlbmRzKGVsLnN0eWxlLCB2aXN1YWxseUhpZGRlbiQxKTtcbiAgICBnZXRCb2R5RWxlbWVudCgpLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBjb25zdCBib2R5ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGJvZHkuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsID09PSByZWYuY3VycmVudCkge1xuICAgICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW2lkXSk7XG4gIGNvbnN0IGFubm91bmNlID0gdXNlQ2FsbGJhY2sobWVzc2FnZSA9PiB7XG4gICAgY29uc3QgZWwgPSByZWYuY3VycmVudDtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBBIHNjcmVlbiByZWFkZXIgbWVzc2FnZSB3YXMgdHJ5aW5nIHRvIGJlIGFubm91bmNlZCBidXQgaXQgd2FzIHVuYWJsZSB0byBkbyBzby5cbiAgICAgIFRoaXMgY2FuIG9jY3VyIGlmIHlvdSB1bm1vdW50IHlvdXIgPERyYWdEcm9wQ29udGV4dCAvPiBpbiB5b3VyIG9uRHJhZ0VuZC5cbiAgICAgIENvbnNpZGVyIGNhbGxpbmcgcHJvdmlkZWQuYW5ub3VuY2UoKSBiZWZvcmUgdGhlIHVubW91bnQgc28gdGhhdCB0aGUgaW5zdHJ1Y3Rpb24gd2lsbFxuICAgICAgbm90IGJlIGxvc3QgZm9yIHVzZXJzIHJlbHlpbmcgb24gYSBzY3JlZW4gcmVhZGVyLlxuXG4gICAgICBNZXNzYWdlIG5vdCBwYXNzZWQgdG8gc2NyZWVuIHJlYWRlcjpcblxuICAgICAgXCIke21lc3NhZ2V9XCJcbiAgICBgKSA6IHZvaWQgMDtcbiAgfSwgW10pO1xuICByZXR1cm4gYW5ub3VuY2U7XG59XG5cbmxldCBjb3VudCQxID0gMDtcbmNvbnN0IGRlZmF1bHRzID0ge1xuICBzZXBhcmF0b3I6ICc6Oidcbn07XG5mdW5jdGlvbiByZXNldERlcHJlY2F0ZWRVbmlxdWVJZCgpIHtcbiAgY291bnQkMSA9IDA7XG59XG5mdW5jdGlvbiB1c2VEZXByZWNhdGVkVW5pcXVlSWQocHJlZml4LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHM7XG4gIH1cbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gYCR7cHJlZml4fSR7b3B0aW9ucy5zZXBhcmF0b3J9JHtjb3VudCQxKyt9YCwgW29wdGlvbnMuc2VwYXJhdG9yLCBwcmVmaXhdKTtcbn1cbmZ1bmN0aW9uIHVzZVVuaXF1ZUlkKHByZWZpeCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzO1xuICB9XG4gIGNvbnN0IGlkID0gUmVhY3QudXNlSWQoKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gYCR7cHJlZml4fSR7b3B0aW9ucy5zZXBhcmF0b3J9JHtpZH1gLCBbb3B0aW9ucy5zZXBhcmF0b3IsIHByZWZpeCwgaWRdKTtcbn1cbnZhciB1c2VVbmlxdWVJZCQxID0gJ3VzZUlkJyBpbiBSZWFjdCA/IHVzZVVuaXF1ZUlkIDogdXNlRGVwcmVjYXRlZFVuaXF1ZUlkO1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50SWQoX3JlZikge1xuICBsZXQge1xuICAgIGNvbnRleHRJZCxcbiAgICB1bmlxdWVJZFxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIGByZmQtaGlkZGVuLXRleHQtJHtjb250ZXh0SWR9LSR7dW5pcXVlSWR9YDtcbn1cbmZ1bmN0aW9uIHVzZUhpZGRlblRleHRFbGVtZW50KF9yZWYyKSB7XG4gIGxldCB7XG4gICAgY29udGV4dElkLFxuICAgIHRleHRcbiAgfSA9IF9yZWYyO1xuICBjb25zdCB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkJDEoJ2hpZGRlbi10ZXh0Jywge1xuICAgIHNlcGFyYXRvcjogJy0nXG4gIH0pO1xuICBjb25zdCBpZCA9IHVzZU1lbW8oKCkgPT4gZ2V0RWxlbWVudElkKHtcbiAgICBjb250ZXh0SWQsXG4gICAgdW5pcXVlSWRcbiAgfSksIFt1bmlxdWVJZCwgY29udGV4dElkXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLmlkID0gaWQ7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZ2V0Qm9keUVsZW1lbnQoKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgICAgIGlmIChib2R5LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbaWQsIHRleHRdKTtcbiAgcmV0dXJuIGlkO1xufVxuXG52YXIgQXBwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbnZhciBwZWVyRGVwZW5kZW5jaWVzID0ge1xuXHRyZWFjdDogXCJeMTYuOC41IHx8IF4xNy4wLjAgfHwgXjE4LjAuMFwiLFxuXHRcInJlYWN0LWRvbVwiOiBcIl4xNi44LjUgfHwgXjE3LjAuMCB8fCBeMTguMC4wXCJcbn07XG5cbmNvbnN0IHNlbXZlciA9IC8oXFxkKylcXC4oXFxkKylcXC4oXFxkKykvO1xuY29uc3QgZ2V0VmVyc2lvbiA9IHZhbHVlID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gc2VtdmVyLmV4ZWModmFsdWUpO1xuICAhKHJlc3VsdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFVuYWJsZSB0byBwYXJzZSBSZWFjdCB2ZXJzaW9uICR7dmFsdWV9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBtYWpvciA9IE51bWJlcihyZXN1bHRbMV0pO1xuICBjb25zdCBtaW5vciA9IE51bWJlcihyZXN1bHRbMl0pO1xuICBjb25zdCBwYXRjaCA9IE51bWJlcihyZXN1bHRbM10pO1xuICByZXR1cm4ge1xuICAgIG1ham9yLFxuICAgIG1pbm9yLFxuICAgIHBhdGNoLFxuICAgIHJhdzogdmFsdWVcbiAgfTtcbn07XG5jb25zdCBpc1NhdGlzZmllZCA9IChleHBlY3RlZCwgYWN0dWFsKSA9PiB7XG4gIGlmIChhY3R1YWwubWFqb3IgPiBleHBlY3RlZC5tYWpvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhY3R1YWwubWFqb3IgPCBleHBlY3RlZC5tYWpvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYWN0dWFsLm1pbm9yID4gZXhwZWN0ZWQubWlub3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYWN0dWFsLm1pbm9yIDwgZXhwZWN0ZWQubWlub3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGFjdHVhbC5wYXRjaCA+PSBleHBlY3RlZC5wYXRjaDtcbn07XG52YXIgY2hlY2tSZWFjdFZlcnNpb24gPSAoKHBlZXJEZXBWYWx1ZSwgYWN0dWFsVmFsdWUpID0+IHtcbiAgY29uc3QgcGVlckRlcCA9IGdldFZlcnNpb24ocGVlckRlcFZhbHVlKTtcbiAgY29uc3QgYWN0dWFsID0gZ2V0VmVyc2lvbihhY3R1YWxWYWx1ZSk7XG4gIGlmIChpc1NhdGlzZmllZChwZWVyRGVwLCBhY3R1YWwpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIFJlYWN0IHZlcnNpb246IFske2FjdHVhbC5yYXd9XVxuICAgIGRvZXMgbm90IHNhdGlzZnkgZXhwZWN0ZWQgcGVlciBkZXBlbmRlbmN5IHZlcnNpb246IFske3BlZXJEZXAucmF3fV1cblxuICAgIFRoaXMgY2FuIHJlc3VsdCBpbiBydW4gdGltZSBidWdzLCBhbmQgZXZlbiBmYXRhbCBjcmFzaGVzXG4gIGApIDogdm9pZCAwO1xufSk7XG5cbmNvbnN0IHN1ZmZpeCA9IGBcbiAgV2UgZXhwZWN0IGEgaHRtbDUgZG9jdHlwZTogPCFkb2N0eXBlIGh0bWw+XG4gIFRoaXMgaXMgdG8gZW5zdXJlIGNvbnNpc3RlbnQgYnJvd3NlciBsYXlvdXQgYW5kIG1lYXN1cmVtZW50XG5cbiAgTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQvYmxvYi9tYWluL2RvY3MvZ3VpZGVzL2RvY3R5cGUubWRcbmA7XG52YXIgY2hlY2tEb2N0eXBlID0gKGRvYyA9PiB7XG4gIGNvbnN0IGRvY3R5cGUgPSBkb2MuZG9jdHlwZTtcbiAgaWYgKCFkb2N0eXBlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBObyA8IWRvY3R5cGUgaHRtbD4gZm91bmQuXG5cbiAgICAgICR7c3VmZml4fVxuICAgIGApIDogdm9pZCAwO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZG9jdHlwZS5uYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdodG1sJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgVW5leHBlY3RlZCA8IWRvY3R5cGU+IGZvdW5kOiAoJHtkb2N0eXBlLm5hbWV9KVxuXG4gICAgICAke3N1ZmZpeH1cbiAgICBgKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAoZG9jdHlwZS5wdWJsaWNJZCAhPT0gJycpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIFVuZXhwZWN0ZWQgPCFkb2N0eXBlPiBwdWJsaWNJZCBmb3VuZDogKCR7ZG9jdHlwZS5wdWJsaWNJZH0pXG4gICAgICBBIGh0bWw1IGRvY3R5cGUgZG9lcyBub3QgaGF2ZSBhIHB1YmxpY0lkXG5cbiAgICAgICR7c3VmZml4fVxuICAgIGApIDogdm9pZCAwO1xuICB9XG59KTtcblxuZnVuY3Rpb24gdXNlRGV2KHVzZUhvb2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB1c2VIb29rKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlRGV2U2V0dXBXYXJuaW5nKGZuLCBpbnB1dHMpIHtcbiAgdXNlRGV2KCgpID0+IHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoYFxuICAgICAgICAgIEEgc2V0dXAgcHJvYmxlbSB3YXMgZW5jb3VudGVyZWQuXG5cbiAgICAgICAgICA+ICR7ZS5tZXNzYWdlfVxuICAgICAgICBgKTtcbiAgICAgIH1cbiAgICB9LCBpbnB1dHMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlU3RhcnR1cFZhbGlkYXRpb24oKSB7XG4gIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgY2hlY2tSZWFjdFZlcnNpb24ocGVlckRlcGVuZGVuY2llcy5yZWFjdCwgUmVhY3QudmVyc2lvbik7XG4gICAgY2hlY2tEb2N0eXBlKGRvY3VtZW50KTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VQcmV2aW91cyhjdXJyZW50KSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZihjdXJyZW50KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBsb2NrID0gbnVsbDtcbiAgZnVuY3Rpb24gaXNDbGFpbWVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKGxvY2spO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWN0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsb2NrO1xuICB9XG4gIGZ1bmN0aW9uIGNsYWltKGFiYW5kb24pIHtcbiAgICAhIWxvY2sgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY2xhaW0gbG9jayBhcyBpdCBpcyBhbHJlYWR5IGNsYWltZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgbmV3TG9jayA9IHtcbiAgICAgIGFiYW5kb25cbiAgICB9O1xuICAgIGxvY2sgPSBuZXdMb2NrO1xuICAgIHJldHVybiBuZXdMb2NrO1xuICB9XG4gIGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgIWxvY2sgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcmVsZWFzZSBsb2NrIHdoZW4gdGhlcmUgaXMgbm8gbG9jaycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBsb2NrID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiB0cnlBYmFuZG9uKCkge1xuICAgIGlmIChsb2NrKSB7XG4gICAgICBsb2NrLmFiYW5kb24oKTtcbiAgICAgIHJlbGVhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0NsYWltZWQsXG4gICAgaXNBY3RpdmUsXG4gICAgY2xhaW0sXG4gICAgcmVsZWFzZSxcbiAgICB0cnlBYmFuZG9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzRHJhZ2dpbmcoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmlzRHJhZ2dpbmc7XG59XG5cbmNvbnN0IHRhYiA9IDk7XG5jb25zdCBlbnRlciA9IDEzO1xuY29uc3QgZXNjYXBlID0gMjc7XG5jb25zdCBzcGFjZSA9IDMyO1xuY29uc3QgcGFnZVVwID0gMzM7XG5jb25zdCBwYWdlRG93biA9IDM0O1xuY29uc3QgZW5kID0gMzU7XG5jb25zdCBob21lID0gMzY7XG5jb25zdCBhcnJvd0xlZnQgPSAzNztcbmNvbnN0IGFycm93VXAgPSAzODtcbmNvbnN0IGFycm93UmlnaHQgPSAzOTtcbmNvbnN0IGFycm93RG93biA9IDQwO1xuXG5jb25zdCBwcmV2ZW50ZWRLZXlzID0ge1xuICBbZW50ZXJdOiB0cnVlLFxuICBbdGFiXTogdHJ1ZVxufTtcbnZhciBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMgPSAoZXZlbnQgPT4ge1xuICBpZiAocHJldmVudGVkS2V5c1tldmVudC5rZXlDb2RlXSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn0pO1xuXG5jb25zdCBzdXBwb3J0ZWRFdmVudE5hbWUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbYmFzZSwgYG1zJHtiYXNlfWAsIGB3ZWJraXQke2Jhc2V9YCwgYG1veiR7YmFzZX1gLCBgbyR7YmFzZX1gXTtcbiAgY29uc3Qgc3VwcG9ydGVkID0gY2FuZGlkYXRlcy5maW5kKGV2ZW50TmFtZSA9PiBgb24ke2V2ZW50TmFtZX1gIGluIGRvY3VtZW50KTtcbiAgcmV0dXJuIHN1cHBvcnRlZCB8fCBiYXNlO1xufSkoKTtcbnZhciBzdXBwb3J0ZWRQYWdlVmlzaWJpbGl0eUV2ZW50TmFtZSA9IHN1cHBvcnRlZEV2ZW50TmFtZTtcblxuY29uc3QgcHJpbWFyeUJ1dHRvbiA9IDA7XG5jb25zdCBzbG9wcHlDbGlja1RocmVzaG9sZCA9IDU7XG5mdW5jdGlvbiBpc1Nsb3BweUNsaWNrVGhyZXNob2xkRXhjZWVkZWQob3JpZ2luYWwsIGN1cnJlbnQpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGN1cnJlbnQueCAtIG9yaWdpbmFsLngpID49IHNsb3BweUNsaWNrVGhyZXNob2xkIHx8IE1hdGguYWJzKGN1cnJlbnQueSAtIG9yaWdpbmFsLnkpID49IHNsb3BweUNsaWNrVGhyZXNob2xkO1xufVxuY29uc3QgaWRsZSQxID0ge1xuICB0eXBlOiAnSURMRSdcbn07XG5mdW5jdGlvbiBnZXRDYXB0dXJlQmluZGluZ3MoX3JlZikge1xuICBsZXQge1xuICAgIGNhbmNlbCxcbiAgICBjb21wbGV0ZWQsXG4gICAgZ2V0UGhhc2UsXG4gICAgc2V0UGhhc2VcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ21vdXNlbW92ZScsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYnV0dG9uLFxuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICBpZiAoYnV0dG9uICE9PSBwcmltYXJ5QnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICB5OiBjbGllbnRZXG4gICAgICB9O1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcGhhc2UuYWN0aW9ucy5tb3ZlKHBvaW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgIShwaGFzZS50eXBlID09PSAnUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGJlIElETEUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICBjb25zdCBwZW5kaW5nID0gcGhhc2UucG9pbnQ7XG4gICAgICBpZiAoIWlzU2xvcHB5Q2xpY2tUaHJlc2hvbGRFeGNlZWRlZChwZW5kaW5nLCBwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBwaGFzZS5hY3Rpb25zLmZsdWlkTGlmdChwb2ludCk7XG4gICAgICBzZXRQaGFzZSh7XG4gICAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICAgIGFjdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNldXAnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMuZHJvcCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNlZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gZXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMoZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnc2Nyb2xsJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9LFxuICAgIGZuOiAoKSA9PiB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnd2Via2l0bW91c2Vmb3JjZWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICAhKHBoYXNlLnR5cGUgIT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIHBoYXNlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgaWYgKHBoYXNlLmFjdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKSkge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZFBhZ2VWaXNpYmlsaXR5RXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5mdW5jdGlvbiB1c2VNb3VzZVNlbnNvcihhcGkpIHtcbiAgY29uc3QgcGhhc2VSZWYgPSB1c2VSZWYoaWRsZSQxKTtcbiAgY29uc3QgdW5iaW5kRXZlbnRzUmVmID0gdXNlUmVmKG5vb3AkMik7XG4gIGNvbnN0IHN0YXJ0Q2FwdHVyZUJpbmRpbmcgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5idXR0b24gIT09IHByaW1hcnlCdXR0b24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IHByZXZlbnRGb3JjZVByZXNzQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcGkuZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUoaWQpO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghYXBpLmNhbkdldExvY2soaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9KSwgW2FwaV0pO1xuICBjb25zdCBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gbGlzdGVuRm9yQ2FwdHVyZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbcHJldmVudEZvcmNlUHJlc3NCaW5kaW5nLCBzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmcsIHN0YXJ0Q2FwdHVyZUJpbmRpbmddKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50ID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnSURMRScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGhhc2VSZWYuY3VycmVudCA9IGlkbGUkMTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbiAgY29uc3QgY2FuY2VsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHBoYXNlID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBzdG9wKCk7XG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuY2FuY2VsKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmFib3J0KCk7XG4gICAgfVxuICB9LCBbc3RvcF0pO1xuICBjb25zdCBiaW5kQ2FwdHVyaW5nRXZlbnRzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gYmluZENhcHR1cmluZ0V2ZW50cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBiaW5kaW5ncyA9IGdldENhcHR1cmVCaW5kaW5ncyh7XG4gICAgICBjYW5jZWwsXG4gICAgICBjb21wbGV0ZWQ6IHN0b3AsXG4gICAgICBnZXRQaGFzZTogKCkgPT4gcGhhc2VSZWYuY3VycmVudCxcbiAgICAgIHNldFBoYXNlOiBwaGFzZSA9PiB7XG4gICAgICAgIHBoYXNlUmVmLmN1cnJlbnQgPSBwaGFzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBiaW5kaW5ncywgb3B0aW9ucyk7XG4gIH0sIFtjYW5jZWwsIHN0b3BdKTtcbiAgY29uc3Qgc3RhcnRQZW5kaW5nRHJhZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpIHtcbiAgICAhKHBoYXNlUmVmLmN1cnJlbnQudHlwZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIG1vdmUgZnJvbSBJRExFIHRvIFBFTkRJTkcgZHJhZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBwaGFzZVJlZi5jdXJyZW50ID0ge1xuICAgICAgdHlwZTogJ1BFTkRJTkcnLFxuICAgICAgcG9pbnQsXG4gICAgICBhY3Rpb25zXG4gICAgfTtcbiAgICBiaW5kQ2FwdHVyaW5nRXZlbnRzKCk7XG4gIH0sIFtiaW5kQ2FwdHVyaW5nRXZlbnRzXSk7XG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIH07XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlXSk7XG59XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5jb25zdCBzY3JvbGxKdW1wS2V5cyA9IHtcbiAgW3BhZ2VEb3duXTogdHJ1ZSxcbiAgW3BhZ2VVcF06IHRydWUsXG4gIFtob21lXTogdHJ1ZSxcbiAgW2VuZF06IHRydWVcbn07XG5mdW5jdGlvbiBnZXREcmFnZ2luZ0JpbmRpbmdzKGFjdGlvbnMsIHN0b3ApIHtcbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHN0b3AoKTtcbiAgICBhY3Rpb25zLmNhbmNlbCgpO1xuICB9XG4gIGZ1bmN0aW9uIGRyb3AoKSB7XG4gICAgc3RvcCgpO1xuICAgIGFjdGlvbnMuZHJvcCgpO1xuICB9XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gZXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gc3BhY2UpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZHJvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dEb3duKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZURvd24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93VXApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlVXAoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93UmlnaHQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlUmlnaHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93TGVmdCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVMZWZ0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzY3JvbGxKdW1wS2V5c1tldmVudC5rZXlDb2RlXSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMoZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNlZG93bicsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2V1cCcsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnY2xpY2snLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoc3RhcnQnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnd2hlZWwnLFxuICAgIGZuOiBjYW5jZWwsXG4gICAgb3B0aW9uczoge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkUGFnZVZpc2liaWxpdHlFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cbmZ1bmN0aW9uIHVzZUtleWJvYXJkU2Vuc29yKGFwaSkge1xuICBjb25zdCB1bmJpbmRFdmVudHNSZWYgPSB1c2VSZWYobm9vcCQxKTtcbiAgY29uc3Qgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSAhPT0gc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZURyYWcgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFwcmVEcmFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBsZXQgaXNDYXB0dXJpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgYWN0aW9ucyA9IHByZURyYWcuc25hcExpZnQoKTtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAhaXNDYXB0dXJpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBjYXB0dXJpbmcgYSBrZXlib2FyZCBkcmFnIHdoZW4gbm90IGNhcHR1cmluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgaXNDYXB0dXJpbmcgPSBmYWxzZTtcbiAgICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgICAgfVxuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgZ2V0RHJhZ2dpbmdCaW5kaW5ncyhhY3Rpb25zLCBzdG9wKSwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgW2FwaV0pO1xuICBjb25zdCBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5U3RhcnRDYXB0dXJlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtzdGFydENhcHR1cmVCaW5kaW5nXSk7XG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIH07XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlXSk7XG59XG5cbmNvbnN0IGlkbGUgPSB7XG4gIHR5cGU6ICdJRExFJ1xufTtcbmNvbnN0IHRpbWVGb3JMb25nUHJlc3MgPSAxMjA7XG5jb25zdCBmb3JjZVByZXNzVGhyZXNob2xkID0gMC4xNTtcbmZ1bmN0aW9uIGdldFdpbmRvd0JpbmRpbmdzKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjYW5jZWwsXG4gICAgZ2V0UGhhc2VcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ29yaWVudGF0aW9uY2hhbmdlJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdyZXNpemUnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2NvbnRleHRtZW51JyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGVzY2FwZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRQYWdlVmlzaWJpbGl0eUV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlQmluZGluZ3MoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBjYW5jZWwsXG4gICAgY29tcGxldGVkLFxuICAgIGdldFBoYXNlXG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAndG91Y2htb3ZlJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwaGFzZS5oYXNNb3ZlZCA9IHRydWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFgsXG4gICAgICAgIGNsaWVudFlcbiAgICAgIH0gPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5tb3ZlKHBvaW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd0b3VjaGVuZCcsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5kcm9wKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hjYW5jZWwnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hmb3JjZWNoYW5nZScsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgICEocGhhc2UudHlwZSAhPT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgaWYgKCF0b3VjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc0ZvcmNlUHJlc3MgPSB0b3VjaC5mb3JjZSA+PSBmb3JjZVByZXNzVGhyZXNob2xkO1xuICAgICAgaWYgKCFpc0ZvcmNlUHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvdWxkUmVzcGVjdCA9IHBoYXNlLmFjdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlc3BlY3QpIHtcbiAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVzcGVjdCkge1xuICAgICAgICBpZiAocGhhc2UuaGFzTW92ZWQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZFBhZ2VWaXNpYmlsaXR5RXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5mdW5jdGlvbiB1c2VUb3VjaFNlbnNvcihhcGkpIHtcbiAgY29uc3QgcGhhc2VSZWYgPSB1c2VSZWYoaWRsZSk7XG4gIGNvbnN0IHVuYmluZEV2ZW50c1JlZiA9IHVzZVJlZihub29wJDIpO1xuICBjb25zdCBnZXRQaGFzZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGdldFBoYXNlKCkge1xuICAgIHJldHVybiBwaGFzZVJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIGNvbnN0IHNldFBoYXNlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc2V0UGhhc2UocGhhc2UpIHtcbiAgICBwaGFzZVJlZi5jdXJyZW50ID0gcGhhc2U7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICd0b3VjaHN0YXJ0JyxcbiAgICBmbjogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aW9ucyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgICBpZiAoIWFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gdG91Y2g7XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBsaXN0ZW5Gb3JDYXB0dXJlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtzdGFydENhcHR1cmVCaW5kaW5nXSk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQudHlwZSA9PT0gJ0lETEUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnQubG9uZ1ByZXNzVGltZXJJZCk7XG4gICAgfVxuICAgIHNldFBoYXNlKGlkbGUpO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZSwgc2V0UGhhc2VdKTtcbiAgY29uc3QgY2FuY2VsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHBoYXNlID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBzdG9wKCk7XG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuY2FuY2VsKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmFib3J0KCk7XG4gICAgfVxuICB9LCBbc3RvcF0pO1xuICBjb25zdCBiaW5kQ2FwdHVyaW5nRXZlbnRzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gYmluZENhcHR1cmluZ0V2ZW50cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgY2FuY2VsLFxuICAgICAgY29tcGxldGVkOiBzdG9wLFxuICAgICAgZ2V0UGhhc2VcbiAgICB9O1xuICAgIGNvbnN0IHVuYmluZFRhcmdldCA9IGJpbmRFdmVudHMod2luZG93LCBnZXRIYW5kbGVCaW5kaW5ncyhhcmdzKSwgb3B0aW9ucyk7XG4gICAgY29uc3QgdW5iaW5kV2luZG93ID0gYmluZEV2ZW50cyh3aW5kb3csIGdldFdpbmRvd0JpbmRpbmdzKGFyZ3MpLCBvcHRpb25zKTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGZ1bmN0aW9uIHVuYmluZEFsbCgpIHtcbiAgICAgIHVuYmluZFRhcmdldCgpO1xuICAgICAgdW5iaW5kV2luZG93KCk7XG4gICAgfTtcbiAgfSwgW2NhbmNlbCwgZ2V0UGhhc2UsIHN0b3BdKTtcbiAgY29uc3Qgc3RhcnREcmFnZ2luZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0RHJhZ2dpbmcoKSB7XG4gICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICEocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBzdGFydCBkcmFnZ2luZyBmcm9tIHBoYXNlICR7cGhhc2UudHlwZX1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgYWN0aW9ucyA9IHBoYXNlLmFjdGlvbnMuZmx1aWRMaWZ0KHBoYXNlLnBvaW50KTtcbiAgICBzZXRQaGFzZSh7XG4gICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgYWN0aW9ucyxcbiAgICAgIGhhc01vdmVkOiBmYWxzZVxuICAgIH0pO1xuICB9LCBbZ2V0UGhhc2UsIHNldFBoYXNlXSk7XG4gIGNvbnN0IHN0YXJ0UGVuZGluZ0RyYWcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KSB7XG4gICAgIShnZXRQaGFzZSgpLnR5cGUgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBtb3ZlIGZyb20gSURMRSB0byBQRU5ESU5HIGRyYWcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgbG9uZ1ByZXNzVGltZXJJZCA9IHNldFRpbWVvdXQoc3RhcnREcmFnZ2luZywgdGltZUZvckxvbmdQcmVzcyk7XG4gICAgc2V0UGhhc2Uoe1xuICAgICAgdHlwZTogJ1BFTkRJTkcnLFxuICAgICAgcG9pbnQsXG4gICAgICBhY3Rpb25zLFxuICAgICAgbG9uZ1ByZXNzVGltZXJJZFxuICAgIH0pO1xuICAgIGJpbmRDYXB0dXJpbmdFdmVudHMoKTtcbiAgfSwgW2JpbmRDYXB0dXJpbmdFdmVudHMsIGdldFBoYXNlLCBzZXRQaGFzZSwgc3RhcnREcmFnZ2luZ10pO1xuICB1c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHBoYXNlLmxvbmdQcmVzc1RpbWVySWQpO1xuICAgICAgICBzZXRQaGFzZShpZGxlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZ2V0UGhhc2UsIGxpc3RlbkZvckNhcHR1cmUsIHNldFBoYXNlXSk7XG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiB3ZWJraXRIYWNrKCkge1xuICAgIGNvbnN0IHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbe1xuICAgICAgZXZlbnROYW1lOiAndG91Y2htb3ZlJyxcbiAgICAgIGZuOiAoKSA9PiB7fSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiB1bmJpbmQ7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdXNlVmFsaWRhdGVTZW5zb3JIb29rcyhzZW5zb3JIb29rcykge1xuICB1c2VEZXYoKCkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzUmVmID0gdXNlUHJldmlvdXMoc2Vuc29ySG9va3MpO1xuICAgIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgICAhKHByZXZpb3VzUmVmLmN1cnJlbnQubGVuZ3RoID09PSBzZW5zb3JIb29rcy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNoYW5nZSB0aGUgYW1vdW50IG9mIHNlbnNvciBob29rcyBhZnRlciBtb3VudGluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmNvbnN0IGludGVyYWN0aXZlVGFnTmFtZXMgPSBbJ2lucHV0JywgJ2J1dHRvbicsICd0ZXh0YXJlYScsICdzZWxlY3QnLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3ZpZGVvJywgJ2F1ZGlvJ107XG5mdW5jdGlvbiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudCwgY3VycmVudCkge1xuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhhc0FuSW50ZXJhY3RpdmVUYWcgPSBpbnRlcmFjdGl2ZVRhZ05hbWVzLmluY2x1ZGVzKGN1cnJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgaWYgKGhhc0FuSW50ZXJhY3RpdmVUYWcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBhdHRyaWJ1dGUgPSBjdXJyZW50LmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gIGlmIChhdHRyaWJ1dGUgPT09ICd0cnVlJyB8fCBhdHRyaWJ1dGUgPT09ICcnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGN1cnJlbnQgPT09IHBhcmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNBbkludGVyYWN0aXZlRWxlbWVudChwYXJlbnQsIGN1cnJlbnQucGFyZW50RWxlbWVudCk7XG59XG5mdW5jdGlvbiBpc0V2ZW50SW5JbnRlcmFjdGl2ZUVsZW1lbnQoZHJhZ2dhYmxlLCBldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGlmICghaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KGRyYWdnYWJsZSwgdGFyZ2V0KTtcbn1cblxudmFyIGdldEJvcmRlckJveENlbnRlclBvc2l0aW9uID0gKGVsID0+IGdldFJlY3QoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLmNlbnRlcik7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChlbCkge1xuICByZXR1cm4gZWwgaW5zdGFuY2VvZiBnZXRXaW5kb3dGcm9tRWwoZWwpLkVsZW1lbnQ7XG59XG5cbmNvbnN0IHN1cHBvcnRlZE1hdGNoZXNOYW1lID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9ICdtYXRjaGVzJztcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBjb25zdCBjYW5kaWRhdGVzID0gW2Jhc2UsICdtc01hdGNoZXNTZWxlY3RvcicsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InXTtcbiAgY29uc3QgdmFsdWUgPSBjYW5kaWRhdGVzLmZpbmQobmFtZSA9PiBuYW1lIGluIEVsZW1lbnQucHJvdG90eXBlKTtcbiAgcmV0dXJuIHZhbHVlIHx8IGJhc2U7XG59KSgpO1xuZnVuY3Rpb24gY2xvc2VzdFBvbnlmaWxsKGVsLCBzZWxlY3Rvcikge1xuICBpZiAoZWwgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChlbFtzdXBwb3J0ZWRNYXRjaGVzTmFtZV0oc2VsZWN0b3IpKSB7XG4gICAgcmV0dXJuIGVsO1xuICB9XG4gIHJldHVybiBjbG9zZXN0UG9ueWZpbGwoZWwucGFyZW50RWxlbWVudCwgc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gY2xvc2VzdChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3RQb255ZmlsbChlbCwgc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rvcihjb250ZXh0SWQpIHtcbiAgcmV0dXJuIGBbJHtkcmFnSGFuZGxlLmNvbnRleHRJZH09XCIke2NvbnRleHRJZH1cIl1gO1xufVxuZnVuY3Rpb24gZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZXZlbnQudGFyZ2V0IG11c3QgYmUgYSBFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3Rvcihjb250ZXh0SWQpO1xuICBjb25zdCBoYW5kbGUgPSBjbG9zZXN0KHRhcmdldCwgc2VsZWN0b3IpO1xuICBpZiAoIWhhbmRsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaXNIdG1sRWxlbWVudChoYW5kbGUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZHJhZyBoYW5kbGUgbXVzdCBiZSBhIEhUTUxFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZTtcbn1cbmZ1bmN0aW9uIHRyeUdldENsb3Nlc3REcmFnZ2FibGVJZEZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KSB7XG4gIGNvbnN0IGhhbmRsZSA9IGZpbmRDbG9zZXN0RHJhZ0hhbmRsZUZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KTtcbiAgaWYgKCFoYW5kbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaGFuZGxlLmdldEF0dHJpYnV0ZShkcmFnSGFuZGxlLmRyYWdnYWJsZUlkKTtcbn1cblxuZnVuY3Rpb24gZmluZERyYWdnYWJsZShjb250ZXh0SWQsIGRyYWdnYWJsZUlkKSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gYFske2RyYWdnYWJsZS5jb250ZXh0SWR9PVwiJHtjb250ZXh0SWR9XCJdYDtcbiAgY29uc3QgcG9zc2libGUgPSBxdWVyeVNlbGVjdG9yQWxsKGRvY3VtZW50LCBzZWxlY3Rvcik7XG4gIGNvbnN0IGRyYWdnYWJsZSQxID0gcG9zc2libGUuZmluZChlbCA9PiB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShkcmFnZ2FibGUuaWQpID09PSBkcmFnZ2FibGVJZDtcbiAgfSk7XG4gIGlmICghZHJhZ2dhYmxlJDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWlzSHRtbEVsZW1lbnQoZHJhZ2dhYmxlJDEpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnRHJhZ2dhYmxlIGVsZW1lbnQgaXMgbm90IGEgSFRNTEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZHJhZ2dhYmxlJDE7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBpc0FjdGl2ZShfcmVmKSB7XG4gIGxldCB7XG4gICAgZXhwZWN0ZWQsXG4gICAgcGhhc2UsXG4gICAgaXNMb2NrQWN0aXZlLFxuICAgIHNob3VsZFdhcm5cbiAgfSA9IF9yZWY7XG4gIGlmICghaXNMb2NrQWN0aXZlKCkpIHtcbiAgICBpZiAoc2hvdWxkV2Fybikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICAgIENhbm5vdCBwZXJmb3JtIGFjdGlvbi5cbiAgICAgICAgVGhlIHNlbnNvciBubyBsb25nZXIgaGFzIGFuIGFjdGlvbiBsb2NrLlxuXG4gICAgICAgIFRpcHM6XG5cbiAgICAgICAgLSBUaHJvdyBhd2F5IHlvdXIgYWN0aW9uIGhhbmRsZXJzIHdoZW4gZm9yY2VTdG9wKCkgaXMgY2FsbGVkXG4gICAgICAgIC0gQ2hlY2sgYWN0aW9ucy5pc0FjdGl2ZSgpIGlmIHlvdSByZWFsbHkgbmVlZCB0b1xuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXhwZWN0ZWQgIT09IHBoYXNlKSB7XG4gICAgaWYgKHNob3VsZFdhcm4pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBDYW5ub3QgcGVyZm9ybSBhY3Rpb24uXG4gICAgICAgIFRoZSBhY3Rpb25zIHlvdSB1c2VkIGJlbG9uZyB0byBhbiBvdXRkYXRlZCBwaGFzZVxuXG4gICAgICAgIEN1cnJlbnQgcGhhc2U6ICR7ZXhwZWN0ZWR9XG4gICAgICAgIFlvdSBjYWxsZWQgYW4gYWN0aW9uIGZyb20gb3V0ZGF0ZWQgcGhhc2U6ICR7cGhhc2V9XG5cbiAgICAgICAgVGlwczpcblxuICAgICAgICAtIERvIG5vdCB1c2UgcHJlRHJhZ0FjdGlvbnMgYWN0aW9ucyBhZnRlciBjYWxsaW5nIHByZURyYWdBY3Rpb25zLmxpZnQoKVxuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNhblN0YXJ0KF9yZWYyKSB7XG4gIGxldCB7XG4gICAgbG9ja0FQSSxcbiAgICBzdG9yZSxcbiAgICByZWdpc3RyeSxcbiAgICBkcmFnZ2FibGVJZFxuICB9ID0gX3JlZjI7XG4gIGlmIChsb2NrQVBJLmlzQ2xhaW1lZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmZpbmRCeUlkKGRyYWdnYWJsZUlkKTtcbiAgaWYgKCFlbnRyeSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFVuYWJsZSB0byBmaW5kIGRyYWdnYWJsZSB3aXRoIGlkOiAke2RyYWdnYWJsZUlkfWApIDogdm9pZCAwO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWVudHJ5Lm9wdGlvbnMuaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghY2FuU3RhcnREcmFnKHN0b3JlLmdldFN0YXRlKCksIGRyYWdnYWJsZUlkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRyeVN0YXJ0KF9yZWYzKSB7XG4gIGxldCB7XG4gICAgbG9ja0FQSSxcbiAgICBjb250ZXh0SWQsXG4gICAgc3RvcmUsXG4gICAgcmVnaXN0cnksXG4gICAgZHJhZ2dhYmxlSWQsXG4gICAgZm9yY2VTZW5zb3JTdG9wLFxuICAgIHNvdXJjZUV2ZW50XG4gIH0gPSBfcmVmMztcbiAgY29uc3Qgc2hvdWxkU3RhcnQgPSBjYW5TdGFydCh7XG4gICAgbG9ja0FQSSxcbiAgICBzdG9yZSxcbiAgICByZWdpc3RyeSxcbiAgICBkcmFnZ2FibGVJZFxuICB9KTtcbiAgaWYgKCFzaG91bGRTdGFydCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQoZHJhZ2dhYmxlSWQpO1xuICBjb25zdCBlbCA9IGZpbmREcmFnZ2FibGUoY29udGV4dElkLCBlbnRyeS5kZXNjcmlwdG9yLmlkKTtcbiAgaWYgKCFlbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFVuYWJsZSB0byBmaW5kIGRyYWdnYWJsZSBlbGVtZW50IHdpdGggaWQ6ICR7ZHJhZ2dhYmxlSWR9YCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHNvdXJjZUV2ZW50ICYmICFlbnRyeS5vcHRpb25zLmNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzICYmIGlzRXZlbnRJbkludGVyYWN0aXZlRWxlbWVudChlbCwgc291cmNlRXZlbnQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbG9jayA9IGxvY2tBUEkuY2xhaW0oZm9yY2VTZW5zb3JTdG9wIHx8IG5vb3AkMik7XG4gIGxldCBwaGFzZSA9ICdQUkVfRFJBRyc7XG4gIGZ1bmN0aW9uIGdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzKCkge1xuICAgIHJldHVybiBlbnRyeS5vcHRpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzO1xuICB9XG4gIGZ1bmN0aW9uIGlzTG9ja0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gbG9ja0FQSS5pc0FjdGl2ZShsb2NrKTtcbiAgfVxuICBmdW5jdGlvbiB0cnlEaXNwYXRjaChleHBlY3RlZCwgZ2V0QWN0aW9uKSB7XG4gICAgaWYgKGlzQWN0aXZlKHtcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgcGhhc2UsXG4gICAgICBpc0xvY2tBY3RpdmUsXG4gICAgICBzaG91bGRXYXJuOiB0cnVlXG4gICAgfSkpIHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGdldEFjdGlvbigpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcgPSB0cnlEaXNwYXRjaC5iaW5kKG51bGwsICdEUkFHR0lORycpO1xuICBmdW5jdGlvbiBsaWZ0KGFyZ3MpIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgICBsb2NrQVBJLnJlbGVhc2UoKTtcbiAgICAgIHBoYXNlID0gJ0NPTVBMRVRFRCc7XG4gICAgfVxuICAgIGlmIChwaGFzZSAhPT0gJ1BSRV9EUkFHJykge1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgbGlmdCBpbiBwaGFzZSAke3BoYXNlfWApIDogaW52YXJpYW50KGZhbHNlKSA7XG4gICAgfVxuICAgIHN0b3JlLmRpc3BhdGNoKGxpZnQkMShhcmdzLmxpZnRBY3Rpb25BcmdzKSk7XG4gICAgcGhhc2UgPSAnRFJBR0dJTkcnO1xuICAgIGZ1bmN0aW9uIGZpbmlzaChyZWFzb24sIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGFyZ3MuY2xlYW51cCgpO1xuICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkQmxvY2tOZXh0Q2xpY2spIHtcbiAgICAgICAgY29uc3QgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFt7XG4gICAgICAgICAgZXZlbnROYW1lOiAnY2xpY2snLFxuICAgICAgICAgIGZuOiBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICAgIHNldFRpbWVvdXQodW5iaW5kKTtcbiAgICAgIH1cbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZHJvcCQxKHtcbiAgICAgICAgcmVhc29uXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc0FjdGl2ZTogKCkgPT4gaXNBY3RpdmUoe1xuICAgICAgICBleHBlY3RlZDogJ0RSQUdHSU5HJyxcbiAgICAgICAgcGhhc2UsXG4gICAgICAgIGlzTG9ja0FjdGl2ZSxcbiAgICAgICAgc2hvdWxkV2FybjogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgICAgZHJvcDogb3B0aW9ucyA9PiBmaW5pc2goJ0RST1AnLCBvcHRpb25zKSxcbiAgICAgIGNhbmNlbDogb3B0aW9ucyA9PiBmaW5pc2goJ0NBTkNFTCcsIG9wdGlvbnMpLFxuICAgICAgLi4uYXJncy5hY3Rpb25zXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmbHVpZExpZnQoY2xpZW50U2VsZWN0aW9uKSB7XG4gICAgY29uc3QgbW92ZSQxID0gcmFmU2NoZChjbGllbnQgPT4ge1xuICAgICAgdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcoKCkgPT4gbW92ZSh7XG4gICAgICAgIGNsaWVudFxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFwaSA9IGxpZnQoe1xuICAgICAgbGlmdEFjdGlvbkFyZ3M6IHtcbiAgICAgICAgaWQ6IGRyYWdnYWJsZUlkLFxuICAgICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICAgIG1vdmVtZW50TW9kZTogJ0ZMVUlEJ1xuICAgICAgfSxcbiAgICAgIGNsZWFudXA6ICgpID0+IG1vdmUkMS5jYW5jZWwoKSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgbW92ZTogbW92ZSQxXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFwaSxcbiAgICAgIG1vdmU6IG1vdmUkMVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc25hcExpZnQoKSB7XG4gICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgIG1vdmVVcDogKCkgPT4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZVVwKSxcbiAgICAgIG1vdmVSaWdodDogKCkgPT4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZVJpZ2h0KSxcbiAgICAgIG1vdmVEb3duOiAoKSA9PiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlRG93biksXG4gICAgICBtb3ZlTGVmdDogKCkgPT4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZUxlZnQpXG4gICAgfTtcbiAgICByZXR1cm4gbGlmdCh7XG4gICAgICBsaWZ0QWN0aW9uQXJnczoge1xuICAgICAgICBpZDogZHJhZ2dhYmxlSWQsXG4gICAgICAgIGNsaWVudFNlbGVjdGlvbjogZ2V0Qm9yZGVyQm94Q2VudGVyUG9zaXRpb24oZWwpLFxuICAgICAgICBtb3ZlbWVudE1vZGU6ICdTTkFQJ1xuICAgICAgfSxcbiAgICAgIGNsZWFudXA6IG5vb3AkMixcbiAgICAgIGFjdGlvbnNcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhYm9ydFByZURyYWcoKSB7XG4gICAgY29uc3Qgc2hvdWxkUmVsZWFzZSA9IGlzQWN0aXZlKHtcbiAgICAgIGV4cGVjdGVkOiAnUFJFX0RSQUcnLFxuICAgICAgcGhhc2UsXG4gICAgICBpc0xvY2tBY3RpdmUsXG4gICAgICBzaG91bGRXYXJuOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHNob3VsZFJlbGVhc2UpIHtcbiAgICAgIGxvY2tBUEkucmVsZWFzZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwcmVEcmFnID0ge1xuICAgIGlzQWN0aXZlOiAoKSA9PiBpc0FjdGl2ZSh7XG4gICAgICBleHBlY3RlZDogJ1BSRV9EUkFHJyxcbiAgICAgIHBoYXNlLFxuICAgICAgaXNMb2NrQWN0aXZlLFxuICAgICAgc2hvdWxkV2FybjogZmFsc2VcbiAgICB9KSxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzczogZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgZmx1aWRMaWZ0LFxuICAgIHNuYXBMaWZ0LFxuICAgIGFib3J0OiBhYm9ydFByZURyYWdcbiAgfTtcbiAgcmV0dXJuIHByZURyYWc7XG59XG5jb25zdCBkZWZhdWx0U2Vuc29ycyA9IFt1c2VNb3VzZVNlbnNvciwgdXNlS2V5Ym9hcmRTZW5zb3IsIHVzZVRvdWNoU2Vuc29yXTtcbmZ1bmN0aW9uIHVzZVNlbnNvck1hcnNoYWwoX3JlZjQpIHtcbiAgbGV0IHtcbiAgICBjb250ZXh0SWQsXG4gICAgc3RvcmUsXG4gICAgcmVnaXN0cnksXG4gICAgY3VzdG9tU2Vuc29ycyxcbiAgICBlbmFibGVEZWZhdWx0U2Vuc29yc1xuICB9ID0gX3JlZjQ7XG4gIGNvbnN0IHVzZVNlbnNvcnMgPSBbLi4uKGVuYWJsZURlZmF1bHRTZW5zb3JzID8gZGVmYXVsdFNlbnNvcnMgOiBbXSksIC4uLihjdXN0b21TZW5zb3JzIHx8IFtdKV07XG4gIGNvbnN0IGxvY2tBUEkgPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGUoKSlbMF07XG4gIGNvbnN0IHRyeUFiYW5kb25Mb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5QWJhbmRvbkxvY2socHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICBpZiAoaXNEcmFnZ2luZyhwcmV2aW91cykgJiYgIWlzRHJhZ2dpbmcoY3VycmVudCkpIHtcbiAgICAgIGxvY2tBUEkudHJ5QWJhbmRvbigpO1xuICAgIH1cbiAgfSwgW2xvY2tBUEldKTtcbiAgdXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIGxpc3RlblRvU3RvcmUoKSB7XG4gICAgbGV0IHByZXZpb3VzID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIHRyeUFiYW5kb25Mb2NrKHByZXZpb3VzLCBjdXJyZW50KTtcbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIFtsb2NrQVBJLCBzdG9yZSwgdHJ5QWJhbmRvbkxvY2tdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gbG9ja0FQSS50cnlBYmFuZG9uO1xuICB9LCBbbG9ja0FQSS50cnlBYmFuZG9uXSk7XG4gIGNvbnN0IGNhbkdldExvY2sgPSB1c2VDYWxsYmFjayhkcmFnZ2FibGVJZCA9PiB7XG4gICAgcmV0dXJuIGNhblN0YXJ0KHtcbiAgICAgIGxvY2tBUEksXG4gICAgICByZWdpc3RyeSxcbiAgICAgIHN0b3JlLFxuICAgICAgZHJhZ2dhYmxlSWRcbiAgICB9KTtcbiAgfSwgW2xvY2tBUEksIHJlZ2lzdHJ5LCBzdG9yZV0pO1xuICBjb25zdCB0cnlHZXRMb2NrID0gdXNlQ2FsbGJhY2soKGRyYWdnYWJsZUlkLCBmb3JjZVN0b3AsIG9wdGlvbnMpID0+IHRyeVN0YXJ0KHtcbiAgICBsb2NrQVBJLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGNvbnRleHRJZCxcbiAgICBzdG9yZSxcbiAgICBkcmFnZ2FibGVJZCxcbiAgICBmb3JjZVNlbnNvclN0b3A6IGZvcmNlU3RvcCB8fCBudWxsLFxuICAgIHNvdXJjZUV2ZW50OiBvcHRpb25zICYmIG9wdGlvbnMuc291cmNlRXZlbnQgPyBvcHRpb25zLnNvdXJjZUV2ZW50IDogbnVsbFxuICB9KSwgW2NvbnRleHRJZCwgbG9ja0FQSSwgcmVnaXN0cnksIHN0b3JlXSk7XG4gIGNvbnN0IGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQgPSB1c2VDYWxsYmFjayhldmVudCA9PiB0cnlHZXRDbG9zZXN0RHJhZ2dhYmxlSWRGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCksIFtjb250ZXh0SWRdKTtcbiAgY29uc3QgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUgPSB1c2VDYWxsYmFjayhpZCA9PiB7XG4gICAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZmluZEJ5SWQoaWQpO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5Lm9wdGlvbnMgOiBudWxsO1xuICB9LCBbcmVnaXN0cnkuZHJhZ2dhYmxlXSk7XG4gIGNvbnN0IHRyeVJlbGVhc2VMb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVsZWFzZUxvY2soKSB7XG4gICAgaWYgKCFsb2NrQVBJLmlzQ2xhaW1lZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvY2tBUEkudHJ5QWJhbmRvbigpO1xuICAgIGlmIChzdG9yZS5nZXRTdGF0ZSgpLnBoYXNlICE9PSAnSURMRScpIHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGZsdXNoKCkpO1xuICAgIH1cbiAgfSwgW2xvY2tBUEksIHN0b3JlXSk7XG4gIGNvbnN0IGlzTG9ja0NsYWltZWQgPSB1c2VDYWxsYmFjaygoKSA9PiBsb2NrQVBJLmlzQ2xhaW1lZCgpLCBbbG9ja0FQSV0pO1xuICBjb25zdCBhcGkgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY2FuR2V0TG9jayxcbiAgICB0cnlHZXRMb2NrLFxuICAgIGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQsXG4gICAgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUsXG4gICAgdHJ5UmVsZWFzZUxvY2ssXG4gICAgaXNMb2NrQ2xhaW1lZFxuICB9KSwgW2NhbkdldExvY2ssIHRyeUdldExvY2ssIGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQsIGZpbmRPcHRpb25zRm9yRHJhZ2dhYmxlLCB0cnlSZWxlYXNlTG9jaywgaXNMb2NrQ2xhaW1lZF0pO1xuICB1c2VWYWxpZGF0ZVNlbnNvckhvb2tzKHVzZVNlbnNvcnMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHVzZVNlbnNvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB1c2VTZW5zb3JzW2ldKGFwaSk7XG4gIH1cbn1cblxuY29uc3QgY3JlYXRlUmVzcG9uZGVycyA9IHByb3BzID0+ICh7XG4gIG9uQmVmb3JlQ2FwdHVyZTogdCA9PiB7XG4gICAgY29uc3Qgb25CZWZvcmVDYXB1cmVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGlmIChwcm9wcy5vbkJlZm9yZUNhcHR1cmUpIHtcbiAgICAgICAgcHJvcHMub25CZWZvcmVDYXB0dXJlKHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKFJlYWN0LnZlcnNpb24uc3RhcnRzV2l0aCgnMTYnKSB8fCBSZWFjdC52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE3JykpIHtcbiAgICAgIG9uQmVmb3JlQ2FwdXJlQ2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hTeW5jKG9uQmVmb3JlQ2FwdXJlQ2FsbGJhY2spO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVEcmFnU3RhcnQ6IHByb3BzLm9uQmVmb3JlRHJhZ1N0YXJ0LFxuICBvbkRyYWdTdGFydDogcHJvcHMub25EcmFnU3RhcnQsXG4gIG9uRHJhZ0VuZDogcHJvcHMub25EcmFnRW5kLFxuICBvbkRyYWdVcGRhdGU6IHByb3BzLm9uRHJhZ1VwZGF0ZVxufSk7XG5jb25zdCBjcmVhdGVBdXRvU2Nyb2xsZXJPcHRpb25zID0gcHJvcHMgPT4gKHtcbiAgLi4uZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMsXG4gIC4uLnByb3BzLmF1dG9TY3JvbGxlck9wdGlvbnMsXG4gIGR1cmF0aW9uRGFtcGVuaW5nOiB7XG4gICAgLi4uZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMuZHVyYXRpb25EYW1wZW5pbmcsXG4gICAgLi4ucHJvcHMuYXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9XG59KTtcbmZ1bmN0aW9uIGdldFN0b3JlKGxhenlSZWYpIHtcbiAgIWxhenlSZWYuY3VycmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHN0b3JlIGZyb20gbGF6eSByZWYnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBsYXp5UmVmLmN1cnJlbnQ7XG59XG5mdW5jdGlvbiBBcHAocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNvbnRleHRJZCxcbiAgICBzZXRDYWxsYmFja3MsXG4gICAgc2Vuc29ycyxcbiAgICBub25jZSxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBsYXp5U3RvcmVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZVN0YXJ0dXBWYWxpZGF0aW9uKCk7XG4gIGNvbnN0IGxhc3RQcm9wc1JlZiA9IHVzZVByZXZpb3VzKHByb3BzKTtcbiAgY29uc3QgZ2V0UmVzcG9uZGVycyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlUmVzcG9uZGVycyhsYXN0UHJvcHNSZWYuY3VycmVudCk7XG4gIH0sIFtsYXN0UHJvcHNSZWZdKTtcbiAgY29uc3QgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlQXV0b1Njcm9sbGVyT3B0aW9ucyhsYXN0UHJvcHNSZWYuY3VycmVudCk7XG4gIH0sIFtsYXN0UHJvcHNSZWZdKTtcbiAgY29uc3QgYW5ub3VuY2UgPSB1c2VBbm5vdW5jZXIoY29udGV4dElkKTtcbiAgY29uc3QgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQgPSB1c2VIaWRkZW5UZXh0RWxlbWVudCh7XG4gICAgY29udGV4dElkLFxuICAgIHRleHQ6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc1xuICB9KTtcbiAgY29uc3Qgc3R5bGVNYXJzaGFsID0gdXNlU3R5bGVNYXJzaGFsKGNvbnRleHRJZCwgbm9uY2UpO1xuICBjb25zdCBsYXp5RGlzcGF0Y2ggPSB1c2VDYWxsYmFjayhhY3Rpb24gPT4ge1xuICAgIGdldFN0b3JlKGxhenlTdG9yZVJlZikuZGlzcGF0Y2goYWN0aW9uKTtcbiAgfSwgW10pO1xuICBjb25zdCBtYXJzaGFsQ2FsbGJhY2tzID0gdXNlTWVtbygoKSA9PiBiaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgIHB1Ymxpc2hXaGlsZURyYWdnaW5nLFxuICAgIHVwZGF0ZURyb3BwYWJsZVNjcm9sbCxcbiAgICB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQsXG4gICAgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCxcbiAgICBjb2xsZWN0aW9uU3RhcnRpbmdcbiAgfSwgbGF6eURpc3BhdGNoKSwgW2xhenlEaXNwYXRjaF0pO1xuICBjb25zdCByZWdpc3RyeSA9IHVzZVJlZ2lzdHJ5KCk7XG4gIGNvbnN0IGRpbWVuc2lvbk1hcnNoYWwgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlRGltZW5zaW9uTWFyc2hhbChyZWdpc3RyeSwgbWFyc2hhbENhbGxiYWNrcyk7XG4gIH0sIFtyZWdpc3RyeSwgbWFyc2hhbENhbGxiYWNrc10pO1xuICBjb25zdCBhdXRvU2Nyb2xsZXIgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZUF1dG9TY3JvbGxlcih7XG4gICAgc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZTogZGltZW5zaW9uTWFyc2hhbC5zY3JvbGxEcm9wcGFibGUsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyxcbiAgICAuLi5iaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgICAgbW92ZVxuICAgIH0sIGxhenlEaXNwYXRjaClcbiAgfSksIFtkaW1lbnNpb25NYXJzaGFsLnNjcm9sbERyb3BwYWJsZSwgbGF6eURpc3BhdGNoLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXSk7XG4gIGNvbnN0IGZvY3VzTWFyc2hhbCA9IHVzZUZvY3VzTWFyc2hhbChjb250ZXh0SWQpO1xuICBjb25zdCBzdG9yZSA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlU3RvcmUoe1xuICAgIGFubm91bmNlLFxuICAgIGF1dG9TY3JvbGxlcixcbiAgICBkaW1lbnNpb25NYXJzaGFsLFxuICAgIGZvY3VzTWFyc2hhbCxcbiAgICBnZXRSZXNwb25kZXJzLFxuICAgIHN0eWxlTWFyc2hhbFxuICB9KSwgW2Fubm91bmNlLCBhdXRvU2Nyb2xsZXIsIGRpbWVuc2lvbk1hcnNoYWwsIGZvY3VzTWFyc2hhbCwgZ2V0UmVzcG9uZGVycywgc3R5bGVNYXJzaGFsXSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGxhenlTdG9yZVJlZi5jdXJyZW50ICYmIGxhenlTdG9yZVJlZi5jdXJyZW50ICE9PSBzdG9yZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygndW5leHBlY3RlZCBzdG9yZSBjaGFuZ2UnKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgbGF6eVN0b3JlUmVmLmN1cnJlbnQgPSBzdG9yZTtcbiAgY29uc3QgdHJ5UmVzZXRTdG9yZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50ID0gZ2V0U3RvcmUobGF6eVN0b3JlUmVmKTtcbiAgICBjb25zdCBzdGF0ZSA9IGN1cnJlbnQuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUucGhhc2UgIT09ICdJRExFJykge1xuICAgICAgY3VycmVudC5kaXNwYXRjaChmbHVzaCgpKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgaXNEcmFnZ2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0b3JlKGxhenlTdG9yZVJlZikuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuaXNEcmFnZ2luZztcbiAgfSwgW10pO1xuICBjb25zdCBhcHBDYWxsYmFja3MgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaXNEcmFnZ2luZyxcbiAgICB0cnlBYm9ydDogdHJ5UmVzZXRTdG9yZVxuICB9KSwgW2lzRHJhZ2dpbmcsIHRyeVJlc2V0U3RvcmVdKTtcbiAgc2V0Q2FsbGJhY2tzKGFwcENhbGxiYWNrcyk7XG4gIGNvbnN0IGdldENhbkxpZnQgPSB1c2VDYWxsYmFjayhpZCA9PiBjYW5TdGFydERyYWcoZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5nZXRTdGF0ZSgpLCBpZCksIFtdKTtcbiAgY29uc3QgZ2V0SXNNb3ZlbWVudEFsbG93ZWQgPSB1c2VDYWxsYmFjaygoKSA9PiBpc01vdmVtZW50QWxsb3dlZChnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmdldFN0YXRlKCkpLCBbXSk7XG4gIGNvbnN0IGFwcENvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgbWFyc2hhbDogZGltZW5zaW9uTWFyc2hhbCxcbiAgICBmb2N1czogZm9jdXNNYXJzaGFsLFxuICAgIGNvbnRleHRJZCxcbiAgICBjYW5MaWZ0OiBnZXRDYW5MaWZ0LFxuICAgIGlzTW92ZW1lbnRBbGxvd2VkOiBnZXRJc01vdmVtZW50QWxsb3dlZCxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCxcbiAgICByZWdpc3RyeVxuICB9KSwgW2NvbnRleHRJZCwgZGltZW5zaW9uTWFyc2hhbCwgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsIGZvY3VzTWFyc2hhbCwgZ2V0Q2FuTGlmdCwgZ2V0SXNNb3ZlbWVudEFsbG93ZWQsIHJlZ2lzdHJ5XSk7XG4gIHVzZVNlbnNvck1hcnNoYWwoe1xuICAgIGNvbnRleHRJZCxcbiAgICBzdG9yZSxcbiAgICByZWdpc3RyeSxcbiAgICBjdXN0b21TZW5zb3JzOiBzZW5zb3JzIHx8IG51bGwsXG4gICAgZW5hYmxlRGVmYXVsdFNlbnNvcnM6IHByb3BzLmVuYWJsZURlZmF1bHRTZW5zb3JzICE9PSBmYWxzZVxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdHJ5UmVzZXRTdG9yZTtcbiAgfSwgW3RyeVJlc2V0U3RvcmVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhcHBDb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJvdmlkZXIsIHtcbiAgICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gICAgc3RvcmU6IHN0b3JlXG4gIH0sIHByb3BzLmNoaWxkcmVuKSk7XG59XG5cbmxldCBjb3VudCA9IDA7XG5mdW5jdGlvbiByZXNldERlcHJlY2F0ZWRVbmlxdWVDb250ZXh0SWQoKSB7XG4gIGNvdW50ID0gMDtcbn1cbmZ1bmN0aW9uIHVzZURlcHJlY2F0ZWRVbmlxdWVDb250ZXh0SWQoKSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IGAke2NvdW50Kyt9YCwgW10pO1xufVxuZnVuY3Rpb24gdXNlVW5pcXVlQ29udGV4dElkKCkge1xuICByZXR1cm4gUmVhY3QudXNlSWQoKTtcbn1cbnZhciB1c2VVbmlxdWVDb250ZXh0SWQkMSA9ICd1c2VJZCcgaW4gUmVhY3QgPyB1c2VVbmlxdWVDb250ZXh0SWQgOiB1c2VEZXByZWNhdGVkVW5pcXVlQ29udGV4dElkO1xuXG5mdW5jdGlvbiByZXNldFNlcnZlckNvbnRleHQoKSB7XG4gIGlmICgndXNlSWQnIGluIFJlYWN0KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjYWxsIHJlc2V0U2VydmVyQ29udGV4dCB3aGVuIHVzaW5nIFJlYWN0IDE4K2ApIDogdm9pZCAwO1xuICAgIHJldHVybjtcbiAgfVxuICByZXNldERlcHJlY2F0ZWRVbmlxdWVDb250ZXh0SWQoKTtcbiAgcmVzZXREZXByZWNhdGVkVW5pcXVlSWQoKTtcbn1cbmZ1bmN0aW9uIERyYWdEcm9wQ29udGV4dChwcm9wcykge1xuICBjb25zdCBjb250ZXh0SWQgPSB1c2VVbmlxdWVDb250ZXh0SWQkMSgpO1xuICBjb25zdCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMgPSBwcm9wcy5kcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMgfHwgcHJlc2V0JDEuZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5LCBudWxsLCBzZXRDYWxsYmFja3MgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChBcHAsIHtcbiAgICBub25jZTogcHJvcHMubm9uY2UsXG4gICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgc2V0Q2FsbGJhY2tzOiBzZXRDYWxsYmFja3MsXG4gICAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zOiBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMsXG4gICAgZW5hYmxlRGVmYXVsdFNlbnNvcnM6IHByb3BzLmVuYWJsZURlZmF1bHRTZW5zb3JzLFxuICAgIHNlbnNvcnM6IHByb3BzLnNlbnNvcnMsXG4gICAgb25CZWZvcmVDYXB0dXJlOiBwcm9wcy5vbkJlZm9yZUNhcHR1cmUsXG4gICAgb25CZWZvcmVEcmFnU3RhcnQ6IHByb3BzLm9uQmVmb3JlRHJhZ1N0YXJ0LFxuICAgIG9uRHJhZ1N0YXJ0OiBwcm9wcy5vbkRyYWdTdGFydCxcbiAgICBvbkRyYWdVcGRhdGU6IHByb3BzLm9uRHJhZ1VwZGF0ZSxcbiAgICBvbkRyYWdFbmQ6IHByb3BzLm9uRHJhZ0VuZCxcbiAgICBhdXRvU2Nyb2xsZXJPcHRpb25zOiBwcm9wcy5hdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0sIHByb3BzLmNoaWxkcmVuKSk7XG59XG5cbmNvbnN0IHpJbmRleE9wdGlvbnMgPSB7XG4gIGRyYWdnaW5nOiA1MDAwLFxuICBkcm9wQW5pbWF0aW5nOiA0NTAwXG59O1xuY29uc3QgZ2V0RHJhZ2dpbmdUcmFuc2l0aW9uID0gKHNob3VsZEFuaW1hdGVEcmFnTW92ZW1lbnQsIGRyb3BwaW5nKSA9PiB7XG4gIGlmIChkcm9wcGluZykge1xuICAgIHJldHVybiB0cmFuc2l0aW9ucy5kcm9wKGRyb3BwaW5nLmR1cmF0aW9uKTtcbiAgfVxuICBpZiAoc2hvdWxkQW5pbWF0ZURyYWdNb3ZlbWVudCkge1xuICAgIHJldHVybiB0cmFuc2l0aW9ucy5zbmFwO1xuICB9XG4gIHJldHVybiB0cmFuc2l0aW9ucy5mbHVpZDtcbn07XG5jb25zdCBnZXREcmFnZ2luZ09wYWNpdHkgPSAoaXNDb21iaW5pbmcsIGlzRHJvcEFuaW1hdGluZykgPT4ge1xuICBpZiAoIWlzQ29tYmluaW5nKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gaXNEcm9wQW5pbWF0aW5nID8gY29tYmluZS5vcGFjaXR5LmRyb3AgOiBjb21iaW5lLm9wYWNpdHkuY29tYmluaW5nO1xufTtcbmNvbnN0IGdldFNob3VsZERyYWdnaW5nQW5pbWF0ZSA9IGRyYWdnaW5nID0+IHtcbiAgaWYgKGRyYWdnaW5nLmZvcmNlU2hvdWxkQW5pbWF0ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGRyYWdnaW5nLmZvcmNlU2hvdWxkQW5pbWF0ZTtcbiAgfVxuICByZXR1cm4gZHJhZ2dpbmcubW9kZSA9PT0gJ1NOQVAnO1xufTtcbmZ1bmN0aW9uIGdldERyYWdnaW5nU3R5bGUoZHJhZ2dpbmcpIHtcbiAgY29uc3QgZGltZW5zaW9uID0gZHJhZ2dpbmcuZGltZW5zaW9uO1xuICBjb25zdCBib3ggPSBkaW1lbnNpb24uY2xpZW50O1xuICBjb25zdCB7XG4gICAgb2Zmc2V0LFxuICAgIGNvbWJpbmVXaXRoLFxuICAgIGRyb3BwaW5nXG4gIH0gPSBkcmFnZ2luZztcbiAgY29uc3QgaXNDb21iaW5pbmcgPSBCb29sZWFuKGNvbWJpbmVXaXRoKTtcbiAgY29uc3Qgc2hvdWxkQW5pbWF0ZSA9IGdldFNob3VsZERyYWdnaW5nQW5pbWF0ZShkcmFnZ2luZyk7XG4gIGNvbnN0IGlzRHJvcEFuaW1hdGluZyA9IEJvb2xlYW4oZHJvcHBpbmcpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSBpc0Ryb3BBbmltYXRpbmcgPyB0cmFuc2Zvcm1zLmRyb3Aob2Zmc2V0LCBpc0NvbWJpbmluZykgOiB0cmFuc2Zvcm1zLm1vdmVUbyhvZmZzZXQpO1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICB0b3A6IGJveC5tYXJnaW5Cb3gudG9wLFxuICAgIGxlZnQ6IGJveC5tYXJnaW5Cb3gubGVmdCxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICB3aWR0aDogYm94LmJvcmRlckJveC53aWR0aCxcbiAgICBoZWlnaHQ6IGJveC5ib3JkZXJCb3guaGVpZ2h0LFxuICAgIHRyYW5zaXRpb246IGdldERyYWdnaW5nVHJhbnNpdGlvbihzaG91bGRBbmltYXRlLCBkcm9wcGluZyksXG4gICAgdHJhbnNmb3JtLFxuICAgIG9wYWNpdHk6IGdldERyYWdnaW5nT3BhY2l0eShpc0NvbWJpbmluZywgaXNEcm9wQW5pbWF0aW5nKSxcbiAgICB6SW5kZXg6IGlzRHJvcEFuaW1hdGluZyA/IHpJbmRleE9wdGlvbnMuZHJvcEFuaW1hdGluZyA6IHpJbmRleE9wdGlvbnMuZHJhZ2dpbmcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gIH07XG4gIHJldHVybiBzdHlsZTtcbn1cbmZ1bmN0aW9uIGdldFNlY29uZGFyeVN0eWxlKHNlY29uZGFyeSkge1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogdHJhbnNmb3Jtcy5tb3ZlVG8oc2Vjb25kYXJ5Lm9mZnNldCksXG4gICAgdHJhbnNpdGlvbjogc2Vjb25kYXJ5LnNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQgPyB1bmRlZmluZWQgOiAnbm9uZSdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN0eWxlJDEobWFwcGVkKSB7XG4gIHJldHVybiBtYXBwZWQudHlwZSA9PT0gJ0RSQUdHSU5HJyA/IGdldERyYWdnaW5nU3R5bGUobWFwcGVkKSA6IGdldFNlY29uZGFyeVN0eWxlKG1hcHBlZCk7XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbiQxKGRlc2NyaXB0b3IsIGVsLCB3aW5kb3dTY3JvbGwpIHtcbiAgaWYgKHdpbmRvd1Njcm9sbCA9PT0gdm9pZCAwKSB7XG4gICAgd2luZG93U2Nyb2xsID0gb3JpZ2luO1xuICB9XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBjb25zdCBib3JkZXJCb3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgY2xpZW50ID0gY2FsY3VsYXRlQm94KGJvcmRlckJveCwgY29tcHV0ZWRTdHlsZXMpO1xuICBjb25zdCBwYWdlID0gd2l0aFNjcm9sbChjbGllbnQsIHdpbmRvd1Njcm9sbCk7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0ge1xuICAgIGNsaWVudCxcbiAgICB0YWdOYW1lOiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgZGlzcGxheTogY29tcHV0ZWRTdHlsZXMuZGlzcGxheVxuICB9O1xuICBjb25zdCBkaXNwbGFjZUJ5ID0ge1xuICAgIHg6IGNsaWVudC5tYXJnaW5Cb3gud2lkdGgsXG4gICAgeTogY2xpZW50Lm1hcmdpbkJveC5oZWlnaHRcbiAgfTtcbiAgY29uc3QgZGltZW5zaW9uID0ge1xuICAgIGRlc2NyaXB0b3IsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgZGlzcGxhY2VCeSxcbiAgICBjbGllbnQsXG4gICAgcGFnZVxuICB9O1xuICByZXR1cm4gZGltZW5zaW9uO1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnZ2FibGVQdWJsaXNoZXIoYXJncykge1xuICBjb25zdCB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkJDEoJ2RyYWdnYWJsZScpO1xuICBjb25zdCB7XG4gICAgZGVzY3JpcHRvcixcbiAgICByZWdpc3RyeSxcbiAgICBnZXREcmFnZ2FibGVSZWYsXG4gICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgaXNFbmFibGVkXG4gIH0gPSBhcmdzO1xuICBjb25zdCBvcHRpb25zID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgIGlzRW5hYmxlZFxuICB9KSwgW2NhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLCBpc0VuYWJsZWQsIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzXSk7XG4gIGNvbnN0IGdldERpbWVuc2lvbiA9IHVzZUNhbGxiYWNrKHdpbmRvd1Njcm9sbCA9PiB7XG4gICAgY29uc3QgZWwgPSBnZXREcmFnZ2FibGVSZWYoKTtcbiAgICAhZWwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZ2V0IGRpbWVuc2lvbiB3aGVuIG5vIHJlZiBpcyBzZXQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGdldERpbWVuc2lvbiQxKGRlc2NyaXB0b3IsIGVsLCB3aW5kb3dTY3JvbGwpO1xuICB9LCBbZGVzY3JpcHRvciwgZ2V0RHJhZ2dhYmxlUmVmXSk7XG4gIGNvbnN0IGVudHJ5ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHVuaXF1ZUlkLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgb3B0aW9ucyxcbiAgICBnZXREaW1lbnNpb25cbiAgfSksIFtkZXNjcmlwdG9yLCBnZXREaW1lbnNpb24sIG9wdGlvbnMsIHVuaXF1ZUlkXSk7XG4gIGNvbnN0IHB1Ymxpc2hlZFJlZiA9IHVzZVJlZihlbnRyeSk7XG4gIGNvbnN0IGlzRmlyc3RQdWJsaXNoUmVmID0gdXNlUmVmKHRydWUpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJlZ2lzdHJ5LmRyYWdnYWJsZS5yZWdpc3RlcihwdWJsaXNoZWRSZWYuY3VycmVudCk7XG4gICAgcmV0dXJuICgpID0+IHJlZ2lzdHJ5LmRyYWdnYWJsZS51bnJlZ2lzdGVyKHB1Ymxpc2hlZFJlZi5jdXJyZW50KTtcbiAgfSwgW3JlZ2lzdHJ5LmRyYWdnYWJsZV0pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc0ZpcnN0UHVibGlzaFJlZi5jdXJyZW50KSB7XG4gICAgICBpc0ZpcnN0UHVibGlzaFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSBwdWJsaXNoZWRSZWYuY3VycmVudDtcbiAgICBwdWJsaXNoZWRSZWYuY3VycmVudCA9IGVudHJ5O1xuICAgIHJlZ2lzdHJ5LmRyYWdnYWJsZS51cGRhdGUoZW50cnksIGxhc3QpO1xuICB9LCBbZW50cnksIHJlZ2lzdHJ5LmRyYWdnYWJsZV0pO1xufVxuXG52YXIgRHJvcHBhYmxlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmZ1bmN0aW9uIGNoZWNrSXNWYWxpZElubmVyUmVmKGVsKSB7XG4gICEoZWwgJiYgaXNIdG1sRWxlbWVudChlbCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgXG4gICAgcHJvdmlkZWQuaW5uZXJSZWYgaGFzIG5vdCBiZWVuIHByb3ZpZGVkIHdpdGggYSBIVE1MRWxlbWVudC5cblxuICAgIFlvdSBjYW4gZmluZCBhIGd1aWRlIG9uIHVzaW5nIHRoZSBpbm5lclJlZiBjYWxsYmFjayBmdW5jdGlvbnMgYXQ6XG4gICAgaHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQvYmxvYi9tYWluL2RvY3MvZ3VpZGVzL3VzaW5nLWlubmVyLXJlZi5tZFxuICBgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIHVzZVZhbGlkYXRpb24kMShwcm9wcywgY29udGV4dElkLCBnZXRSZWYpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICBmdW5jdGlvbiBwcmVmaXgoaWQpIHtcbiAgICAgIHJldHVybiBgRHJhZ2dhYmxlW2lkOiAke2lkfV06IGA7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gcHJvcHMuZHJhZ2dhYmxlSWQ7XG4gICAgIWlkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRHJhZ2dhYmxlIHJlcXVpcmVzIGEgZHJhZ2dhYmxlSWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYERyYWdnYWJsZSByZXF1aXJlcyBhIFtzdHJpbmddIGRyYWdnYWJsZUlkLlxuICAgICAgUHJvdmlkZWQ6IFt0eXBlOiAke3R5cGVvZiBpZH1dICh2YWx1ZTogJHtpZH0pYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICFOdW1iZXIuaXNJbnRlZ2VyKHByb3BzLmluZGV4KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYCR7cHJlZml4KGlkKX0gcmVxdWlyZXMgYW4gaW50ZWdlciBpbmRleCBwcm9wYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGlmIChwcm9wcy5tYXBwZWQudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjaGVja0lzVmFsaWRJbm5lclJlZihnZXRSZWYoKSk7XG4gICAgaWYgKHByb3BzLmlzRW5hYmxlZCkge1xuICAgICAgIWZpbmREcmFnSGFuZGxlKGNvbnRleHRJZCwgaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHtwcmVmaXgoaWQpfSBVbmFibGUgdG8gZmluZCBkcmFnIGhhbmRsZWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdXNlQ2xvbmVQcm9wVmFsaWRhdGlvbihpc0Nsb25lKSB7XG4gIHVzZURldigoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFJlZiA9IHVzZVJlZihpc0Nsb25lKTtcbiAgICB1c2VEZXZTZXR1cFdhcm5pbmcoKCkgPT4ge1xuICAgICAgIShpc0Nsb25lID09PSBpbml0aWFsUmVmLmN1cnJlbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRHJhZ2dhYmxlIGlzQ2xvbmUgcHJvcCB2YWx1ZSBjaGFuZ2VkIGR1cmluZyBjb21wb25lbnQgbGlmZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9LCBbaXNDbG9uZV0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlUmVxdWlyZWRDb250ZXh0KENvbnRleHQpIHtcbiAgY29uc3QgcmVzdWx0ID0gdXNlQ29udGV4dChDb250ZXh0KTtcbiAgIXJlc3VsdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHJlcXVpcmVkIGNvbnRleHQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRIdG1sNURuZChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuY29uc3QgRHJhZ2dhYmxlID0gcHJvcHMgPT4ge1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldFJlZiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCA9PT0gdm9pZCAwKSB7XG4gICAgICBlbCA9IG51bGw7XG4gICAgfVxuICAgIHJlZi5jdXJyZW50ID0gZWw7XG4gIH0sIFtdKTtcbiAgY29uc3QgZ2V0UmVmID0gdXNlQ2FsbGJhY2soKCkgPT4gcmVmLmN1cnJlbnQsIFtdKTtcbiAgY29uc3Qge1xuICAgIGNvbnRleHRJZCxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCxcbiAgICByZWdpc3RyeVxuICB9ID0gdXNlUmVxdWlyZWRDb250ZXh0KEFwcENvbnRleHQpO1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBkcm9wcGFibGVJZFxuICB9ID0gdXNlUmVxdWlyZWRDb250ZXh0KERyb3BwYWJsZUNvbnRleHQpO1xuICBjb25zdCBkZXNjcmlwdG9yID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlkOiBwcm9wcy5kcmFnZ2FibGVJZCxcbiAgICBpbmRleDogcHJvcHMuaW5kZXgsXG4gICAgdHlwZSxcbiAgICBkcm9wcGFibGVJZFxuICB9KSwgW3Byb3BzLmRyYWdnYWJsZUlkLCBwcm9wcy5pbmRleCwgdHlwZSwgZHJvcHBhYmxlSWRdKTtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGRyYWdnYWJsZUlkLFxuICAgIGlzRW5hYmxlZCxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICBpc0Nsb25lLFxuICAgIG1hcHBlZCxcbiAgICBkcm9wQW5pbWF0aW9uRmluaXNoZWQ6IGRyb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvblxuICB9ID0gcHJvcHM7XG4gIHVzZVZhbGlkYXRpb24kMShwcm9wcywgY29udGV4dElkLCBnZXRSZWYpO1xuICB1c2VDbG9uZVByb3BWYWxpZGF0aW9uKGlzQ2xvbmUpO1xuICBpZiAoIWlzQ2xvbmUpIHtcbiAgICBjb25zdCBmb3JQdWJsaXNoZXIgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICBkZXNjcmlwdG9yLFxuICAgICAgcmVnaXN0cnksXG4gICAgICBnZXREcmFnZ2FibGVSZWY6IGdldFJlZixcbiAgICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgICBpc0VuYWJsZWRcbiAgICB9KSwgW2Rlc2NyaXB0b3IsIHJlZ2lzdHJ5LCBnZXRSZWYsIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLCBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcywgaXNFbmFibGVkXSk7XG4gICAgdXNlRHJhZ2dhYmxlUHVibGlzaGVyKGZvclB1Ymxpc2hlcik7XG4gIH1cbiAgY29uc3QgZHJhZ0hhbmRsZVByb3BzID0gdXNlTWVtbygoKSA9PiBpc0VuYWJsZWQgPyB7XG4gICAgdGFiSW5kZXg6IDAsXG4gICAgcm9sZTogJ2J1dHRvbicsXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCxcbiAgICAnZGF0YS1yZmQtZHJhZy1oYW5kbGUtZHJhZ2dhYmxlLWlkJzogZHJhZ2dhYmxlSWQsXG4gICAgJ2RhdGEtcmZkLWRyYWctaGFuZGxlLWNvbnRleHQtaWQnOiBjb250ZXh0SWQsXG4gICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICBvbkRyYWdTdGFydDogcHJldmVudEh0bWw1RG5kXG4gIH0gOiBudWxsLCBbY29udGV4dElkLCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCwgZHJhZ2dhYmxlSWQsIGlzRW5hYmxlZF0pO1xuICBjb25zdCBvbk1vdmVFbmQgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgaWYgKG1hcHBlZC50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbWFwcGVkLmRyb3BwaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUgIT09ICd0cmFuc2Zvcm0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChSZWFjdC52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE2JykgfHwgUmVhY3QudmVyc2lvbi5zdGFydHNXaXRoKCcxNycpKSB7XG4gICAgICBkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hTeW5jKGRyb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvbik7XG4gICAgfVxuICB9LCBbZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uLCBtYXBwZWRdKTtcbiAgY29uc3QgcHJvdmlkZWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IGdldFN0eWxlJDEobWFwcGVkKTtcbiAgICBjb25zdCBvblRyYW5zaXRpb25FbmQgPSBtYXBwZWQudHlwZSA9PT0gJ0RSQUdHSU5HJyAmJiBtYXBwZWQuZHJvcHBpbmcgPyBvbk1vdmVFbmQgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgaW5uZXJSZWY6IHNldFJlZixcbiAgICAgIGRyYWdnYWJsZVByb3BzOiB7XG4gICAgICAgICdkYXRhLXJmZC1kcmFnZ2FibGUtY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICAgICAgJ2RhdGEtcmZkLWRyYWdnYWJsZS1pZCc6IGRyYWdnYWJsZUlkLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgb25UcmFuc2l0aW9uRW5kXG4gICAgICB9LFxuICAgICAgZHJhZ0hhbmRsZVByb3BzXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBbY29udGV4dElkLCBkcmFnSGFuZGxlUHJvcHMsIGRyYWdnYWJsZUlkLCBtYXBwZWQsIG9uTW92ZUVuZCwgc2V0UmVmXSk7XG4gIGNvbnN0IHJ1YnJpYyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBkcmFnZ2FibGVJZDogZGVzY3JpcHRvci5pZCxcbiAgICB0eXBlOiBkZXNjcmlwdG9yLnR5cGUsXG4gICAgc291cmNlOiB7XG4gICAgICBpbmRleDogZGVzY3JpcHRvci5pbmRleCxcbiAgICAgIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG4gICAgfVxuICB9KSwgW2Rlc2NyaXB0b3IuZHJvcHBhYmxlSWQsIGRlc2NyaXB0b3IuaWQsIGRlc2NyaXB0b3IuaW5kZXgsIGRlc2NyaXB0b3IudHlwZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4ocHJvdmlkZWQsIG1hcHBlZC5zbmFwc2hvdCwgcnVicmljKSk7XG59O1xudmFyIERyYWdnYWJsZSQxID0gRHJhZ2dhYmxlO1xuXG52YXIgaXNTdHJpY3RFcXVhbCA9ICgoYSwgYikgPT4gYSA9PT0gYik7XG5cbnZhciB3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQgPSAocmVzdWx0ID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbWJpbmUsXG4gICAgZGVzdGluYXRpb25cbiAgfSA9IHJlc3VsdDtcbiAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uLmRyb3BwYWJsZUlkO1xuICB9XG4gIGlmIChjb21iaW5lKSB7XG4gICAgcmV0dXJuIGNvbWJpbmUuZHJvcHBhYmxlSWQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KTtcblxuY29uc3QgZ2V0Q29tYmluZVdpdGhGcm9tUmVzdWx0ID0gcmVzdWx0ID0+IHtcbiAgcmV0dXJuIHJlc3VsdC5jb21iaW5lID8gcmVzdWx0LmNvbWJpbmUuZHJhZ2dhYmxlSWQgOiBudWxsO1xufTtcbmNvbnN0IGdldENvbWJpbmVXaXRoRnJvbUltcGFjdCA9IGltcGFjdCA9PiB7XG4gIHJldHVybiBpbXBhY3QuYXQgJiYgaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJyA/IGltcGFjdC5hdC5jb21iaW5lLmRyYWdnYWJsZUlkIDogbnVsbDtcbn07XG5mdW5jdGlvbiBnZXREcmFnZ2FibGVTZWxlY3RvcigpIHtcbiAgY29uc3QgbWVtb2l6ZWRPZmZzZXQgPSBtZW1vaXplT25lKCh4LCB5KSA9PiAoe1xuICAgIHgsXG4gICAgeVxuICB9KSk7XG4gIGNvbnN0IGdldE1lbW9pemVkU25hcHNob3QgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChtb2RlLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIsIGNvbWJpbmVXaXRoLCBkcm9wcGluZykge1xuICAgIGlmIChkcmFnZ2luZ092ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZHJhZ2dpbmdPdmVyID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNvbWJpbmVXaXRoID09PSB2b2lkIDApIHtcbiAgICAgIGNvbWJpbmVXaXRoID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRyb3BwaW5nID09PSB2b2lkIDApIHtcbiAgICAgIGRyb3BwaW5nID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWUsXG4gICAgICBpc0Nsb25lLFxuICAgICAgaXNEcm9wQW5pbWF0aW5nOiBCb29sZWFuKGRyb3BwaW5nKSxcbiAgICAgIGRyb3BBbmltYXRpb246IGRyb3BwaW5nLFxuICAgICAgbW9kZSxcbiAgICAgIGRyYWdnaW5nT3ZlcixcbiAgICAgIGNvbWJpbmVXaXRoLFxuICAgICAgY29tYmluZVRhcmdldEZvcjogbnVsbFxuICAgIH07XG4gIH0pO1xuICBjb25zdCBnZXRNZW1vaXplZFByb3BzID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAob2Zmc2V0LCBtb2RlLCBkaW1lbnNpb24sIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIGZvcmNlU2hvdWxkQW5pbWF0ZSkge1xuICAgIGlmIChkcmFnZ2luZ092ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZHJhZ2dpbmdPdmVyID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNvbWJpbmVXaXRoID09PSB2b2lkIDApIHtcbiAgICAgIGNvbWJpbmVXaXRoID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGZvcmNlU2hvdWxkQW5pbWF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWFwcGVkOiB7XG4gICAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICAgIGRyb3BwaW5nOiBudWxsLFxuICAgICAgICBkcmFnZ2luZ092ZXIsXG4gICAgICAgIGNvbWJpbmVXaXRoLFxuICAgICAgICBtb2RlLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGRpbWVuc2lvbixcbiAgICAgICAgZm9yY2VTaG91bGRBbmltYXRlLFxuICAgICAgICBzbmFwc2hvdDogZ2V0TWVtb2l6ZWRTbmFwc2hvdChtb2RlLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIsIGNvbWJpbmVXaXRoLCBudWxsKVxuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBjb25zdCBzZWxlY3RvciA9IChzdGF0ZSwgb3duUHJvcHMpID0+IHtcbiAgICBpZiAoaXNEcmFnZ2luZyhzdGF0ZSkpIHtcbiAgICAgIGlmIChzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWQgIT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0O1xuICAgICAgY29uc3QgZGltZW5zaW9uID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW293blByb3BzLmRyYWdnYWJsZUlkXTtcbiAgICAgIGNvbnN0IGRyYWdnaW5nT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCk7XG4gICAgICBjb25zdCBjb21iaW5lV2l0aCA9IGdldENvbWJpbmVXaXRoRnJvbUltcGFjdChzdGF0ZS5pbXBhY3QpO1xuICAgICAgY29uc3QgZm9yY2VTaG91bGRBbmltYXRlID0gc3RhdGUuZm9yY2VTaG91bGRBbmltYXRlO1xuICAgICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMobWVtb2l6ZWRPZmZzZXQob2Zmc2V0LngsIG9mZnNldC55KSwgc3RhdGUubW92ZW1lbnRNb2RlLCBkaW1lbnNpb24sIG93blByb3BzLmlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIGZvcmNlU2hvdWxkQW5pbWF0ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuICAgICAgaWYgKGNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQgIT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNDbG9uZSA9IG93blByb3BzLmlzQ2xvbmU7XG4gICAgICBjb25zdCBkaW1lbnNpb24gPSBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNbb3duUHJvcHMuZHJhZ2dhYmxlSWRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGxldGVkLnJlc3VsdDtcbiAgICAgIGNvbnN0IG1vZGUgPSByZXN1bHQubW9kZTtcbiAgICAgIGNvbnN0IGRyYWdnaW5nT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdChyZXN1bHQpO1xuICAgICAgY29uc3QgY29tYmluZVdpdGggPSBnZXRDb21iaW5lV2l0aEZyb21SZXN1bHQocmVzdWx0KTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gc3RhdGUuZHJvcER1cmF0aW9uO1xuICAgICAgY29uc3QgZHJvcHBpbmcgPSB7XG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBjdXJ2ZTogY3VydmVzLmRyb3AsXG4gICAgICAgIG1vdmVUbzogc3RhdGUubmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgICAgb3BhY2l0eTogY29tYmluZVdpdGggPyBjb21iaW5lLm9wYWNpdHkuZHJvcCA6IG51bGwsXG4gICAgICAgIHNjYWxlOiBjb21iaW5lV2l0aCA/IGNvbWJpbmUuc2NhbGUuZHJvcCA6IG51bGxcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXBwZWQ6IHtcbiAgICAgICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgICAgIG9mZnNldDogc3RhdGUubmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgICAgICBkaW1lbnNpb24sXG4gICAgICAgICAgZHJvcHBpbmcsXG4gICAgICAgICAgZHJhZ2dpbmdPdmVyLFxuICAgICAgICAgIGNvbWJpbmVXaXRoLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiBudWxsLFxuICAgICAgICAgIHNuYXBzaG90OiBnZXRNZW1vaXplZFNuYXBzaG90KG1vZGUsIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIGRyb3BwaW5nKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U25hcHNob3QoY29tYmluZVRhcmdldEZvcikge1xuICBpZiAoY29tYmluZVRhcmdldEZvciA9PT0gdm9pZCAwKSB7XG4gICAgY29tYmluZVRhcmdldEZvciA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICBpc0Ryb3BBbmltYXRpbmc6IGZhbHNlLFxuICAgIGlzQ2xvbmU6IGZhbHNlLFxuICAgIGRyb3BBbmltYXRpb246IG51bGwsXG4gICAgbW9kZTogbnVsbCxcbiAgICBkcmFnZ2luZ092ZXI6IG51bGwsXG4gICAgY29tYmluZVRhcmdldEZvcixcbiAgICBjb21iaW5lV2l0aDogbnVsbFxuICB9O1xufVxuY29uc3QgYXRSZXN0ID0ge1xuICBtYXBwZWQ6IHtcbiAgICB0eXBlOiAnU0VDT05EQVJZJyxcbiAgICBvZmZzZXQ6IG9yaWdpbixcbiAgICBjb21iaW5lVGFyZ2V0Rm9yOiBudWxsLFxuICAgIHNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQ6IHRydWUsXG4gICAgc25hcHNob3Q6IGdldFNlY29uZGFyeVNuYXBzaG90KG51bGwpXG4gIH1cbn07XG5mdW5jdGlvbiBnZXRTZWNvbmRhcnlTZWxlY3RvcigpIHtcbiAgY29uc3QgbWVtb2l6ZWRPZmZzZXQgPSBtZW1vaXplT25lKCh4LCB5KSA9PiAoe1xuICAgIHgsXG4gICAgeVxuICB9KSk7XG4gIGNvbnN0IGdldE1lbW9pemVkU25hcHNob3QgPSBtZW1vaXplT25lKGdldFNlY29uZGFyeVNuYXBzaG90KTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKG9mZnNldCwgY29tYmluZVRhcmdldEZvciwgc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCkge1xuICAgIGlmIChjb21iaW5lVGFyZ2V0Rm9yID09PSB2b2lkIDApIHtcbiAgICAgIGNvbWJpbmVUYXJnZXRGb3IgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWFwcGVkOiB7XG4gICAgICAgIHR5cGU6ICdTRUNPTkRBUlknLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGNvbWJpbmVUYXJnZXRGb3IsXG4gICAgICAgIHNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQsXG4gICAgICAgIHNuYXBzaG90OiBnZXRNZW1vaXplZFNuYXBzaG90KGNvbWJpbmVUYXJnZXRGb3IpXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IGdldEZhbGxiYWNrID0gY29tYmluZVRhcmdldEZvciA9PiB7XG4gICAgcmV0dXJuIGNvbWJpbmVUYXJnZXRGb3IgPyBnZXRNZW1vaXplZFByb3BzKG9yaWdpbiwgY29tYmluZVRhcmdldEZvciwgdHJ1ZSkgOiBudWxsO1xuICB9O1xuICBjb25zdCBnZXRQcm9wcyA9IChvd25JZCwgZHJhZ2dpbmdJZCwgaW1wYWN0LCBhZnRlckNyaXRpY2FsKSA9PiB7XG4gICAgY29uc3QgdmlzdWFsRGlzcGxhY2VtZW50ID0gaW1wYWN0LmRpc3BsYWNlZC52aXNpYmxlW293bklkXTtcbiAgICBjb25zdCBpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0ID0gQm9vbGVhbihhZnRlckNyaXRpY2FsLmluVmlydHVhbExpc3QgJiYgYWZ0ZXJDcml0aWNhbC5lZmZlY3RlZFtvd25JZF0pO1xuICAgIGNvbnN0IGNvbWJpbmUgPSB0cnlHZXRDb21iaW5lKGltcGFjdCk7XG4gICAgY29uc3QgY29tYmluZVRhcmdldEZvciA9IGNvbWJpbmUgJiYgY29tYmluZS5kcmFnZ2FibGVJZCA9PT0gb3duSWQgPyBkcmFnZ2luZ0lkIDogbnVsbDtcbiAgICBpZiAoIXZpc3VhbERpc3BsYWNlbWVudCkge1xuICAgICAgaWYgKCFpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0KSB7XG4gICAgICAgIHJldHVybiBnZXRGYWxsYmFjayhjb21iaW5lVGFyZ2V0Rm9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbXBhY3QuZGlzcGxhY2VkLmludmlzaWJsZVtvd25JZF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFuZ2UgPSBuZWdhdGUoYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBtZW1vaXplZE9mZnNldChjaGFuZ2UueCwgY2hhbmdlLnkpO1xuICAgICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMob2Zmc2V0LCBjb21iaW5lVGFyZ2V0Rm9yLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGlzQWZ0ZXJDcml0aWNhbEluVmlydHVhbExpc3QpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjayhjb21iaW5lVGFyZ2V0Rm9yKTtcbiAgICB9XG4gICAgY29uc3QgZGlzcGxhY2VCeSA9IGltcGFjdC5kaXNwbGFjZWRCeS5wb2ludDtcbiAgICBjb25zdCBvZmZzZXQgPSBtZW1vaXplZE9mZnNldChkaXNwbGFjZUJ5LngsIGRpc3BsYWNlQnkueSk7XG4gICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMob2Zmc2V0LCBjb21iaW5lVGFyZ2V0Rm9yLCB2aXN1YWxEaXNwbGFjZW1lbnQuc2hvdWxkQW5pbWF0ZSk7XG4gIH07XG4gIGNvbnN0IHNlbGVjdG9yID0gKHN0YXRlLCBvd25Qcm9wcykgPT4ge1xuICAgIGlmIChpc0RyYWdnaW5nKHN0YXRlKSkge1xuICAgICAgaWYgKHN0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCA9PT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0UHJvcHMob3duUHJvcHMuZHJhZ2dhYmxlSWQsIHN0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCwgc3RhdGUuaW1wYWN0LCBzdGF0ZS5hZnRlckNyaXRpY2FsKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG4gICAgICBpZiAoY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCA9PT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0UHJvcHMob3duUHJvcHMuZHJhZ2dhYmxlSWQsIGNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQsIGNvbXBsZXRlZC5pbXBhY3QsIGNvbXBsZXRlZC5hZnRlckNyaXRpY2FsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIHJldHVybiBzZWxlY3Rvcjtcbn1cbmNvbnN0IG1ha2VNYXBTdGF0ZVRvUHJvcHMkMSA9ICgpID0+IHtcbiAgY29uc3QgZHJhZ2dpbmdTZWxlY3RvciA9IGdldERyYWdnYWJsZVNlbGVjdG9yKCk7XG4gIGNvbnN0IHNlY29uZGFyeVNlbGVjdG9yID0gZ2V0U2Vjb25kYXJ5U2VsZWN0b3IoKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIG93blByb3BzKSA9PiBkcmFnZ2luZ1NlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykgfHwgc2Vjb25kYXJ5U2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB8fCBhdFJlc3Q7XG4gIHJldHVybiBzZWxlY3Rvcjtcbn07XG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMkMSA9IHtcbiAgZHJvcEFuaW1hdGlvbkZpbmlzaGVkOiBkcm9wQW5pbWF0aW9uRmluaXNoZWRcbn07XG5jb25zdCBDb25uZWN0ZWREcmFnZ2FibGUgPSBjb25uZWN0KG1ha2VNYXBTdGF0ZVRvUHJvcHMkMSwgbWFwRGlzcGF0Y2hUb1Byb3BzJDEsIG51bGwsIHtcbiAgY29udGV4dDogU3RvcmVDb250ZXh0LFxuICBhcmVTdGF0ZVByb3BzRXF1YWw6IGlzU3RyaWN0RXF1YWxcbn0pKERyYWdnYWJsZSQxKTtcbnZhciBDb25uZWN0ZWREcmFnZ2FibGUkMSA9IENvbm5lY3RlZERyYWdnYWJsZTtcblxuZnVuY3Rpb24gUHJpdmF0ZURyYWdnYWJsZShwcm9wcykge1xuICBjb25zdCBkcm9wcGFibGVDb250ZXh0ID0gdXNlUmVxdWlyZWRDb250ZXh0KERyb3BwYWJsZUNvbnRleHQpO1xuICBjb25zdCBpc1VzaW5nQ2xvbmVGb3IgPSBkcm9wcGFibGVDb250ZXh0LmlzVXNpbmdDbG9uZUZvcjtcbiAgaWYgKGlzVXNpbmdDbG9uZUZvciA9PT0gcHJvcHMuZHJhZ2dhYmxlSWQgJiYgIXByb3BzLmlzQ2xvbmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0ZWREcmFnZ2FibGUkMSwgcHJvcHMpO1xufVxuZnVuY3Rpb24gUHVibGljRHJhZ2dhYmxlKHByb3BzKSB7XG4gIGNvbnN0IGlzRW5hYmxlZCA9IHR5cGVvZiBwcm9wcy5pc0RyYWdEaXNhYmxlZCA9PT0gJ2Jvb2xlYW4nID8gIXByb3BzLmlzRHJhZ0Rpc2FibGVkIDogdHJ1ZTtcbiAgY29uc3QgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMgPSBCb29sZWFuKHByb3BzLmRpc2FibGVJbnRlcmFjdGl2ZUVsZW1lbnRCbG9ja2luZyk7XG4gIGNvbnN0IHNob3VsZFJlc3BlY3RGb3JjZVByZXNzID0gQm9vbGVhbihwcm9wcy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFByaXZhdGVEcmFnZ2FibGUsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGlzQ2xvbmU6IGZhbHNlLFxuICAgIGlzRW5hYmxlZDogaXNFbmFibGVkLFxuICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzOiBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzczogc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3NcbiAgfSkpO1xufVxuXG5jb25zdCBpc0VxdWFsID0gYmFzZSA9PiB2YWx1ZSA9PiBiYXNlID09PSB2YWx1ZTtcbmNvbnN0IGlzU2Nyb2xsID0gaXNFcXVhbCgnc2Nyb2xsJyk7XG5jb25zdCBpc0F1dG8gPSBpc0VxdWFsKCdhdXRvJyk7XG5jb25zdCBpc1Zpc2libGUgPSBpc0VxdWFsKCd2aXNpYmxlJyk7XG5jb25zdCBpc0VpdGhlciA9IChvdmVyZmxvdywgZm4pID0+IGZuKG92ZXJmbG93Lm92ZXJmbG93WCkgfHwgZm4ob3ZlcmZsb3cub3ZlcmZsb3dZKTtcbmNvbnN0IGlzQm90aCA9IChvdmVyZmxvdywgZm4pID0+IGZuKG92ZXJmbG93Lm92ZXJmbG93WCkgJiYgZm4ob3ZlcmZsb3cub3ZlcmZsb3dZKTtcbmNvbnN0IGlzRWxlbWVudFNjcm9sbGFibGUgPSBlbCA9PiB7XG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBjb25zdCBvdmVyZmxvdyA9IHtcbiAgICBvdmVyZmxvd1g6IHN0eWxlLm92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1k6IHN0eWxlLm92ZXJmbG93WVxuICB9O1xuICByZXR1cm4gaXNFaXRoZXIob3ZlcmZsb3csIGlzU2Nyb2xsKSB8fCBpc0VpdGhlcihvdmVyZmxvdywgaXNBdXRvKTtcbn07XG5jb25zdCBpc0JvZHlTY3JvbGxhYmxlID0gKCkgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBib2R5ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgY29uc3QgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgIWh0bWwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgaWYgKCFpc0VsZW1lbnRTY3JvbGxhYmxlKGJvZHkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGh0bWxTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuICBjb25zdCBodG1sT3ZlcmZsb3cgPSB7XG4gICAgb3ZlcmZsb3dYOiBodG1sU3R5bGUub3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WTogaHRtbFN0eWxlLm92ZXJmbG93WVxuICB9O1xuICBpZiAoaXNCb3RoKGh0bWxPdmVyZmxvdywgaXNWaXNpYmxlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICBXZSBoYXZlIGRldGVjdGVkIHRoYXQgeW91ciA8Ym9keT4gZWxlbWVudCBtaWdodCBiZSBhIHNjcm9sbCBjb250YWluZXIuXG4gICAgV2UgaGF2ZSBmb3VuZCBubyByZWxpYWJsZSB3YXkgb2YgZGV0ZWN0aW5nIHdoZXRoZXIgdGhlIDxib2R5PiBlbGVtZW50IGlzIGEgc2Nyb2xsIGNvbnRhaW5lci5cbiAgICBVbmRlciBtb3N0IGNpcmN1bXN0YW5jZXMgYSA8Ym9keT4gc2Nyb2xsIGJhciB3aWxsIGJlIG9uIHRoZSA8aHRtbD4gZWxlbWVudCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KVxuXG4gICAgQmVjYXVzZSB3ZSBjYW5ub3QgZGV0ZXJtaW5lIGlmIHRoZSA8Ym9keT4gaXMgYSBzY3JvbGwgY29udGFpbmVyLCBhbmQgZ2VuZXJhbGx5IGl0IGlzIG5vdCBvbmUsXG4gICAgd2Ugd2lsbCBiZSB0cmVhdGluZyB0aGUgPGJvZHk+IGFzICpub3QqIGEgc2Nyb2xsIGNvbnRhaW5lclxuXG4gICAgTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQvYmxvYi9tYWluL2RvY3MvZ3VpZGVzL2hvdy13ZS1kZXRlY3Qtc2Nyb2xsLWNvbnRhaW5lcnMubWRcbiAgYCkgOiB2b2lkIDA7XG4gIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBnZXRDbG9zZXN0U2Nyb2xsYWJsZSA9IGVsID0+IHtcbiAgaWYgKGVsID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gaXNCb2R5U2Nyb2xsYWJsZSgpID8gZWwgOiBudWxsO1xuICB9XG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpc0VsZW1lbnRTY3JvbGxhYmxlKGVsKSkge1xuICAgIHJldHVybiBnZXRDbG9zZXN0U2Nyb2xsYWJsZShlbC5wYXJlbnRFbGVtZW50KTtcbiAgfVxuICByZXR1cm4gZWw7XG59O1xudmFyIGdldENsb3Nlc3RTY3JvbGxhYmxlJDEgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZTtcblxudmFyIGNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyA9IChzY3JvbGxhYmxlID0+IHtcbiAgaWYgKCFzY3JvbGxhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGFub3RoZXJTY3JvbGxQYXJlbnQgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZSQxKHNjcm9sbGFibGUucGFyZW50RWxlbWVudCk7XG4gIGlmICghYW5vdGhlclNjcm9sbFBhcmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICBEcm9wcGFibGU6IHVuc3VwcG9ydGVkIG5lc3RlZCBzY3JvbGwgY29udGFpbmVyIGRldGVjdGVkLlxuICAgIEEgRHJvcHBhYmxlIGNhbiBvbmx5IGhhdmUgb25lIHNjcm9sbCBwYXJlbnQgKHdoaWNoIGNhbiBiZSBpdHNlbGYpXG4gICAgTmVzdGVkIHNjcm9sbCBjb250YWluZXJzIGFyZSBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cblxuICAgIFdlIGhvcGUgdG8gc3VwcG9ydCBuZXN0ZWQgc2Nyb2xsIGNvbnRhaW5lcnMgc29vbjogaHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5kL2lzc3Vlcy8xMzFcbiAgYCkgOiB2b2lkIDA7XG59KTtcblxudmFyIGdldFNjcm9sbCA9IChlbCA9PiAoe1xuICB4OiBlbC5zY3JvbGxMZWZ0LFxuICB5OiBlbC5zY3JvbGxUb3Bcbn0pKTtcblxuY29uc3QgZ2V0SXNGaXhlZCA9IGVsID0+IHtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGdldElzRml4ZWQoZWwucGFyZW50RWxlbWVudCk7XG59O1xudmFyIGdldEVudiA9IChzdGFydCA9PiB7XG4gIGNvbnN0IGNsb3Nlc3RTY3JvbGxhYmxlID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGUkMShzdGFydCk7XG4gIGNvbnN0IGlzRml4ZWRPblBhZ2UgPSBnZXRJc0ZpeGVkKHN0YXJ0KTtcbiAgcmV0dXJuIHtcbiAgICBjbG9zZXN0U2Nyb2xsYWJsZSxcbiAgICBpc0ZpeGVkT25QYWdlXG4gIH07XG59KTtcblxudmFyIGdldERyb3BwYWJsZURpbWVuc2lvbiA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBkZXNjcmlwdG9yLFxuICAgIGlzRW5hYmxlZCxcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIGlzRml4ZWRPblBhZ2UsXG4gICAgZGlyZWN0aW9uLFxuICAgIGNsaWVudCxcbiAgICBwYWdlLFxuICAgIGNsb3Nlc3RcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGZyYW1lID0gKCgpID0+IHtcbiAgICBpZiAoIWNsb3Nlc3QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxTaXplLFxuICAgICAgY2xpZW50OiBmcmFtZUNsaWVudFxuICAgIH0gPSBjbG9zZXN0O1xuICAgIGNvbnN0IG1heFNjcm9sbCA9IGdldE1heFNjcm9sbCh7XG4gICAgICBzY3JvbGxIZWlnaHQ6IHNjcm9sbFNpemUuc2Nyb2xsSGVpZ2h0LFxuICAgICAgc2Nyb2xsV2lkdGg6IHNjcm9sbFNpemUuc2Nyb2xsV2lkdGgsXG4gICAgICBoZWlnaHQ6IGZyYW1lQ2xpZW50LnBhZGRpbmdCb3guaGVpZ2h0LFxuICAgICAgd2lkdGg6IGZyYW1lQ2xpZW50LnBhZGRpbmdCb3gud2lkdGhcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZU1hcmdpbkJveDogY2xvc2VzdC5wYWdlLm1hcmdpbkJveCxcbiAgICAgIGZyYW1lQ2xpZW50LFxuICAgICAgc2Nyb2xsU2l6ZSxcbiAgICAgIHNob3VsZENsaXBTdWJqZWN0OiBjbG9zZXN0LnNob3VsZENsaXBTdWJqZWN0LFxuICAgICAgc2Nyb2xsOiB7XG4gICAgICAgIGluaXRpYWw6IGNsb3Nlc3Quc2Nyb2xsLFxuICAgICAgICBjdXJyZW50OiBjbG9zZXN0LnNjcm9sbCxcbiAgICAgICAgbWF4OiBtYXhTY3JvbGwsXG4gICAgICAgIGRpZmY6IHtcbiAgICAgICAgICB2YWx1ZTogb3JpZ2luLFxuICAgICAgICAgIGRpc3BsYWNlbWVudDogb3JpZ2luXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuICBjb25zdCBheGlzID0gZGlyZWN0aW9uID09PSAndmVydGljYWwnID8gdmVydGljYWwgOiBob3Jpem9udGFsO1xuICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IG51bGwsXG4gICAgYXhpcyxcbiAgICBmcmFtZVxuICB9KTtcbiAgY29uc3QgZGltZW5zaW9uID0ge1xuICAgIGRlc2NyaXB0b3IsXG4gICAgaXNDb21iaW5lRW5hYmxlZCxcbiAgICBpc0ZpeGVkT25QYWdlLFxuICAgIGF4aXMsXG4gICAgaXNFbmFibGVkLFxuICAgIGNsaWVudCxcbiAgICBwYWdlLFxuICAgIGZyYW1lLFxuICAgIHN1YmplY3RcbiAgfTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn0pO1xuXG5jb25zdCBnZXRDbGllbnQgPSAodGFyZ2V0UmVmLCBjbG9zZXN0U2Nyb2xsYWJsZSkgPT4ge1xuICBjb25zdCBiYXNlID0gZ2V0Qm94KHRhcmdldFJlZik7XG4gIGlmICghY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBpZiAodGFyZ2V0UmVmICE9PSBjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IHRvcCA9IGJhc2UucGFkZGluZ0JveC50b3AgLSBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxUb3A7XG4gIGNvbnN0IGxlZnQgPSBiYXNlLnBhZGRpbmdCb3gubGVmdCAtIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbExlZnQ7XG4gIGNvbnN0IGJvdHRvbSA9IHRvcCArIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbEhlaWdodDtcbiAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsV2lkdGg7XG4gIGNvbnN0IHBhZGRpbmdCb3ggPSB7XG4gICAgdG9wLFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbSxcbiAgICBsZWZ0XG4gIH07XG4gIGNvbnN0IGJvcmRlckJveCA9IGV4cGFuZChwYWRkaW5nQm94LCBiYXNlLmJvcmRlcik7XG4gIGNvbnN0IGNsaWVudCA9IGNyZWF0ZUJveCh7XG4gICAgYm9yZGVyQm94LFxuICAgIG1hcmdpbjogYmFzZS5tYXJnaW4sXG4gICAgYm9yZGVyOiBiYXNlLmJvcmRlcixcbiAgICBwYWRkaW5nOiBiYXNlLnBhZGRpbmdcbiAgfSk7XG4gIHJldHVybiBjbGllbnQ7XG59O1xudmFyIGdldERpbWVuc2lvbiA9IChfcmVmID0+IHtcbiAgbGV0IHtcbiAgICByZWYsXG4gICAgZGVzY3JpcHRvcixcbiAgICBlbnYsXG4gICAgd2luZG93U2Nyb2xsLFxuICAgIGRpcmVjdGlvbixcbiAgICBpc0Ryb3BEaXNhYmxlZCxcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIHNob3VsZENsaXBTdWJqZWN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBjbG9zZXN0U2Nyb2xsYWJsZSA9IGVudi5jbG9zZXN0U2Nyb2xsYWJsZTtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KHJlZiwgY2xvc2VzdFNjcm9sbGFibGUpO1xuICBjb25zdCBwYWdlID0gd2l0aFNjcm9sbChjbGllbnQsIHdpbmRvd1Njcm9sbCk7XG4gIGNvbnN0IGNsb3Nlc3QgPSAoKCkgPT4ge1xuICAgIGlmICghY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBmcmFtZUNsaWVudCA9IGdldEJveChjbG9zZXN0U2Nyb2xsYWJsZSk7XG4gICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IHtcbiAgICAgIHNjcm9sbEhlaWdodDogY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0LFxuICAgICAgc2Nyb2xsV2lkdGg6IGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbFdpZHRoXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50OiBmcmFtZUNsaWVudCxcbiAgICAgIHBhZ2U6IHdpdGhTY3JvbGwoZnJhbWVDbGllbnQsIHdpbmRvd1Njcm9sbCksXG4gICAgICBzY3JvbGw6IGdldFNjcm9sbChjbG9zZXN0U2Nyb2xsYWJsZSksXG4gICAgICBzY3JvbGxTaXplLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3RcbiAgICB9O1xuICB9KSgpO1xuICBjb25zdCBkaW1lbnNpb24gPSBnZXREcm9wcGFibGVEaW1lbnNpb24oe1xuICAgIGRlc2NyaXB0b3IsXG4gICAgaXNFbmFibGVkOiAhaXNEcm9wRGlzYWJsZWQsXG4gICAgaXNDb21iaW5lRW5hYmxlZCxcbiAgICBpc0ZpeGVkT25QYWdlOiBlbnYuaXNGaXhlZE9uUGFnZSxcbiAgICBkaXJlY3Rpb24sXG4gICAgY2xpZW50LFxuICAgIHBhZ2UsXG4gICAgY2xvc2VzdFxuICB9KTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn0pO1xuXG5jb25zdCBpbW1lZGlhdGUgPSB7XG4gIHBhc3NpdmU6IGZhbHNlXG59O1xuY29uc3QgZGVsYXllZCA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcbnZhciBnZXRMaXN0ZW5lck9wdGlvbnMgPSAob3B0aW9ucyA9PiBvcHRpb25zLnNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseSA/IGltbWVkaWF0ZSA6IGRlbGF5ZWQpO1xuXG5jb25zdCBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnID0gZHJhZ2dpbmcgPT4gZHJhZ2dpbmcgJiYgZHJhZ2dpbmcuZW52LmNsb3Nlc3RTY3JvbGxhYmxlIHx8IG51bGw7XG5mdW5jdGlvbiB1c2VEcm9wcGFibGVQdWJsaXNoZXIoYXJncykge1xuICBjb25zdCB3aGlsZURyYWdnaW5nUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBhcHBDb250ZXh0ID0gdXNlUmVxdWlyZWRDb250ZXh0KEFwcENvbnRleHQpO1xuICBjb25zdCB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkJDEoJ2Ryb3BwYWJsZScpO1xuICBjb25zdCB7XG4gICAgcmVnaXN0cnksXG4gICAgbWFyc2hhbFxuICB9ID0gYXBwQ29udGV4dDtcbiAgY29uc3QgcHJldmlvdXNSZWYgPSB1c2VQcmV2aW91cyhhcmdzKTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpZDogYXJncy5kcm9wcGFibGVJZCxcbiAgICB0eXBlOiBhcmdzLnR5cGUsXG4gICAgbW9kZTogYXJncy5tb2RlXG4gIH0pLCBbYXJncy5kcm9wcGFibGVJZCwgYXJncy5tb2RlLCBhcmdzLnR5cGVdKTtcbiAgY29uc3QgcHVibGlzaGVkRGVzY3JpcHRvclJlZiA9IHVzZVJlZihkZXNjcmlwdG9yKTtcbiAgY29uc3QgbWVtb2l6ZWRVcGRhdGVTY3JvbGwgPSB1c2VNZW1vKCgpID0+IG1lbW9pemVPbmUoKHgsIHkpID0+IHtcbiAgICAhd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgdXBkYXRlIHNjcm9sbCB3aGVuIGRyYWdnaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IHNjcm9sbCA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBtYXJzaGFsLnVwZGF0ZURyb3BwYWJsZVNjcm9sbChkZXNjcmlwdG9yLmlkLCBzY3JvbGwpO1xuICB9KSwgW2Rlc2NyaXB0b3IuaWQsIG1hcnNoYWxdKTtcbiAgY29uc3QgZ2V0Q2xvc2VzdFNjcm9sbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICBpZiAoIWRyYWdnaW5nIHx8ICFkcmFnZ2luZy5lbnYuY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIHJldHVybiBnZXRTY3JvbGwoZHJhZ2dpbmcuZW52LmNsb3Nlc3RTY3JvbGxhYmxlKTtcbiAgfSwgW10pO1xuICBjb25zdCB1cGRhdGVTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsID0gZ2V0Q2xvc2VzdFNjcm9sbCgpO1xuICAgIG1lbW9pemVkVXBkYXRlU2Nyb2xsKHNjcm9sbC54LCBzY3JvbGwueSk7XG4gIH0sIFtnZXRDbG9zZXN0U2Nyb2xsLCBtZW1vaXplZFVwZGF0ZVNjcm9sbF0pO1xuICBjb25zdCBzY2hlZHVsZVNjcm9sbFVwZGF0ZSA9IHVzZU1lbW8oKCkgPT4gcmFmU2NoZCh1cGRhdGVTY3JvbGwpLCBbdXBkYXRlU2Nyb2xsXSk7XG4gIGNvbnN0IG9uQ2xvc2VzdFNjcm9sbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICBjb25zdCBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgIShkcmFnZ2luZyAmJiBjbG9zZXN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHNjcm9sbCBvcHRpb25zIHdoaWxlIHNjcm9sbGluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBvcHRpb25zID0gZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5zaG91bGRQdWJsaXNoSW1tZWRpYXRlbHkpIHtcbiAgICAgIHVwZGF0ZVNjcm9sbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlZHVsZVNjcm9sbFVwZGF0ZSgpO1xuICB9LCBbc2NoZWR1bGVTY3JvbGxVcGRhdGUsIHVwZGF0ZVNjcm9sbF0pO1xuICBjb25zdCBnZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCA9IHVzZUNhbGxiYWNrKCh3aW5kb3dTY3JvbGwsIG9wdGlvbnMpID0+IHtcbiAgICAhIXdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjb2xsZWN0IGEgZHJvcHBhYmxlIHdoaWxlIGEgZHJhZyBpcyBvY2N1cnJpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgcHJldmlvdXMgPSBwcmV2aW91c1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHJlZiA9IHByZXZpb3VzLmdldERyb3BwYWJsZVJlZigpO1xuICAgICFyZWYgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29sbGVjdCB3aXRob3V0IGEgZHJvcHBhYmxlIHJlZicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBlbnYgPSBnZXRFbnYocmVmKTtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHtcbiAgICAgIHJlZixcbiAgICAgIGRlc2NyaXB0b3IsXG4gICAgICBlbnYsXG4gICAgICBzY3JvbGxPcHRpb25zOiBvcHRpb25zXG4gICAgfTtcbiAgICB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPSBkcmFnZ2luZztcbiAgICBjb25zdCBkaW1lbnNpb24gPSBnZXREaW1lbnNpb24oe1xuICAgICAgcmVmLFxuICAgICAgZGVzY3JpcHRvcixcbiAgICAgIGVudixcbiAgICAgIHdpbmRvd1Njcm9sbCxcbiAgICAgIGRpcmVjdGlvbjogcHJldmlvdXMuZGlyZWN0aW9uLFxuICAgICAgaXNEcm9wRGlzYWJsZWQ6IHByZXZpb3VzLmlzRHJvcERpc2FibGVkLFxuICAgICAgaXNDb21iaW5lRW5hYmxlZDogcHJldmlvdXMuaXNDb21iaW5lRW5hYmxlZCxcbiAgICAgIHNob3VsZENsaXBTdWJqZWN0OiAhcHJldmlvdXMuaWdub3JlQ29udGFpbmVyQ2xpcHBpbmdcbiAgICB9KTtcbiAgICBjb25zdCBzY3JvbGxhYmxlID0gZW52LmNsb3Nlc3RTY3JvbGxhYmxlO1xuICAgIGlmIChzY3JvbGxhYmxlKSB7XG4gICAgICBzY3JvbGxhYmxlLnNldEF0dHJpYnV0ZShzY3JvbGxDb250YWluZXIuY29udGV4dElkLCBhcHBDb250ZXh0LmNvbnRleHRJZCk7XG4gICAgICBzY3JvbGxhYmxlLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uQ2xvc2VzdFNjcm9sbCwgZ2V0TGlzdGVuZXJPcHRpb25zKGRyYWdnaW5nLnNjcm9sbE9wdGlvbnMpKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyhzY3JvbGxhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbiAgfSwgW2FwcENvbnRleHQuY29udGV4dElkLCBkZXNjcmlwdG9yLCBvbkNsb3Nlc3RTY3JvbGwsIHByZXZpb3VzUmVmXSk7XG4gIGNvbnN0IGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgICEoZHJhZ2dpbmcgJiYgY2xvc2VzdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSByZWNvbGxlY3QgRHJvcHBhYmxlIGNsaWVudCBmb3IgRHJvcHBhYmxlcyB0aGF0IGhhdmUgYSBzY3JvbGwgY29udGFpbmVyJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBnZXRTY3JvbGwoY2xvc2VzdCk7XG4gIH0sIFtdKTtcbiAgY29uc3QgZHJhZ1N0b3BwZWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0b3AgZHJhZyB3aGVuIG5vIGFjdGl2ZSBkcmFnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIGlmICghY2xvc2VzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlZHVsZVNjcm9sbFVwZGF0ZS5jYW5jZWwoKTtcbiAgICBjbG9zZXN0LnJlbW92ZUF0dHJpYnV0ZShzY3JvbGxDb250YWluZXIuY29udGV4dElkKTtcbiAgICBjbG9zZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uQ2xvc2VzdFNjcm9sbCwgZ2V0TGlzdGVuZXJPcHRpb25zKGRyYWdnaW5nLnNjcm9sbE9wdGlvbnMpKTtcbiAgfSwgW29uQ2xvc2VzdFNjcm9sbCwgc2NoZWR1bGVTY3JvbGxVcGRhdGVdKTtcbiAgY29uc3Qgc2Nyb2xsID0gdXNlQ2FsbGJhY2soY2hhbmdlID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2Nyb2xsIHdoZW4gdGhlcmUgaXMgbm8gZHJhZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgIWNsb3Nlc3QgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2Nyb2xsIGEgZHJvcHBhYmxlIHdpdGggbm8gY2xvc2VzdCBzY3JvbGxhYmxlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNsb3Nlc3Quc2Nyb2xsVG9wICs9IGNoYW5nZS55O1xuICAgIGNsb3Nlc3Quc2Nyb2xsTGVmdCArPSBjaGFuZ2UueDtcbiAgfSwgW10pO1xuICBjb25zdCBjYWxsYmFja3MgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwsXG4gICAgICBnZXRTY3JvbGxXaGlsZURyYWdnaW5nLFxuICAgICAgZHJhZ1N0b3BwZWQsXG4gICAgICBzY3JvbGxcbiAgICB9O1xuICB9LCBbZHJhZ1N0b3BwZWQsIGdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsLCBnZXRTY3JvbGxXaGlsZURyYWdnaW5nLCBzY3JvbGxdKTtcbiAgY29uc3QgZW50cnkgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgdW5pcXVlSWQsXG4gICAgZGVzY3JpcHRvcixcbiAgICBjYWxsYmFja3NcbiAgfSksIFtjYWxsYmFja3MsIGRlc2NyaXB0b3IsIHVuaXF1ZUlkXSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcHVibGlzaGVkRGVzY3JpcHRvclJlZi5jdXJyZW50ID0gZW50cnkuZGVzY3JpcHRvcjtcbiAgICByZWdpc3RyeS5kcm9wcGFibGUucmVnaXN0ZXIoZW50cnkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAod2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ1Vuc3VwcG9ydGVkOiBjaGFuZ2luZyB0aGUgZHJvcHBhYmxlSWQgb3IgdHlwZSBvZiBhIERyb3BwYWJsZSBkdXJpbmcgYSBkcmFnJykgOiB2b2lkIDA7XG4gICAgICAgIGRyYWdTdG9wcGVkKCk7XG4gICAgICB9XG4gICAgICByZWdpc3RyeS5kcm9wcGFibGUudW5yZWdpc3RlcihlbnRyeSk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrcywgZGVzY3JpcHRvciwgZHJhZ1N0b3BwZWQsIGVudHJ5LCBtYXJzaGFsLCByZWdpc3RyeS5kcm9wcGFibGVdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXJzaGFsLnVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZChwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQuaWQsICFhcmdzLmlzRHJvcERpc2FibGVkKTtcbiAgfSwgW2FyZ3MuaXNEcm9wRGlzYWJsZWQsIG1hcnNoYWxdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXJzaGFsLnVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQocHVibGlzaGVkRGVzY3JpcHRvclJlZi5jdXJyZW50LmlkLCBhcmdzLmlzQ29tYmluZUVuYWJsZWQpO1xuICB9LCBbYXJncy5pc0NvbWJpbmVFbmFibGVkLCBtYXJzaGFsXSk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuY29uc3QgZW1wdHkgPSB7XG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIG1hcmdpbjogbm9TcGFjaW5nXG59O1xuY29uc3QgZ2V0U2l6ZSA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgYW5pbWF0ZVxuICB9ID0gX3JlZjtcbiAgaWYgKGlzQW5pbWF0aW5nT3Blbk9uTW91bnQpIHtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgaWYgKGFuaW1hdGUgPT09ICdjbG9zZScpIHtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IHBsYWNlaG9sZGVyLmNsaWVudC5ib3JkZXJCb3guaGVpZ2h0LFxuICAgIHdpZHRoOiBwbGFjZWhvbGRlci5jbGllbnQuYm9yZGVyQm94LndpZHRoLFxuICAgIG1hcmdpbjogcGxhY2Vob2xkZXIuY2xpZW50Lm1hcmdpblxuICB9O1xufTtcbmNvbnN0IGdldFN0eWxlID0gX3JlZjIgPT4ge1xuICBsZXQge1xuICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgYW5pbWF0ZVxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IHNpemUgPSBnZXRTaXplKHtcbiAgICBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIGFuaW1hdGVcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxheTogcGxhY2Vob2xkZXIuZGlzcGxheSxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgIG1hcmdpblRvcDogc2l6ZS5tYXJnaW4udG9wLFxuICAgIG1hcmdpblJpZ2h0OiBzaXplLm1hcmdpbi5yaWdodCxcbiAgICBtYXJnaW5Cb3R0b206IHNpemUubWFyZ2luLmJvdHRvbSxcbiAgICBtYXJnaW5MZWZ0OiBzaXplLm1hcmdpbi5sZWZ0LFxuICAgIGZsZXhTaHJpbms6ICcwJyxcbiAgICBmbGV4R3JvdzogJzAnLFxuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICB0cmFuc2l0aW9uOiBhbmltYXRlICE9PSAnbm9uZScgPyB0cmFuc2l0aW9ucy5wbGFjZWhvbGRlciA6IG51bGxcbiAgfTtcbn07XG5jb25zdCBQbGFjZWhvbGRlciA9IHByb3BzID0+IHtcbiAgY29uc3QgYW5pbWF0ZU9wZW5UaW1lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgdHJ5Q2xlYXJBbmltYXRlT3BlblRpbWVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyVGltZW91dChhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQpO1xuICAgIGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCA9IG51bGw7XG4gIH0sIFtdKTtcbiAgY29uc3Qge1xuICAgIGFuaW1hdGUsXG4gICAgb25UcmFuc2l0aW9uRW5kLFxuICAgIG9uQ2xvc2UsXG4gICAgY29udGV4dElkXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgW2lzQW5pbWF0aW5nT3Blbk9uTW91bnQsIHNldElzQW5pbWF0aW5nT3Blbk9uTW91bnRdID0gdXNlU3RhdGUocHJvcHMuYW5pbWF0ZSA9PT0gJ29wZW4nKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQW5pbWF0aW5nT3Blbk9uTW91bnQpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXIoKTtcbiAgICAgIHNldElzQW5pbWF0aW5nT3Blbk9uTW91bnQoZmFsc2UpO1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGlmIChhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBzZXRJc0FuaW1hdGluZ09wZW5Pbk1vdW50KGZhbHNlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ5Q2xlYXJBbmltYXRlT3BlblRpbWVyO1xuICB9LCBbYW5pbWF0ZSwgaXNBbmltYXRpbmdPcGVuT25Nb3VudCwgdHJ5Q2xlYXJBbmltYXRlT3BlblRpbWVyXSk7XG4gIGNvbnN0IG9uU2l6ZUNoYW5nZUVuZCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBpZiAoZXZlbnQucHJvcGVydHlOYW1lICE9PSAnaGVpZ2h0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvblRyYW5zaXRpb25FbmQoKTtcbiAgICBpZiAoYW5pbWF0ZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgb25DbG9zZSgpO1xuICAgIH1cbiAgfSwgW2FuaW1hdGUsIG9uQ2xvc2UsIG9uVHJhbnNpdGlvbkVuZF0pO1xuICBjb25zdCBzdHlsZSA9IGdldFN0eWxlKHtcbiAgICBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICAgIGFuaW1hdGU6IHByb3BzLmFuaW1hdGUsXG4gICAgcGxhY2Vob2xkZXI6IHByb3BzLnBsYWNlaG9sZGVyXG4gIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChwcm9wcy5wbGFjZWhvbGRlci50YWdOYW1lLCB7XG4gICAgc3R5bGUsXG4gICAgJ2RhdGEtcmZkLXBsYWNlaG9sZGVyLWNvbnRleHQtaWQnOiBjb250ZXh0SWQsXG4gICAgb25UcmFuc2l0aW9uRW5kOiBvblNpemVDaGFuZ2VFbmQsXG4gICAgcmVmOiBwcm9wcy5pbm5lclJlZlxuICB9KTtcbn07XG52YXIgUGxhY2Vob2xkZXIkMSA9IFJlYWN0Lm1lbW8oUGxhY2Vob2xkZXIpO1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xufVxuZnVuY3Rpb24gcnVuQ2hlY2tzKGFyZ3MsIGNoZWNrcykge1xuICBjaGVja3MuZm9yRWFjaChjaGVjayA9PiBjaGVjayhhcmdzKSk7XG59XG5jb25zdCBzaGFyZWQgPSBbZnVuY3Rpb24gcmVxdWlyZWQoX3JlZikge1xuICBsZXQge1xuICAgIHByb3BzXG4gIH0gPSBfcmVmO1xuICAhcHJvcHMuZHJvcHBhYmxlSWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdBIERyb3BwYWJsZSByZXF1aXJlcyBhIGRyb3BwYWJsZUlkIHByb3AnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICEodHlwZW9mIHByb3BzLmRyb3BwYWJsZUlkID09PSAnc3RyaW5nJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBBIERyb3BwYWJsZSByZXF1aXJlcyBhIFtzdHJpbmddIGRyb3BwYWJsZUlkLiBQcm92aWRlZDogWyR7dHlwZW9mIHByb3BzLmRyb3BwYWJsZUlkfV1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG59LCBmdW5jdGlvbiBib29sZWFuKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgcHJvcHNcbiAgfSA9IF9yZWYyO1xuICAhaXNCb29sZWFuKHByb3BzLmlzRHJvcERpc2FibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2lzRHJvcERpc2FibGVkIG11c3QgYmUgYSBib29sZWFuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhaXNCb29sZWFuKHByb3BzLmlzQ29tYmluZUVuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaXNDb21iaW5lRW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIWlzQm9vbGVhbihwcm9wcy5pZ25vcmVDb250YWluZXJDbGlwcGluZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdpZ25vcmVDb250YWluZXJDbGlwcGluZyBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIHJlZihfcmVmMykge1xuICBsZXQge1xuICAgIGdldERyb3BwYWJsZVJlZlxuICB9ID0gX3JlZjM7XG4gIGNoZWNrSXNWYWxpZElubmVyUmVmKGdldERyb3BwYWJsZVJlZigpKTtcbn1dO1xuY29uc3Qgc3RhbmRhcmQgPSBbZnVuY3Rpb24gcGxhY2Vob2xkZXIoX3JlZjQpIHtcbiAgbGV0IHtcbiAgICBwcm9wcyxcbiAgICBnZXRQbGFjZWhvbGRlclJlZlxuICB9ID0gX3JlZjQ7XG4gIGlmICghcHJvcHMucGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVmID0gZ2V0UGxhY2Vob2xkZXJSZWYoKTtcbiAgaWYgKHJlZikge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIERyb3BwYWJsZSBzZXR1cCBpc3N1ZSBbZHJvcHBhYmxlSWQ6IFwiJHtwcm9wcy5kcm9wcGFibGVJZH1cIl06XG4gICAgICBEcm9wcGFibGVQcm92aWRlZCA+IHBsYWNlaG9sZGVyIGNvdWxkIG5vdCBiZSBmb3VuZC5cblxuICAgICAgUGxlYXNlIGJlIHN1cmUgdG8gYWRkIHRoZSB7cHJvdmlkZWQucGxhY2Vob2xkZXJ9IFJlYWN0IE5vZGUgYXMgYSBjaGlsZCBvZiB5b3VyIERyb3BwYWJsZS5cbiAgICAgIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL2FwaS9kcm9wcGFibGUubWRcbiAgICBgKSA6IHZvaWQgMDtcbn1dO1xuY29uc3QgdmlydHVhbCA9IFtmdW5jdGlvbiBoYXNDbG9uZShfcmVmNSkge1xuICBsZXQge1xuICAgIHByb3BzXG4gIH0gPSBfcmVmNTtcbiAgIXByb3BzLnJlbmRlckNsb25lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBwcm92aWRlIGEgY2xvbmUgcmVuZGVyIGZ1bmN0aW9uIChyZW5kZXJDbG9uZSkgZm9yIHZpcnR1YWwgbGlzdHMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG59LCBmdW5jdGlvbiBoYXNOb1BsYWNlaG9sZGVyKF9yZWY2KSB7XG4gIGxldCB7XG4gICAgZ2V0UGxhY2Vob2xkZXJSZWZcbiAgfSA9IF9yZWY2O1xuICAhIWdldFBsYWNlaG9sZGVyUmVmKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB2aXJ0dWFsIGxpc3QgdG8gbm90IGhhdmUgYSBwbGFjZWhvbGRlcicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn1dO1xuZnVuY3Rpb24gdXNlVmFsaWRhdGlvbihhcmdzKSB7XG4gIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgcnVuQ2hlY2tzKGFyZ3MsIHNoYXJlZCk7XG4gICAgaWYgKGFyZ3MucHJvcHMubW9kZSA9PT0gJ3N0YW5kYXJkJykge1xuICAgICAgcnVuQ2hlY2tzKGFyZ3MsIHN0YW5kYXJkKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MucHJvcHMubW9kZSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgICBydW5DaGVja3MoYXJncywgdmlydHVhbCk7XG4gICAgfVxuICB9KTtcbn1cblxuY2xhc3MgQW5pbWF0ZUluT3V0IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzVmlzaWJsZTogQm9vbGVhbih0aGlzLnByb3BzLm9uKSxcbiAgICAgIGRhdGE6IHRoaXMucHJvcHMub24sXG4gICAgICBhbmltYXRlOiB0aGlzLnByb3BzLnNob3VsZEFuaW1hdGUgJiYgdGhpcy5wcm9wcy5vbiA/ICdvcGVuJyA6ICdub25lJ1xuICAgIH07XG4gICAgdGhpcy5vbkNsb3NlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuYW5pbWF0ZSAhPT0gJ2Nsb3NlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNWaXNpYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIGlmICghcHJvcHMuc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWaXNpYmxlOiBCb29sZWFuKHByb3BzLm9uKSxcbiAgICAgICAgZGF0YTogcHJvcHMub24sXG4gICAgICAgIGFuaW1hdGU6ICdub25lJ1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHByb3BzLm9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGRhdGE6IHByb3BzLm9uLFxuICAgICAgICBhbmltYXRlOiAnb3BlbidcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChzdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgZGF0YTogc3RhdGUuZGF0YSxcbiAgICAgICAgYW5pbWF0ZTogJ2Nsb3NlJ1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICBhbmltYXRlOiAnY2xvc2UnLFxuICAgICAgZGF0YTogbnVsbFxuICAgIH07XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlZCA9IHtcbiAgICAgIG9uQ2xvc2U6IHRoaXMub25DbG9zZSxcbiAgICAgIGRhdGE6IHRoaXMuc3RhdGUuZGF0YSxcbiAgICAgIGFuaW1hdGU6IHRoaXMuc3RhdGUuYW5pbWF0ZVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4ocHJvdmlkZWQpO1xuICB9XG59XG5cbmNvbnN0IERyb3BwYWJsZSA9IHByb3BzID0+IHtcbiAgY29uc3QgYXBwQ29udGV4dCA9IHVzZUNvbnRleHQoQXBwQ29udGV4dCk7XG4gICFhcHBDb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgYXBwIGNvbnRleHQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0SWQsXG4gICAgaXNNb3ZlbWVudEFsbG93ZWRcbiAgfSA9IGFwcENvbnRleHQ7XG4gIGNvbnN0IGRyb3BwYWJsZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcGxhY2Vob2xkZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBkcm9wcGFibGVJZCxcbiAgICB0eXBlLFxuICAgIG1vZGUsXG4gICAgZGlyZWN0aW9uLFxuICAgIGlnbm9yZUNvbnRhaW5lckNsaXBwaW5nLFxuICAgIGlzRHJvcERpc2FibGVkLFxuICAgIGlzQ29tYmluZUVuYWJsZWQsXG4gICAgc25hcHNob3QsXG4gICAgdXNlQ2xvbmUsXG4gICAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGwsXG4gICAgZ2V0Q29udGFpbmVyRm9yQ2xvbmVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBnZXREcm9wcGFibGVSZWYgPSB1c2VDYWxsYmFjaygoKSA9PiBkcm9wcGFibGVSZWYuY3VycmVudCwgW10pO1xuICBjb25zdCBzZXREcm9wcGFibGVSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICBkcm9wcGFibGVSZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbXSk7XG4gIGNvbnN0IGdldFBsYWNlaG9sZGVyUmVmID0gdXNlQ2FsbGJhY2soKCkgPT4gcGxhY2Vob2xkZXJSZWYuY3VycmVudCwgW10pO1xuICBjb25zdCBzZXRQbGFjZWhvbGRlclJlZiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW10pO1xuICB1c2VWYWxpZGF0aW9uKHtcbiAgICBwcm9wcyxcbiAgICBnZXREcm9wcGFibGVSZWYsXG4gICAgZ2V0UGxhY2Vob2xkZXJSZWZcbiAgfSk7XG4gIGNvbnN0IG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChpc01vdmVtZW50QWxsb3dlZCgpKSB7XG4gICAgICB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbCh7XG4gICAgICAgIG1heFNjcm9sbDogZ2V0TWF4V2luZG93U2Nyb2xsKClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2lzTW92ZW1lbnRBbGxvd2VkLCB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbF0pO1xuICB1c2VEcm9wcGFibGVQdWJsaXNoZXIoe1xuICAgIGRyb3BwYWJsZUlkLFxuICAgIHR5cGUsXG4gICAgbW9kZSxcbiAgICBkaXJlY3Rpb24sXG4gICAgaXNEcm9wRGlzYWJsZWQsXG4gICAgaXNDb21iaW5lRW5hYmxlZCxcbiAgICBpZ25vcmVDb250YWluZXJDbGlwcGluZyxcbiAgICBnZXREcm9wcGFibGVSZWZcbiAgfSk7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gdXNlTWVtbygoKSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KEFuaW1hdGVJbk91dCwge1xuICAgIG9uOiBwcm9wcy5wbGFjZWhvbGRlcixcbiAgICBzaG91bGRBbmltYXRlOiBwcm9wcy5zaG91bGRBbmltYXRlUGxhY2Vob2xkZXJcbiAgfSwgX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIG9uQ2xvc2UsXG4gICAgICBkYXRhLFxuICAgICAgYW5pbWF0ZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFBsYWNlaG9sZGVyJDEsIHtcbiAgICAgIHBsYWNlaG9sZGVyOiBkYXRhLFxuICAgICAgb25DbG9zZTogb25DbG9zZSxcbiAgICAgIGlubmVyUmVmOiBzZXRQbGFjZWhvbGRlclJlZixcbiAgICAgIGFuaW1hdGU6IGFuaW1hdGUsXG4gICAgICBjb250ZXh0SWQ6IGNvbnRleHRJZCxcbiAgICAgIG9uVHJhbnNpdGlvbkVuZDogb25QbGFjZWhvbGRlclRyYW5zaXRpb25FbmRcbiAgICB9KTtcbiAgfSksIFtjb250ZXh0SWQsIG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kLCBwcm9wcy5wbGFjZWhvbGRlciwgcHJvcHMuc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyLCBzZXRQbGFjZWhvbGRlclJlZl0pO1xuICBjb25zdCBwcm92aWRlZCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpbm5lclJlZjogc2V0RHJvcHBhYmxlUmVmLFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIGRyb3BwYWJsZVByb3BzOiB7XG4gICAgICAnZGF0YS1yZmQtZHJvcHBhYmxlLWlkJzogZHJvcHBhYmxlSWQsXG4gICAgICAnZGF0YS1yZmQtZHJvcHBhYmxlLWNvbnRleHQtaWQnOiBjb250ZXh0SWRcbiAgICB9XG4gIH0pLCBbY29udGV4dElkLCBkcm9wcGFibGVJZCwgcGxhY2Vob2xkZXIsIHNldERyb3BwYWJsZVJlZl0pO1xuICBjb25zdCBpc1VzaW5nQ2xvbmVGb3IgPSB1c2VDbG9uZSA/IHVzZUNsb25lLmRyYWdnaW5nLmRyYWdnYWJsZUlkIDogbnVsbDtcbiAgY29uc3QgZHJvcHBhYmxlQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBkcm9wcGFibGVJZCxcbiAgICB0eXBlLFxuICAgIGlzVXNpbmdDbG9uZUZvclxuICB9KSwgW2Ryb3BwYWJsZUlkLCBpc1VzaW5nQ2xvbmVGb3IsIHR5cGVdKTtcbiAgZnVuY3Rpb24gZ2V0Q2xvbmUoKSB7XG4gICAgaWYgKCF1c2VDbG9uZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRyYWdnaW5nLFxuICAgICAgcmVuZGVyXG4gICAgfSA9IHVzZUNsb25lO1xuICAgIGNvbnN0IG5vZGUgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFByaXZhdGVEcmFnZ2FibGUsIHtcbiAgICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2luZy5kcmFnZ2FibGVJZCxcbiAgICAgIGluZGV4OiBkcmFnZ2luZy5zb3VyY2UuaW5kZXgsXG4gICAgICBpc0Nsb25lOiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiB0cnVlLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGZhbHNlLFxuICAgICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHM6IHRydWVcbiAgICB9LCAoZHJhZ2dhYmxlUHJvdmlkZWQsIGRyYWdnYWJsZVNuYXBzaG90KSA9PiByZW5kZXIoZHJhZ2dhYmxlUHJvdmlkZWQsIGRyYWdnYWJsZVNuYXBzaG90LCBkcmFnZ2luZykpO1xuICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwobm9kZSwgZ2V0Q29udGFpbmVyRm9yQ2xvbmUoKSk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcHBhYmxlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkcm9wcGFibGVDb250ZXh0XG4gIH0sIGNoaWxkcmVuKHByb3ZpZGVkLCBzbmFwc2hvdCksIGdldENsb25lKCkpO1xufTtcbnZhciBEcm9wcGFibGUkMSA9IERyb3BwYWJsZTtcblxuZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgIWRvY3VtZW50LmJvZHkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdkb2N1bWVudC5ib2R5IGlzIG5vdCByZWFkeScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG59XG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIG1vZGU6ICdzdGFuZGFyZCcsXG4gIHR5cGU6ICdERUZBVUxUJyxcbiAgZGlyZWN0aW9uOiAndmVydGljYWwnLFxuICBpc0Ryb3BEaXNhYmxlZDogZmFsc2UsXG4gIGlzQ29tYmluZUVuYWJsZWQ6IGZhbHNlLFxuICBpZ25vcmVDb250YWluZXJDbGlwcGluZzogZmFsc2UsXG4gIHJlbmRlckNsb25lOiBudWxsLFxuICBnZXRDb250YWluZXJGb3JDbG9uZTogZ2V0Qm9keVxufTtcbmNvbnN0IGF0dGFjaERlZmF1bHRQcm9wc1RvT3duUHJvcHMgPSBvd25Qcm9wcyA9PiB7XG4gIGxldCBtZXJnZWRQcm9wcyA9IHtcbiAgICAuLi5vd25Qcm9wc1xuICB9O1xuICBsZXQgZGVmYXVsdFByb3BLZXk7XG4gIGZvciAoZGVmYXVsdFByb3BLZXkgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKG93blByb3BzW2RlZmF1bHRQcm9wS2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtZXJnZWRQcm9wcyA9IHtcbiAgICAgICAgLi4ubWVyZ2VkUHJvcHMsXG4gICAgICAgIFtkZWZhdWx0UHJvcEtleV06IGRlZmF1bHRQcm9wc1tkZWZhdWx0UHJvcEtleV1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRQcm9wcztcbn07XG5jb25zdCBpc01hdGNoaW5nVHlwZSA9ICh0eXBlLCBjcml0aWNhbCkgPT4gdHlwZSA9PT0gY3JpdGljYWwuZHJvcHBhYmxlLnR5cGU7XG5jb25zdCBnZXREcmFnZ2FibGUgPSAoY3JpdGljYWwsIGRpbWVuc2lvbnMpID0+IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tjcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuY29uc3QgbWFrZU1hcFN0YXRlVG9Qcm9wcyA9ICgpID0+IHtcbiAgY29uc3QgaWRsZVdpdGhBbmltYXRpb24gPSB7XG4gICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiB0cnVlLFxuICAgIHNuYXBzaG90OiB7XG4gICAgICBpc0RyYWdnaW5nT3ZlcjogZmFsc2UsXG4gICAgICBkcmFnZ2luZ092ZXJXaXRoOiBudWxsLFxuICAgICAgZHJhZ2dpbmdGcm9tVGhpc1dpdGg6IG51bGwsXG4gICAgICBpc1VzaW5nUGxhY2Vob2xkZXI6IGZhbHNlXG4gICAgfSxcbiAgICB1c2VDbG9uZTogbnVsbFxuICB9O1xuICBjb25zdCBpZGxlV2l0aG91dEFuaW1hdGlvbiA9IHtcbiAgICAuLi5pZGxlV2l0aEFuaW1hdGlvbixcbiAgICBzaG91bGRBbmltYXRlUGxhY2Vob2xkZXI6IGZhbHNlXG4gIH07XG4gIGNvbnN0IGdldERyYWdnYWJsZVJ1YnJpYyA9IG1lbW9pemVPbmUoZGVzY3JpcHRvciA9PiAoe1xuICAgIGRyYWdnYWJsZUlkOiBkZXNjcmlwdG9yLmlkLFxuICAgIHR5cGU6IGRlc2NyaXB0b3IudHlwZSxcbiAgICBzb3VyY2U6IHtcbiAgICAgIGluZGV4OiBkZXNjcmlwdG9yLmluZGV4LFxuICAgICAgZHJvcHBhYmxlSWQ6IGRlc2NyaXB0b3IuZHJvcHBhYmxlSWRcbiAgICB9XG4gIH0pKTtcbiAgY29uc3QgZ2V0TWFwUHJvcHMgPSBtZW1vaXplT25lKChpZCwgaXNFbmFibGVkLCBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyLCBpc0RyYWdnaW5nT3ZlckZvckltcGFjdCwgZHJhZ2dpbmcsIHJlbmRlckNsb25lKSA9PiB7XG4gICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBkcmFnZ2luZy5kZXNjcmlwdG9yLmlkO1xuICAgIGNvbnN0IGlzSG9tZSA9IGRyYWdnaW5nLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQgPT09IGlkO1xuICAgIGlmIChpc0hvbWUpIHtcbiAgICAgIGNvbnN0IHVzZUNsb25lID0gcmVuZGVyQ2xvbmUgPyB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyQ2xvbmUsXG4gICAgICAgIGRyYWdnaW5nOiBnZXREcmFnZ2FibGVSdWJyaWMoZHJhZ2dpbmcuZGVzY3JpcHRvcilcbiAgICAgIH0gOiBudWxsO1xuICAgICAgY29uc3Qgc25hcHNob3QgPSB7XG4gICAgICAgIGlzRHJhZ2dpbmdPdmVyOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyLFxuICAgICAgICBkcmFnZ2luZ092ZXJXaXRoOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyID8gZHJhZ2dhYmxlSWQgOiBudWxsLFxuICAgICAgICBkcmFnZ2luZ0Zyb21UaGlzV2l0aDogZHJhZ2dhYmxlSWQsXG4gICAgICAgIGlzVXNpbmdQbGFjZWhvbGRlcjogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBsYWNlaG9sZGVyOiBkcmFnZ2luZy5wbGFjZWhvbGRlcixcbiAgICAgICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiBmYWxzZSxcbiAgICAgICAgc25hcHNob3QsXG4gICAgICAgIHVzZUNsb25lXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWlzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzRHJhZ2dpbmdPdmVyRm9ySW1wYWN0KSB7XG4gICAgICByZXR1cm4gaWRsZVdpdGhBbmltYXRpb247XG4gICAgfVxuICAgIGNvbnN0IHNuYXBzaG90ID0ge1xuICAgICAgaXNEcmFnZ2luZ092ZXI6IGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIsXG4gICAgICBkcmFnZ2luZ092ZXJXaXRoOiBkcmFnZ2FibGVJZCxcbiAgICAgIGRyYWdnaW5nRnJvbVRoaXNXaXRoOiBudWxsLFxuICAgICAgaXNVc2luZ1BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcGxhY2Vob2xkZXI6IGRyYWdnaW5nLnBsYWNlaG9sZGVyLFxuICAgICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiB0cnVlLFxuICAgICAgc25hcHNob3QsXG4gICAgICB1c2VDbG9uZTogbnVsbFxuICAgIH07XG4gIH0pO1xuICBjb25zdCBzZWxlY3RvciA9IChzdGF0ZSwgb3duUHJvcHMpID0+IHtcbiAgICBjb25zdCBvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMgPSBhdHRhY2hEZWZhdWx0UHJvcHNUb093blByb3BzKG93blByb3BzKTtcbiAgICBjb25zdCBpZCA9IG93blByb3BzV2l0aERlZmF1bHRQcm9wcy5kcm9wcGFibGVJZDtcbiAgICBjb25zdCB0eXBlID0gb3duUHJvcHNXaXRoRGVmYXVsdFByb3BzLnR5cGU7XG4gICAgY29uc3QgaXNFbmFibGVkID0gIW93blByb3BzV2l0aERlZmF1bHRQcm9wcy5pc0Ryb3BEaXNhYmxlZDtcbiAgICBjb25zdCByZW5kZXJDbG9uZSA9IG93blByb3BzV2l0aERlZmF1bHRQcm9wcy5yZW5kZXJDbG9uZTtcbiAgICBpZiAoaXNEcmFnZ2luZyhzdGF0ZSkpIHtcbiAgICAgIGNvbnN0IGNyaXRpY2FsID0gc3RhdGUuY3JpdGljYWw7XG4gICAgICBpZiAoIWlzTWF0Y2hpbmdUeXBlKHR5cGUsIGNyaXRpY2FsKSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2luZyA9IGdldERyYWdnYWJsZShjcml0aWNhbCwgc3RhdGUuZGltZW5zaW9ucyk7XG4gICAgICBjb25zdCBpc0RyYWdnaW5nT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCkgPT09IGlkO1xuICAgICAgcmV0dXJuIGdldE1hcFByb3BzKGlkLCBpc0VuYWJsZWQsIGlzRHJhZ2dpbmdPdmVyLCBpc0RyYWdnaW5nT3ZlciwgZHJhZ2dpbmcsIHJlbmRlckNsb25lKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG4gICAgICBpZiAoIWlzTWF0Y2hpbmdUeXBlKHR5cGUsIGNvbXBsZXRlZC5jcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dpbmcgPSBnZXREcmFnZ2FibGUoY29tcGxldGVkLmNyaXRpY2FsLCBzdGF0ZS5kaW1lbnNpb25zKTtcbiAgICAgIHJldHVybiBnZXRNYXBQcm9wcyhpZCwgaXNFbmFibGVkLCB3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQoY29tcGxldGVkLnJlc3VsdCkgPT09IGlkLCB3aGF0SXNEcmFnZ2VkT3Zlcihjb21wbGV0ZWQuaW1wYWN0KSA9PT0gaWQsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnICYmIHN0YXRlLmNvbXBsZXRlZCAmJiAhc3RhdGUuc2hvdWxkRmx1c2gpIHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcbiAgICAgIGlmICghaXNNYXRjaGluZ1R5cGUodHlwZSwgY29tcGxldGVkLmNyaXRpY2FsKSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCB3YXNPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoY29tcGxldGVkLmltcGFjdCkgPT09IGlkO1xuICAgICAgY29uc3Qgd2FzQ29tYmluaW5nID0gQm9vbGVhbihjb21wbGV0ZWQuaW1wYWN0LmF0ICYmIGNvbXBsZXRlZC5pbXBhY3QuYXQudHlwZSA9PT0gJ0NPTUJJTkUnKTtcbiAgICAgIGNvbnN0IGlzSG9tZSA9IGNvbXBsZXRlZC5jcml0aWNhbC5kcm9wcGFibGUuaWQgPT09IGlkO1xuICAgICAgaWYgKHdhc092ZXIpIHtcbiAgICAgICAgcmV0dXJuIHdhc0NvbWJpbmluZyA/IGlkbGVXaXRoQW5pbWF0aW9uIDogaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG4gICAgICBpZiAoaXNIb21lKSB7XG4gICAgICAgIHJldHVybiBpZGxlV2l0aEFuaW1hdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICB9O1xuICByZXR1cm4gc2VsZWN0b3I7XG59O1xuY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0ge1xuICB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbDogdXBkYXRlVmlld3BvcnRNYXhTY3JvbGxcbn07XG5jb25zdCBDb25uZWN0ZWREcm9wcGFibGUgPSBjb25uZWN0KG1ha2VNYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uYXR0YWNoRGVmYXVsdFByb3BzVG9Pd25Qcm9wcyhvd25Qcm9wcyksXG4gICAgLi4uc3RhdGVQcm9wcyxcbiAgICAuLi5kaXNwYXRjaFByb3BzXG4gIH07XG59LCB7XG4gIGNvbnRleHQ6IFN0b3JlQ29udGV4dCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsOiBpc1N0cmljdEVxdWFsXG59KShEcm9wcGFibGUkMSk7XG52YXIgQ29ubmVjdGVkRHJvcHBhYmxlJDEgPSBDb25uZWN0ZWREcm9wcGFibGU7XG5cbmV4cG9ydCB7IERyYWdEcm9wQ29udGV4dCwgUHVibGljRHJhZ2dhYmxlIGFzIERyYWdnYWJsZSwgQ29ubmVjdGVkRHJvcHBhYmxlJDEgYXMgRHJvcHBhYmxlLCByZXNldFNlcnZlckNvbnRleHQsIHVzZUtleWJvYXJkU2Vuc29yLCB1c2VNb3VzZVNlbnNvciwgdXNlVG91Y2hTZW5zb3IgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCQxIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDb250ZXh0IiwiUmVhY3RET00iLCJmbHVzaFN5bmMiLCJjcmVhdGVTdG9yZSIsImNyZWF0ZVN0b3JlJDEiLCJhcHBseU1pZGRsZXdhcmUiLCJjb21wb3NlIiwiYmluZEFjdGlvbkNyZWF0b3JzIiwiUHJvdmlkZXIiLCJjb25uZWN0IiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiZ2V0UmVjdCIsImV4cGFuZCIsIm9mZnNldCIsIndpdGhTY3JvbGwiLCJjYWxjdWxhdGVCb3giLCJnZXRCb3giLCJjcmVhdGVCb3giLCJtZW1vaXplT25lIiwicmFmU2NoZCIsIl9leHRlbmRzIiwiaXNQcm9kdWN0aW9uJDEiLCJwcm9jZXNzIiwic3BhY2VzQW5kVGFicyIsImxpbmVTdGFydFdpdGhTcGFjZXMiLCJjbGVhbiQyIiwidmFsdWUiLCJyZXBsYWNlIiwidHJpbSIsImdldERldk1lc3NhZ2UiLCJtZXNzYWdlIiwiZ2V0Rm9ybWF0dGVkTWVzc2FnZSIsImlzRGlzYWJsZWRGbGFnIiwibG9nIiwidHlwZSIsIndpbmRvdyIsImNvbnNvbGUiLCJ3YXJuaW5nIiwiYmluZCIsImVycm9yIiwibm9vcCQyIiwiZ2V0T3B0aW9ucyIsInNoYXJlZCIsImZyb21CaW5kaW5nIiwiYmluZEV2ZW50cyIsImVsIiwiYmluZGluZ3MiLCJzaGFyZWRPcHRpb25zIiwidW5iaW5kaW5ncyIsIm1hcCIsImJpbmRpbmciLCJvcHRpb25zIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImZuIiwidW5iaW5kIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVuYmluZEFsbCIsImZvckVhY2giLCJpc1Byb2R1Y3Rpb24iLCJwcmVmaXgkMSIsIlJiZEludmFyaWFudCIsIkVycm9yIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJFcnJvckJvdW5kYXJ5IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJhcmd1bWVudHMiLCJjYWxsYmFja3MiLCJvbldpbmRvd0Vycm9yIiwiZXZlbnQiLCJnZXRDYWxsYmFja3MiLCJpc0RyYWdnaW5nIiwidHJ5QWJvcnQiLCJlcnIiLCJwcmV2ZW50RGVmYXVsdCIsInNldENhbGxiYWNrcyIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkQ2F0Y2giLCJzZXRTdGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVuZGVyIiwicHJvcHMiLCJjaGlsZHJlbiIsImRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyIsInBvc2l0aW9uIiwiaW5kZXgiLCJvbkRyYWdTdGFydCIsInN0YXJ0Iiwic291cmNlIiwid2l0aExvY2F0aW9uIiwiZGVzdGluYXRpb24iLCJpc0luSG9tZUxpc3QiLCJkcm9wcGFibGVJZCIsInN0YXJ0UG9zaXRpb24iLCJlbmRQb3NpdGlvbiIsIndpdGhDb21iaW5lIiwiaWQiLCJjb21iaW5lIiwiaW5Ib21lTGlzdCIsImRyYWdnYWJsZUlkIiwib25EcmFnVXBkYXRlIiwidXBkYXRlIiwibG9jYXRpb24iLCJyZXR1cm5lZFRvU3RhcnQiLCJvbkRyYWdFbmQiLCJyZXN1bHQiLCJyZWFzb24iLCJwcmVzZXQiLCJwcmVzZXQkMSIsIm9yaWdpbiIsIngiLCJ5IiwiYWRkIiwicG9pbnQxIiwicG9pbnQyIiwic3VidHJhY3QiLCJpc0VxdWFsJDEiLCJuZWdhdGUiLCJwb2ludCIsInBhdGNoIiwibGluZSIsIm90aGVyVmFsdWUiLCJkaXN0YW5jZSIsIk1hdGgiLCJzcXJ0IiwiY2xvc2VzdCQxIiwidGFyZ2V0IiwicG9pbnRzIiwibWluIiwiYXBwbHkiLCJleGVjdXRlQ2xpcCIsImZyYW1lIiwic3ViamVjdCIsInRvcCIsIm1heCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0Iiwib2Zmc2V0QnlQb3NpdGlvbiIsInNwYWNpbmciLCJnZXRDb3JuZXJzIiwibm9TcGFjaW5nIiwic2Nyb2xsJDEiLCJzY3JvbGwiLCJkaWZmIiwiZGlzcGxhY2VtZW50IiwiaW5jcmVhc2UiLCJheGlzIiwid2l0aFBsYWNlaG9sZGVyIiwiaW5jcmVhc2VkQnkiLCJlbmQiLCJjbGlwIiwic2hvdWxkQ2xpcFN1YmplY3QiLCJwYWdlTWFyZ2luQm94IiwiZ2V0U3ViamVjdCIsIl9yZWYiLCJwYWdlIiwic2Nyb2xsZWQiLCJtYXJnaW5Cb3giLCJpbmNyZWFzZWQiLCJjbGlwcGVkIiwiYWN0aXZlIiwic2Nyb2xsRHJvcHBhYmxlIiwiZHJvcHBhYmxlIiwibmV3U2Nyb2xsIiwic2Nyb2xsYWJsZSIsInNjcm9sbERpZmYiLCJpbml0aWFsIiwic2Nyb2xsRGlzcGxhY2VtZW50IiwiY3VycmVudCIsInRvRHJvcHBhYmxlTWFwIiwiZHJvcHBhYmxlcyIsInJlZHVjZSIsInByZXZpb3VzIiwiZGVzY3JpcHRvciIsInRvRHJhZ2dhYmxlTWFwIiwiZHJhZ2dhYmxlcyIsInRvRHJvcHBhYmxlTGlzdCIsIk9iamVjdCIsInZhbHVlcyIsInRvRHJhZ2dhYmxlTGlzdCIsImdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUiLCJmaWx0ZXIiLCJkcmFnZ2FibGUiLCJzb3J0IiwiYSIsImIiLCJ0cnlHZXREZXN0aW5hdGlvbiIsImltcGFjdCIsImF0IiwidHJ5R2V0Q29tYmluZSIsInJlbW92ZURyYWdnYWJsZUZyb21MaXN0IiwicmVtb3ZlIiwibGlzdCIsIml0ZW0iLCJtb3ZlVG9OZXh0Q29tYmluZSIsImlzTW92aW5nRm9yd2FyZCIsImluc2lkZURlc3RpbmF0aW9uIiwicHJldmlvdXNJbXBhY3QiLCJpc0NvbWJpbmVFbmFibGVkIiwiZ2V0SW1wYWN0IiwiYWxsIiwiZGlzcGxhY2VkIiwiY2xvc2VzdElkIiwibGVuZ3RoIiwid2l0aG91dERyYWdnYWJsZSIsImxhc3QiLCJpbmRleE9mQ2xvc2VzdCIsImZpbmRJbmRleCIsImQiLCJwcm9wb3NlZEluZGV4IiwiYmVmb3JlIiwiaXNIb21lT2YiLCJub0Rpc3BsYWNlZEJ5IiwiZW1wdHlHcm91cHMiLCJpbnZpc2libGUiLCJ2aXNpYmxlIiwibm9JbXBhY3QiLCJkaXNwbGFjZWRCeSIsIm5vSW1wYWN0JDEiLCJpc1dpdGhpbiIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lIiwiaXNXaXRoaW5WZXJ0aWNhbCIsImlzV2l0aGluSG9yaXpvbnRhbCIsImlzQ29udGFpbmVkIiwiaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseSIsImlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseSIsImlzUGFydGlhbGx5Q29udGFpbmVkIiwiaXNCaWdnZXJWZXJ0aWNhbGx5IiwiaXNCaWdnZXJIb3Jpem9udGFsbHkiLCJpc1RhcmdldEJpZ2dlclRoYW5GcmFtZSIsImlzVGFyZ2V0QmlnZ2VyT25PbmVBeGlzIiwiaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSIsInZlcnRpY2FsIiwiZGlyZWN0aW9uIiwiY3Jvc3NBeGlzTGluZSIsInNpemUiLCJjcm9zc0F4aXNTdGFydCIsImNyb3NzQXhpc0VuZCIsImNyb3NzQXhpc1NpemUiLCJob3Jpem9udGFsIiwiaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZU9uQXhpcyIsImdldERyb3BwYWJsZURpc3BsYWNlZCIsImlzVmlzaWJsZUluRHJvcHBhYmxlIiwiaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4iLCJpc1Zpc2libGVJblZpZXdwb3J0Iiwidmlld3BvcnQiLCJpc1Zpc2libGUkMSIsInRvQmVEaXNwbGFjZWQiLCJ3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50IiwiZGlzcGxhY2VkVGFyZ2V0IiwiaXNQYXJ0aWFsbHlWaXNpYmxlIiwiYXJncyIsImlzVG90YWxseVZpc2libGUiLCJpc1RvdGFsbHlWaXNpYmxlT25BeGlzIiwiZ2V0U2hvdWxkQW5pbWF0ZSIsImZvcmNlU2hvdWxkQW5pbWF0ZSIsInNob3VsZEFuaW1hdGUiLCJnZXRUYXJnZXQiLCJleHBhbmRCeSIsImdldERpc3BsYWNlbWVudEdyb3VwcyIsImFmdGVyRHJhZ2dpbmciLCJncm91cHMiLCJwdXNoIiwiaXNWaXNpYmxlIiwiZ2V0SW5kZXhPZkxhc3RJdGVtIiwiaW5kZXhPZkxhc3RJdGVtIiwiZ29BdEVuZCIsIm5ld0luZGV4IiwiY2FsY3VsYXRlUmVvcmRlckltcGFjdCIsIl9yZWYyIiwibWF0Y2giLCJmaW5kIiwid2l0aG91dERyYWdnaW5nIiwic2xpY2VGcm9tIiwiaW5kZXhPZiIsImltcGFjdGVkIiwic2xpY2UiLCJkaWRTdGFydEFmdGVyQ3JpdGljYWwiLCJhZnRlckNyaXRpY2FsIiwiQm9vbGVhbiIsImVmZmVjdGVkIiwiZnJvbUNvbWJpbmUiLCJjb21iaW5lSWQiLCJjb21iaW5lV2l0aCIsImNvbWJpbmVXaXRoSW5kZXgiLCJkaWRDb21iaW5lV2l0aFN0YXJ0QWZ0ZXJDcml0aWNhbCIsImZyb21SZW9yZGVyIiwiY3VycmVudEluZGV4IiwiZmlyc3RJbmRleCIsImxhc3RJbmRleCIsIm1vdmVUb05leHRJbmRleCIsIndhc0F0IiwiZ2V0Q29tYmluZWRJdGVtRGlzcGxhY2VtZW50IiwiaXNEaXNwbGFjZWQiLCJ3aGVuQ29tYmluaW5nIiwiY2VudGVyIiwiYm9yZGVyQm94IiwiZGlzcGxhY2VCeSIsImRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIiLCJib3giLCJtYXJnaW4iLCJkaXN0YW5jZUZyb21FbmRUb0JvcmRlckJveENlbnRlciIsImdldENyb3NzQXhpc0JvcmRlckJveENlbnRlciIsImlzTW92aW5nIiwiZ29BZnRlciIsIm1vdmVSZWxhdGl2ZVRvIiwiZ29CZWZvcmUiLCJnb0ludG9TdGFydCIsIl9yZWYzIiwibW92ZUludG8iLCJjb250ZW50Qm94Iiwid2hlblJlb3JkZXJpbmciLCJkcmFnZ2FibGVQYWdlIiwiY2xvc2VzdEFmdGVyIiwiY2xvc2VzdCIsIndpdGhEaXNwbGFjZW1lbnQiLCJnZXRSZXN1bHRXaXRob3V0RHJvcHBhYmxlRGlzcGxhY2VtZW50Iiwib3JpZ2luYWwiLCJnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCIsIndpdGhvdXREaXNwbGFjZW1lbnQiLCJzY3JvbGxWaWV3cG9ydCIsInVwZGF0ZWQiLCJnZXREcmFnZ2FibGVzJDEiLCJpZHMiLCJ0cnlHZXRWaXNpYmxlIiwiaSIsInNwZWN1bGF0aXZlbHlJbmNyZWFzZSIsIm1heFNjcm9sbENoYW5nZSIsInNjcm9sbGVkVmlld3BvcnQiLCJzY3JvbGxlZERyb3BwYWJsZSIsIndpdGhWaWV3cG9ydFNjcm9sbCIsIndpdGhEcm9wcGFibGVTY3JvbGwiLCJuZXdJbXBhY3QiLCJ3aXRoVmlld3BvcnREaXNwbGFjZW1lbnQiLCJnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlciIsInBhZ2VCb3JkZXJCb3hDZW50ZXIiLCJ3aXRob3V0UGFnZVNjcm9sbENoYW5nZSIsImNsaWVudCIsImlzVG90YWxseVZpc2libGVJbk5ld0xvY2F0aW9uIiwibmV3UGFnZUJvcmRlckJveENlbnRlciIsIm9ubHlPbk1haW5BeGlzIiwiY2hhbmdlTmVlZGVkIiwic2hpZnRlZCIsIm1vdmVUb05leHRQbGFjZSIsInByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlciIsInByZXZpb3VzQ2xpZW50U2VsZWN0aW9uIiwiaXNFbmFibGVkIiwiaXNWaXNpYmxlSW5OZXdMb2NhdGlvbiIsImNsaWVudFNlbGVjdGlvbiIsInNjcm9sbEp1bXBSZXF1ZXN0IiwiY2F1dGlvdXMiLCJnZXRLbm93bkFjdGl2ZSIsInJlY3QiLCJnZXRCZXN0Q3Jvc3NBeGlzRHJvcHBhYmxlIiwiaXNCZXR3ZWVuU291cmNlQ2xpcHBlZCIsImNhbmRpZGF0ZXMiLCJhY3RpdmVPZlRhcmdldCIsImlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZCIsImZpcnN0Iiwic2Vjb25kIiwiYXJyYXkiLCJjb250YWlucyIsImlzV2l0aGluRHJvcHBhYmxlIiwiZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIiLCJnZXRDdXJyZW50UGFnZUJvcmRlckJveCIsImdldENsb3Nlc3REcmFnZ2FibGUiLCJzb3J0ZWQiLCJkaXN0YW5jZVRvQSIsImRpc3RhbmNlVG9CIiwiZ2V0RGlzcGxhY2VkQnkiLCJnZXRSZXF1aXJlZEdyb3d0aEZvclBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXJTaXplIiwibW9kZSIsImF2YWlsYWJsZVNwYWNlIiwiaW5zaWRlRHJvcHBhYmxlIiwic3BhY2VVc2VkIiwic3VtIiwiZGltZW5zaW9uIiwicmVxdWlyZWRTcGFjZSIsIm5lZWRzVG9Hcm93QnkiLCJ3aXRoTWF4U2Nyb2xsIiwiYWRkUGxhY2Vob2xkZXIiLCJyZXF1aXJlZEdyb3d0aCIsImFkZGVkIiwib2xkRnJhbWVNYXhTY3JvbGwiLCJtYXhTY3JvbGwiLCJuZXdGcmFtZSIsInJlbW92ZVBsYWNlaG9sZGVyIiwib2xkTWF4U2Nyb2xsIiwibW92ZVRvTmV3RHJvcHBhYmxlIiwicHJvcG9zZWQiLCJwcm9wb3NlZFBhZ2VCb3JkZXJCb3hDZW50ZXIiLCJpc0dvaW5nQmVmb3JlVGFyZ2V0IiwicmVsYXRpdmVUbyIsIm1vdmVDcm9zc0F4aXMiLCJpc092ZXIiLCJ3aGF0SXNEcmFnZ2VkT3ZlciIsImdldERyb3BwYWJsZU92ZXIkMSIsIm1vdmVJbkRpcmVjdGlvbiIsInN0YXRlIiwiaXNBY3R1YWxseU92ZXIiLCJkaW1lbnNpb25zIiwiaXNNYWluQXhpc01vdmVtZW50QWxsb3dlZCIsImhvbWUiLCJjcml0aWNhbCIsImlzTW92aW5nT25NYWluQXhpcyIsImJvcmRlckJveENlbnRlciIsInNlbGVjdGlvbiIsImlzTW92ZW1lbnRBbGxvd2VkIiwicGhhc2UiLCJpc1Bvc2l0aW9uSW5GcmFtZSIsInJ1biIsImdldEhhc092ZXJsYXAiLCJnZXRGdXJ0aGVzdEF3YXkiLCJwYWdlQm9yZGVyQm94Iiwic3RhcnRDZW50ZXIiLCJjYW5kaWRhdGUiLCJnZXREcm9wcGFibGVPdmVyIiwiY2hpbGRDZW50ZXIiLCJpc1N0YXJ0Q29udGFpbmVkIiwiaXNFbmRDb250YWluZWQiLCJvZmZzZXRSZWN0QnlQb3NpdGlvbiIsImFyZWEiLCJnZXRJc0Rpc3BsYWNlZCIsImF0SW5kZXgiLCJnZXRSZW9yZGVySW1wYWN0IiwicGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGwiLCJ0YXJnZXRSZWN0IiwidGFyZ2V0U3RhcnQiLCJ0YXJnZXRFbmQiLCJjaGlsZCIsImRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxIiwiY29tYmluZVRocmVzaG9sZERpdmlzb3IiLCJnZXRDb21iaW5lSW1wYWN0IiwiY2hpbGRSZWN0IiwiY2hpbGRTaXplIiwidGhyZXNob2xkIiwiZ2V0RHJhZ0ltcGFjdCIsInBhZ2VPZmZzZXQiLCJkZXN0aW5hdGlvbklkIiwicGF0Y2hEcm9wcGFibGVNYXAiLCJjbGVhclVudXNlZFBsYWNlaG9sZGVyIiwibm93IiwibGFzdERyb3BwYWJsZSIsInJlY29tcHV0ZVBsYWNlaG9sZGVycyIsImNsZWFuZWQiLCJwYXRjaGVkIiwiZm9yY2VkQ2xpZW50U2VsZWN0aW9uIiwiZm9yY2VkRGltZW5zaW9ucyIsImZvcmNlZFZpZXdwb3J0IiwiZm9yY2VkSW1wYWN0Iiwid2l0aFVwZGF0ZWRQbGFjZWhvbGRlcnMiLCJnZXREcmFnZ2FibGVzIiwicmVjb21wdXRlIiwiZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyIiwicmVmcmVzaFNuYXAiLCJtb3ZlbWVudE1vZGUiLCJuZWVkc1Zpc2liaWxpdHlDaGVjayIsImdldEhvbWVMb2NhdGlvbiIsImdldExpZnRFZmZlY3QiLCJpbnNpZGVIb21lIiwicmF3SW5kZXgiLCJpblZpcnR1YWxMaXN0IiwicGF0Y2hEaW1lbnNpb25NYXAiLCJrZXkiLCJmaW5pc2giLCJvZmZzZXREcmFnZ2FibGUiLCJvZmZzZXQkMSIsImluaXRpYWxXaW5kb3dTY3JvbGwiLCJtb3ZlZCIsInBsYWNlaG9sZGVyIiwiZ2V0RnJhbWUiLCJhZGp1c3RBZGRpdGlvbnNGb3JTY3JvbGxDaGFuZ2VzIiwiYWRkaXRpb25zIiwidXBkYXRlZERyb3BwYWJsZXMiLCJ3aW5kb3dTY3JvbGxDaGFuZ2UiLCJtb2RpZmllZCIsImRyb3BwYWJsZVNjcm9sbENoYW5nZSIsInRvdGFsQ2hhbmdlIiwidGltaW5nc0tleSIsInB1Ymxpc2hXaGlsZURyYWdnaW5nSW5WaXJ0dWFsIiwicHVibGlzaGVkIiwid2l0aFNjcm9sbENoYW5nZSIsImV4aXN0aW5nIiwidXBkYXRlZEFkZGl0aW9ucyIsInJlbW92YWxzIiwid2FzT3ZlcklkIiwid2FzT3ZlciIsIm9uTGlmdEltcGFjdCIsImRyYWdnaW5nU3RhdGUiLCJkcm9wUGVuZGluZyIsImlzV2FpdGluZyIsImlzU25hcHBpbmciLCJwb3N0RHJvcHBhYmxlQ2hhbmdlIiwiaXNFbmFibGVkQ2hhbmdpbmciLCJyZW1vdmVTY3JvbGxKdW1wUmVxdWVzdCIsImlkbGUkMiIsImNvbXBsZXRlZCIsInNob3VsZEZsdXNoIiwicmVkdWNlciIsImFjdGlvbiIsInBheWxvYWQiLCJpc1dpbmRvd1Njcm9sbEFsbG93ZWQiLCJldmVyeSIsImlzRml4ZWRPblBhZ2UiLCJTdHJpbmciLCJuZXdTdGF0ZSIsImRyb3BEdXJhdGlvbiIsIm5ld0hvbWVDbGllbnRPZmZzZXQiLCJiZWZvcmVJbml0aWFsQ2FwdHVyZSIsImxpZnQkMSIsImluaXRpYWxQdWJsaXNoIiwicHVibGlzaFdoaWxlRHJhZ2dpbmciLCJjb2xsZWN0aW9uU3RhcnRpbmciLCJ1cGRhdGVEcm9wcGFibGVTY3JvbGwiLCJ1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQiLCJ1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkIiwibW92ZSIsIm1vdmVCeVdpbmRvd1Njcm9sbCIsInVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsIiwibW92ZVVwIiwibW92ZURvd24iLCJtb3ZlUmlnaHQiLCJtb3ZlTGVmdCIsImZsdXNoIiwiYW5pbWF0ZURyb3AiLCJjb21wbGV0ZURyb3AiLCJkcm9wJDEiLCJkcm9wQW5pbWF0aW9uRmluaXNoZWQiLCJjaGVja0luZGV4ZXMiLCJpbmRleGVzIiwiZXJyb3JzIiwia2V5cyIsImZvcm1hdHRlZCIsImhhc0Vycm9yIiwiam9pbiIsInZhbGlkYXRlRGltZW5zaW9ucyIsImxpZnQiLCJtYXJzaGFsIiwiZ2V0U3RhdGUiLCJkaXNwYXRjaCIsIm5leHQiLCJzY3JvbGxPcHRpb25zIiwic2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5IiwicmVxdWVzdCIsInN0YXJ0UHVibGlzaGluZyIsInN0eWxlIiwiZHJhZ2dpbmciLCJkcm9wcGluZyIsInJlc3RpbmciLCJjdXJ2ZXMiLCJvdXRPZlRoZVdheSIsImRyb3AiLCJvcGFjaXR5IiwiY29tYmluaW5nIiwic2NhbGUiLCJ0aW1pbmdzIiwibWluRHJvcFRpbWUiLCJtYXhEcm9wVGltZSIsIm91dE9mVGhlV2F5VGltaW5nIiwidHJhbnNpdGlvbnMiLCJmbHVpZCIsInNuYXAiLCJkdXJhdGlvbiIsInRpbWluZyIsIm1vdmVUbyIsInVuZGVmaW5lZCIsInRyYW5zZm9ybXMiLCJpc0NvbWJpbmluZyIsInRyYW5zbGF0ZSIsImRyb3BUaW1lUmFuZ2UiLCJtYXhEcm9wVGltZUF0RGlzdGFuY2UiLCJjYW5jZWxEcm9wTW9kaWZpZXIiLCJnZXREcm9wRHVyYXRpb24iLCJkaXN0YW5jZSQxIiwicGVyY2VudGFnZSIsIndpdGhEdXJhdGlvbiIsIk51bWJlciIsInRvRml4ZWQiLCJnZXROZXdIb21lQ2xpZW50T2Zmc2V0IiwibmV3Q2xpZW50Q2VudGVyIiwiZ2V0RHJvcEltcGFjdCIsImxhc3RJbXBhY3QiLCJyZWNvbXB1dGVkSG9tZUltcGFjdCIsImRpZERyb3BJbnNpZGVEcm9wcGFibGUiLCJ3aXRob3V0TW92ZW1lbnQiLCJkcm9wTWlkZGxld2FyZSIsImlzV2FpdGluZ0ZvckRyb3AiLCJpc0FuaW1hdGlvblJlcXVpcmVkIiwiZ2V0V2luZG93U2Nyb2xsIiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImdldFdpbmRvd1Njcm9sbEJpbmRpbmciLCJwYXNzaXZlIiwiY2FwdHVyZSIsImRvY3VtZW50IiwiZ2V0U2Nyb2xsTGlzdGVuZXIiLCJvbldpbmRvd1Njcm9sbCIsInVwZGF0ZVNjcm9sbCIsInNjaGVkdWxlZCIsImlzQWN0aXZlIiwic3RvcCIsImNhbmNlbCIsInNob3VsZEVuZCIsInNjcm9sbExpc3RlbmVyIiwic3RvcmUiLCJsaXN0ZW5lciIsInNjcm9sbExpc3RlbmVyJDEiLCJnZXRFeHBpcmluZ0Fubm91bmNlIiwiYW5ub3VuY2UiLCJ3YXNDYWxsZWQiLCJpc0V4cGlyZWQiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZ2V0QXN5bmNNYXJzaGFsIiwiZW50cmllcyIsImV4ZWN1dGUiLCJ0aW1lcklkIiwiZW50cnkiLCJzcGxpY2UiLCJjYWxsYmFjayIsInNoYWxsb3ciLCJhcmVMb2NhdGlvbnNFcXVhbCIsImlzQ29tYmluZUVxdWFsIiwiaXNDcml0aWNhbEVxdWFsIiwiaXNEcmFnZ2FibGVFcXVhbCIsImlzRHJvcHBhYmxlRXF1YWwiLCJ3aXRoVGltaW5ncyIsImdldERyYWdTdGFydCIsInJlc3BvbmRlciIsImRhdGEiLCJnZXREZWZhdWx0TWVzc2FnZSIsIndpbGxFeHBpcmUiLCJwcm92aWRlZCIsImdldFB1Ymxpc2hlciIsImdldFJlc3BvbmRlcnMiLCJhc3luY01hcnNoYWwiLCJiZWZvcmVDYXB0dXJlIiwib25CZWZvcmVDYXB0dXJlIiwiYmVmb3JlU3RhcnQiLCJvbkJlZm9yZURyYWdTdGFydCIsImxhc3RDcml0aWNhbCIsImxhc3RMb2NhdGlvbiIsImxhc3RDb21iaW5lIiwiaGFzQ3JpdGljYWxDaGFuZ2VkIiwiaGFzTG9jYXRpb25DaGFuZ2VkIiwiaGFzR3JvdXBpbmdDaGFuZ2VkIiwiYWJvcnQiLCJyZXNwb25kZXJzIiwicHVibGlzaGVyIiwiZHJvcEFuaW1hdGlvbkZpbmlzaE1pZGRsZXdhcmUiLCJkcm9wQW5pbWF0aW9uRmluaXNoIiwiZHJvcEFuaW1hdGlvbkZsdXNoT25TY3JvbGxNaWRkbGV3YXJlIiwiZnJhbWVJZCIsImNsZWFyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJvbmNlIiwiZmx1c2hEcm9wQW5pbWF0aW9uIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZHJvcEFuaW1hdGlvbkZsdXNoT25TY3JvbGwiLCJkaW1lbnNpb25NYXJzaGFsU3RvcHBlciIsInN0b3BQdWJsaXNoaW5nIiwiZm9jdXMiLCJpc1dhdGNoaW5nIiwidHJ5UmVjb3JkRm9jdXMiLCJ0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCIsInRyeVNoaWZ0UmVjb3JkIiwic2hvdWxkU3RvcCIsImF1dG9TY3JvbGwiLCJhdXRvU2Nyb2xsZXIiLCJwZW5kaW5nRHJvcCIsInBvc3RBY3Rpb25TdGF0ZSIsInBlbmRpbmdEcm9wJDEiLCJjb21wb3NlRW5oYW5jZXJzIiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIiwibmFtZSIsImRpbWVuc2lvbk1hcnNoYWwiLCJmb2N1c01hcnNoYWwiLCJzdHlsZU1hcnNoYWwiLCJjbGVhbiQxIiwiY3JlYXRlUHVibGlzaGVyIiwicmVnaXN0cnkiLCJzdGFnaW5nIiwiY29sbGVjdCIsImdldEJ5SWQiLCJnZXREaW1lbnNpb24iLCJnZXRTY3JvbGxXaGlsZURyYWdnaW5nIiwicHVibGlzaCIsImdldE1heFNjcm9sbCIsInNjcm9sbEhlaWdodCIsInNjcm9sbFdpZHRoIiwiYWRqdXN0ZWRNYXhTY3JvbGwiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJkb2MiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRNYXhXaW5kb3dTY3JvbGwiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImdldFZpZXdwb3J0IiwiZ2V0SW5pdGlhbFB1Ymxpc2giLCJ3aW5kb3dTY3JvbGwiLCJnZXRBbGxCeVR5cGUiLCJnZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCIsInNob3VsZFB1Ymxpc2hVcGRhdGUiLCJjcmVhdGVEaW1lbnNpb25NYXJzaGFsIiwiY29sbGVjdGlvbiIsImV4aXN0cyIsImNoYW5nZSIsImRyYWdTdG9wcGVkIiwidW5zdWJzY3JpYmUiLCJzdWJzY3JpYmVyIiwic3Vic2NyaWJlIiwiY2FuU3RhcnREcmFnIiwic2Nyb2xsV2luZG93Iiwic2Nyb2xsQnkiLCJnZXRTY3JvbGxhYmxlRHJvcHBhYmxlcyIsImdldFNjcm9sbGFibGVEcm9wcGFibGVPdmVyIiwibWF5YmUiLCJnZXRCZXN0U2Nyb2xsYWJsZURyb3BwYWJsZSIsImRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zIiwic3RhcnRGcm9tUGVyY2VudGFnZSIsIm1heFNjcm9sbEF0UGVyY2VudGFnZSIsIm1heFBpeGVsU2Nyb2xsIiwiZWFzZSIsImR1cmF0aW9uRGFtcGVuaW5nIiwic3RvcERhbXBlbmluZ0F0IiwiYWNjZWxlcmF0ZUF0IiwiZGlzYWJsZWQiLCJnZXREaXN0YW5jZVRocmVzaG9sZHMiLCJjb250YWluZXIiLCJnZXRBdXRvU2Nyb2xsZXJPcHRpb25zIiwiYXV0b1Njcm9sbGVyT3B0aW9ucyIsInN0YXJ0U2Nyb2xsaW5nRnJvbSIsIm1heFNjcm9sbFZhbHVlQXQiLCJ0aHJlc2hvbGRzIiwiZ2V0UGVyY2VudGFnZSIsInN0YXJ0T2ZSYW5nZSIsImVuZE9mUmFuZ2UiLCJyYW5nZSIsImN1cnJlbnRJblJhbmdlIiwibWluU2Nyb2xsIiwiZ2V0VmFsdWVGcm9tRGlzdGFuY2UiLCJkaXN0YW5jZVRvRWRnZSIsInBlcmNlbnRhZ2VGcm9tTWF4U2Nyb2xsVmFsdWVBdCIsInBlcmNlbnRhZ2VGcm9tU3RhcnRTY3JvbGxpbmdGcm9tIiwiY2VpbCIsImRhbXBlblZhbHVlQnlUaW1lIiwicHJvcG9zZWRTY3JvbGwiLCJkcmFnU3RhcnRUaW1lIiwic3RvcEF0IiwiRGF0ZSIsInJ1blRpbWUiLCJiZXR3ZWVuQWNjZWxlcmF0ZUF0QW5kU3RvcEF0UGVyY2VudGFnZSIsImdldFZhbHVlIiwic2hvdWxkVXNlVGltZURhbXBlbmluZyIsImdldFNjcm9sbE9uQXhpcyIsImRpc3RhbmNlVG9FZGdlcyIsImlzQ2xvc2VyVG9FbmQiLCJhZGp1c3RGb3JTaXplTGltaXRzIiwiaXNUb29CaWdWZXJ0aWNhbGx5IiwiaXNUb29CaWdIb3Jpem9udGFsbHkiLCJjbGVhbiIsImdldFNjcm9sbCQxIiwicmVxdWlyZWQiLCJsaW1pdGVkIiwic21hbGxlc3RTaWduZWQiLCJnZXRPdmVybGFwIiwiZ2V0UmVtYWluZGVyIiwidGFyZ2V0U2Nyb2xsIiwib3ZlcmxhcCIsImNhblBhcnRpYWxseVNjcm9sbCIsInJhd01heCIsInNtYWxsZXN0Q2hhbmdlIiwiY2FuU2Nyb2xsV2luZG93IiwiZ2V0V2luZG93T3ZlcmxhcCIsImNhblNjcm9sbERyb3BwYWJsZSIsImdldERyb3BwYWJsZU92ZXJsYXAiLCJnZXRXaW5kb3dTY3JvbGxDaGFuZ2UiLCJnZXREcm9wcGFibGVTY3JvbGxDaGFuZ2UiLCJjcmVhdGVGbHVpZFNjcm9sbGVyIiwic2NoZWR1bGVXaW5kb3dTY3JvbGwiLCJzY2hlZHVsZURyb3BwYWJsZVNjcm9sbCIsInRyeVNjcm9sbCIsInN0YXJ0JDEiLCJ3YXNTY3JvbGxOZWVkZWQiLCJmYWtlU2Nyb2xsQ2FsbGJhY2siLCJjcmVhdGVKdW1wU2Nyb2xsZXIiLCJtb3ZlQnlPZmZzZXQiLCJzY3JvbGxEcm9wcGFibGVBc011Y2hBc0l0Q2FuIiwid2hhdFRoZURyb3BwYWJsZUNhblNjcm9sbCIsInJlbWFpbmRlciIsInNjcm9sbFdpbmRvd0FzTXVjaEFzSXRDYW4iLCJ3aGF0VGhlV2luZG93Q2FuU2Nyb2xsIiwianVtcFNjcm9sbGVyIiwiZHJvcHBhYmxlUmVtYWluZGVyIiwid2luZG93UmVtYWluZGVyIiwiY3JlYXRlQXV0b1Njcm9sbGVyIiwiZmx1aWRTY3JvbGxlciIsImp1bXBTY3JvbGwiLCJzY3JvbGxlciIsInByZWZpeCIsImRyYWdIYW5kbGUiLCJiYXNlIiwiY29udGV4dElkIiwic2Nyb2xsQ29udGFpbmVyIiwibWFrZUdldFNlbGVjdG9yIiwiY29udGV4dCIsImF0dHJpYnV0ZSIsImdldFN0eWxlcyIsInJ1bGVzIiwicHJvcGVydHkiLCJydWxlIiwic3R5bGVzIiwic2VsZWN0b3IiLCJub1BvaW50ZXJFdmVudHMiLCJnZXRTdHlsZXMkMSIsImdldFNlbGVjdG9yIiwiZHJhZ0hhbmRsZSQxIiwiZ3JhYkN1cnNvciIsImFsd2F5cyIsImRyb3BBbmltYXRpbmciLCJkcmFnZ2FibGUkMSIsInRyYW5zaXRpb24iLCJ1c2VyQ2FuY2VsIiwiZHJvcHBhYmxlJDEiLCJib2R5IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImNyZWF0ZUVsZW1lbnQiLCJnZXRIZWFkIiwiaGVhZCIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVTdHlsZUVsIiwibm9uY2UiLCJzZXRBdHRyaWJ1dGUiLCJ1c2VTdHlsZU1hcnNoYWwiLCJhbHdheXNSZWYiLCJkeW5hbWljUmVmIiwic2V0RHluYW1pY1N0eWxlIiwidGV4dENvbnRlbnQiLCJzZXRBbHdheXNTdHlsZSIsImR5bmFtaWMiLCJhcHBlbmRDaGlsZCIsInJlZiIsInJlbW92ZUNoaWxkIiwicXVlcnlTZWxlY3RvckFsbCIsInBhcmVudE5vZGUiLCJBcnJheSIsImZyb20iLCJnZXRXaW5kb3dGcm9tRWwiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0h0bWxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJmaW5kRHJhZ0hhbmRsZSIsInBvc3NpYmxlIiwiaGFuZGxlIiwiZ2V0QXR0cmlidXRlIiwidXNlRm9jdXNNYXJzaGFsIiwiZW50cmllc1JlZiIsInJlY29yZFJlZiIsInJlc3RvcmVGb2N1c0ZyYW1lUmVmIiwiaXNNb3VudGVkUmVmIiwicmVnaXN0ZXIiLCJ1bnJlZ2lzdGVyIiwidHJ5R2l2ZUZvY3VzIiwidHJ5R2l2ZUZvY3VzVG8iLCJhY3RpdmVFbGVtZW50IiwicmVkaXJlY3RUbyIsInJlY29yZCIsImZvY3VzZWQiLCJjbGVhckZyYW1lT25Vbm1vdW50IiwiY3JlYXRlUmVnaXN0cnkiLCJzdWJzY3JpYmVycyIsImNiIiwibm90aWZ5IiwiZmluZERyYWdnYWJsZUJ5SWQiLCJnZXREcmFnZ2FibGVCeUlkIiwiZHJhZ2dhYmxlQVBJIiwidW5pcXVlSWQiLCJmaW5kQnlJZCIsImZpbmREcm9wcGFibGVCeUlkIiwiZ2V0RHJvcHBhYmxlQnlJZCIsImRyb3BwYWJsZUFQSSIsInVzZVJlZ2lzdHJ5IiwidW5tb3VudCIsInZlcnNpb24iLCJzdGFydHNXaXRoIiwiU3RvcmVDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImdldEJvZHlFbGVtZW50IiwidmlzdWFsbHlIaWRkZW4iLCJib3JkZXIiLCJwYWRkaW5nIiwib3ZlcmZsb3ciLCJ2aXN1YWxseUhpZGRlbiQxIiwiZ2V0SWQiLCJ1c2VBbm5vdW5jZXIiLCJzZXR1cCIsImNsZWFudXAiLCJjb3VudCQxIiwiZGVmYXVsdHMiLCJzZXBhcmF0b3IiLCJyZXNldERlcHJlY2F0ZWRVbmlxdWVJZCIsInVzZURlcHJlY2F0ZWRVbmlxdWVJZCIsInVzZVVuaXF1ZUlkIiwidXNlSWQiLCJ1c2VVbmlxdWVJZCQxIiwiZ2V0RWxlbWVudElkIiwidXNlSGlkZGVuVGV4dEVsZW1lbnQiLCJ0ZXh0IiwibW91bnQiLCJkaXNwbGF5IiwiQXBwQ29udGV4dCIsInBlZXJEZXBlbmRlbmNpZXMiLCJyZWFjdCIsInNlbXZlciIsImdldFZlcnNpb24iLCJleGVjIiwibWFqb3IiLCJtaW5vciIsInJhdyIsImlzU2F0aXNmaWVkIiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJjaGVja1JlYWN0VmVyc2lvbiIsInBlZXJEZXBWYWx1ZSIsImFjdHVhbFZhbHVlIiwicGVlckRlcCIsInN1ZmZpeCIsImNoZWNrRG9jdHlwZSIsImRvY3R5cGUiLCJ0b0xvd2VyQ2FzZSIsInB1YmxpY0lkIiwidXNlRGV2IiwidXNlSG9vayIsInVzZURldlNldHVwV2FybmluZyIsImlucHV0cyIsImUiLCJ1c2VTdGFydHVwVmFsaWRhdGlvbiIsInVzZVByZXZpb3VzIiwiY3JlYXRlIiwibG9jayIsImlzQ2xhaW1lZCIsImNsYWltIiwiYWJhbmRvbiIsIm5ld0xvY2siLCJyZWxlYXNlIiwidHJ5QWJhbmRvbiIsInRhYiIsImVudGVyIiwiZXNjYXBlIiwic3BhY2UiLCJwYWdlVXAiLCJwYWdlRG93biIsImFycm93TGVmdCIsImFycm93VXAiLCJhcnJvd1JpZ2h0IiwiYXJyb3dEb3duIiwicHJldmVudGVkS2V5cyIsInByZXZlbnRTdGFuZGFyZEtleUV2ZW50cyIsImtleUNvZGUiLCJzdXBwb3J0ZWRFdmVudE5hbWUiLCJzdXBwb3J0ZWQiLCJzdXBwb3J0ZWRQYWdlVmlzaWJpbGl0eUV2ZW50TmFtZSIsInByaW1hcnlCdXR0b24iLCJzbG9wcHlDbGlja1RocmVzaG9sZCIsImlzU2xvcHB5Q2xpY2tUaHJlc2hvbGRFeGNlZWRlZCIsImFicyIsImlkbGUkMSIsImdldENhcHR1cmVCaW5kaW5ncyIsImdldFBoYXNlIiwic2V0UGhhc2UiLCJidXR0b24iLCJjbGllbnRYIiwiY2xpZW50WSIsImFjdGlvbnMiLCJwZW5kaW5nIiwiZmx1aWRMaWZ0Iiwic2hvdWxkQmxvY2tOZXh0Q2xpY2siLCJzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyIsInVzZU1vdXNlU2Vuc29yIiwiYXBpIiwicGhhc2VSZWYiLCJ1bmJpbmRFdmVudHNSZWYiLCJzdGFydENhcHR1cmVCaW5kaW5nIiwib25Nb3VzZURvd24iLCJkZWZhdWx0UHJldmVudGVkIiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsImZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQiLCJ0cnlHZXRMb2NrIiwic291cmNlRXZlbnQiLCJzdGFydFBlbmRpbmdEcmFnIiwicHJldmVudEZvcmNlUHJlc3NCaW5kaW5nIiwiZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUiLCJjYW5HZXRMb2NrIiwibGlzdGVuRm9yQ2FwdHVyZSIsImJpbmRDYXB0dXJpbmdFdmVudHMiLCJub29wJDEiLCJzY3JvbGxKdW1wS2V5cyIsImdldERyYWdnaW5nQmluZGluZ3MiLCJ1c2VLZXlib2FyZFNlbnNvciIsIm9uS2V5RG93biIsInByZURyYWciLCJpc0NhcHR1cmluZyIsInNuYXBMaWZ0IiwidHJ5U3RhcnRDYXB0dXJlIiwiaWRsZSIsInRpbWVGb3JMb25nUHJlc3MiLCJmb3JjZVByZXNzVGhyZXNob2xkIiwiZ2V0V2luZG93QmluZGluZ3MiLCJnZXRIYW5kbGVCaW5kaW5ncyIsImhhc01vdmVkIiwidG91Y2hlcyIsInRvdWNoIiwiaXNGb3JjZVByZXNzIiwiZm9yY2UiLCJzaG91bGRSZXNwZWN0IiwidXNlVG91Y2hTZW5zb3IiLCJvblRvdWNoU3RhcnQiLCJsb25nUHJlc3NUaW1lcklkIiwidW5iaW5kVGFyZ2V0IiwidW5iaW5kV2luZG93Iiwic3RhcnREcmFnZ2luZyIsIndlYmtpdEhhY2siLCJ1c2VWYWxpZGF0ZVNlbnNvckhvb2tzIiwic2Vuc29ySG9va3MiLCJwcmV2aW91c1JlZiIsImludGVyYWN0aXZlVGFnTmFtZXMiLCJpc0FuSW50ZXJhY3RpdmVFbGVtZW50IiwicGFyZW50IiwiaGFzQW5JbnRlcmFjdGl2ZVRhZyIsImluY2x1ZGVzIiwidGFnTmFtZSIsInBhcmVudEVsZW1lbnQiLCJpc0V2ZW50SW5JbnRlcmFjdGl2ZUVsZW1lbnQiLCJnZXRCb3JkZXJCb3hDZW50ZXJQb3NpdGlvbiIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImlzRWxlbWVudCIsIkVsZW1lbnQiLCJzdXBwb3J0ZWRNYXRjaGVzTmFtZSIsImNsb3Nlc3RQb255ZmlsbCIsImZpbmRDbG9zZXN0RHJhZ0hhbmRsZUZyb21FdmVudCIsInRyeUdldENsb3Nlc3REcmFnZ2FibGVJZEZyb21FdmVudCIsImZpbmREcmFnZ2FibGUiLCJpc0xvY2tBY3RpdmUiLCJzaG91bGRXYXJuIiwiY2FuU3RhcnQiLCJsb2NrQVBJIiwidHJ5U3RhcnQiLCJmb3JjZVNlbnNvclN0b3AiLCJzaG91bGRTdGFydCIsImNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzIiwiZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MiLCJ0cnlEaXNwYXRjaCIsImdldEFjdGlvbiIsInRyeURpc3BhdGNoV2hlbkRyYWdnaW5nIiwibGlmdEFjdGlvbkFyZ3MiLCJtb3ZlJDEiLCJhYm9ydFByZURyYWciLCJzaG91bGRSZWxlYXNlIiwiZGVmYXVsdFNlbnNvcnMiLCJ1c2VTZW5zb3JNYXJzaGFsIiwiX3JlZjQiLCJjdXN0b21TZW5zb3JzIiwiZW5hYmxlRGVmYXVsdFNlbnNvcnMiLCJ1c2VTZW5zb3JzIiwidHJ5QWJhbmRvbkxvY2siLCJsaXN0ZW5Ub1N0b3JlIiwiZm9yY2VTdG9wIiwidHJ5UmVsZWFzZUxvY2siLCJpc0xvY2tDbGFpbWVkIiwiY3JlYXRlUmVzcG9uZGVycyIsInQiLCJvbkJlZm9yZUNhcHVyZUNhbGxiYWNrIiwiY3JlYXRlQXV0b1Njcm9sbGVyT3B0aW9ucyIsImdldFN0b3JlIiwibGF6eVJlZiIsIkFwcCIsInNlbnNvcnMiLCJsYXp5U3RvcmVSZWYiLCJsYXN0UHJvcHNSZWYiLCJkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCIsImxhenlEaXNwYXRjaCIsIm1hcnNoYWxDYWxsYmFja3MiLCJ0cnlSZXNldFN0b3JlIiwiYXBwQ2FsbGJhY2tzIiwiZ2V0Q2FuTGlmdCIsImdldElzTW92ZW1lbnRBbGxvd2VkIiwiYXBwQ29udGV4dCIsImNhbkxpZnQiLCJjb3VudCIsInJlc2V0RGVwcmVjYXRlZFVuaXF1ZUNvbnRleHRJZCIsInVzZURlcHJlY2F0ZWRVbmlxdWVDb250ZXh0SWQiLCJ1c2VVbmlxdWVDb250ZXh0SWQiLCJ1c2VVbmlxdWVDb250ZXh0SWQkMSIsInJlc2V0U2VydmVyQ29udGV4dCIsIkRyYWdEcm9wQ29udGV4dCIsInpJbmRleE9wdGlvbnMiLCJnZXREcmFnZ2luZ1RyYW5zaXRpb24iLCJzaG91bGRBbmltYXRlRHJhZ01vdmVtZW50IiwiZ2V0RHJhZ2dpbmdPcGFjaXR5IiwiaXNEcm9wQW5pbWF0aW5nIiwiZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlIiwiZ2V0RHJhZ2dpbmdTdHlsZSIsInRyYW5zZm9ybSIsImJveFNpemluZyIsInpJbmRleCIsInBvaW50ZXJFdmVudHMiLCJnZXRTZWNvbmRhcnlTdHlsZSIsInNlY29uZGFyeSIsInNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQiLCJnZXRTdHlsZSQxIiwibWFwcGVkIiwiZ2V0RGltZW5zaW9uJDEiLCJjb21wdXRlZFN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ1c2VEcmFnZ2FibGVQdWJsaXNoZXIiLCJnZXREcmFnZ2FibGVSZWYiLCJwdWJsaXNoZWRSZWYiLCJpc0ZpcnN0UHVibGlzaFJlZiIsIkRyb3BwYWJsZUNvbnRleHQiLCJjaGVja0lzVmFsaWRJbm5lclJlZiIsInVzZVZhbGlkYXRpb24kMSIsImdldFJlZiIsImlzSW50ZWdlciIsInVzZUNsb25lUHJvcFZhbGlkYXRpb24iLCJpc0Nsb25lIiwiaW5pdGlhbFJlZiIsInVzZVJlcXVpcmVkQ29udGV4dCIsIkNvbnRleHQiLCJwcmV2ZW50SHRtbDVEbmQiLCJEcmFnZ2FibGUiLCJzZXRSZWYiLCJkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24iLCJmb3JQdWJsaXNoZXIiLCJkcmFnSGFuZGxlUHJvcHMiLCJ0YWJJbmRleCIsInJvbGUiLCJvbk1vdmVFbmQiLCJwcm9wZXJ0eU5hbWUiLCJvblRyYW5zaXRpb25FbmQiLCJpbm5lclJlZiIsImRyYWdnYWJsZVByb3BzIiwicnVicmljIiwiRnJhZ21lbnQiLCJzbmFwc2hvdCIsIkRyYWdnYWJsZSQxIiwiaXNTdHJpY3RFcXVhbCIsIndoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdCIsImdldENvbWJpbmVXaXRoRnJvbVJlc3VsdCIsImdldENvbWJpbmVXaXRoRnJvbUltcGFjdCIsImdldERyYWdnYWJsZVNlbGVjdG9yIiwibWVtb2l6ZWRPZmZzZXQiLCJnZXRNZW1vaXplZFNuYXBzaG90IiwiZHJhZ2dpbmdPdmVyIiwiZHJvcEFuaW1hdGlvbiIsImNvbWJpbmVUYXJnZXRGb3IiLCJnZXRNZW1vaXplZFByb3BzIiwib3duUHJvcHMiLCJjdXJ2ZSIsImdldFNlY29uZGFyeVNuYXBzaG90IiwiYXRSZXN0IiwiZ2V0U2Vjb25kYXJ5U2VsZWN0b3IiLCJnZXRGYWxsYmFjayIsImdldFByb3BzIiwib3duSWQiLCJkcmFnZ2luZ0lkIiwidmlzdWFsRGlzcGxhY2VtZW50IiwiaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCIsIm1ha2VNYXBTdGF0ZVRvUHJvcHMkMSIsImRyYWdnaW5nU2VsZWN0b3IiLCJzZWNvbmRhcnlTZWxlY3RvciIsIm1hcERpc3BhdGNoVG9Qcm9wcyQxIiwiQ29ubmVjdGVkRHJhZ2dhYmxlIiwiYXJlU3RhdGVQcm9wc0VxdWFsIiwiQ29ubmVjdGVkRHJhZ2dhYmxlJDEiLCJQcml2YXRlRHJhZ2dhYmxlIiwiZHJvcHBhYmxlQ29udGV4dCIsImlzVXNpbmdDbG9uZUZvciIsIlB1YmxpY0RyYWdnYWJsZSIsImlzRHJhZ0Rpc2FibGVkIiwiZGlzYWJsZUludGVyYWN0aXZlRWxlbWVudEJsb2NraW5nIiwiaXNFcXVhbCIsImlzU2Nyb2xsIiwiaXNBdXRvIiwiaXNFaXRoZXIiLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJpc0JvdGgiLCJpc0VsZW1lbnRTY3JvbGxhYmxlIiwiaXNCb2R5U2Nyb2xsYWJsZSIsImh0bWwiLCJodG1sU3R5bGUiLCJodG1sT3ZlcmZsb3ciLCJnZXRDbG9zZXN0U2Nyb2xsYWJsZSIsImdldENsb3Nlc3RTY3JvbGxhYmxlJDEiLCJjaGVja0Zvck5lc3RlZFNjcm9sbENvbnRhaW5lcnMiLCJhbm90aGVyU2Nyb2xsUGFyZW50IiwiZ2V0U2Nyb2xsIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsImdldElzRml4ZWQiLCJnZXRFbnYiLCJjbG9zZXN0U2Nyb2xsYWJsZSIsImdldERyb3BwYWJsZURpbWVuc2lvbiIsInNjcm9sbFNpemUiLCJmcmFtZUNsaWVudCIsInBhZGRpbmdCb3giLCJnZXRDbGllbnQiLCJ0YXJnZXRSZWYiLCJlbnYiLCJpc0Ryb3BEaXNhYmxlZCIsImltbWVkaWF0ZSIsImRlbGF5ZWQiLCJnZXRMaXN0ZW5lck9wdGlvbnMiLCJnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnIiwidXNlRHJvcHBhYmxlUHVibGlzaGVyIiwid2hpbGVEcmFnZ2luZ1JlZiIsInB1Ymxpc2hlZERlc2NyaXB0b3JSZWYiLCJtZW1vaXplZFVwZGF0ZVNjcm9sbCIsImdldENsb3Nlc3RTY3JvbGwiLCJzY2hlZHVsZVNjcm9sbFVwZGF0ZSIsIm9uQ2xvc2VzdFNjcm9sbCIsImdldERyb3BwYWJsZVJlZiIsImlnbm9yZUNvbnRhaW5lckNsaXBwaW5nIiwicmVtb3ZlQXR0cmlidXRlIiwibm9vcCIsImVtcHR5IiwiZ2V0U2l6ZSIsImlzQW5pbWF0aW5nT3Blbk9uTW91bnQiLCJhbmltYXRlIiwiZ2V0U3R5bGUiLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpbkxlZnQiLCJmbGV4U2hyaW5rIiwiZmxleEdyb3ciLCJQbGFjZWhvbGRlciIsImFuaW1hdGVPcGVuVGltZXJSZWYiLCJ0cnlDbGVhckFuaW1hdGVPcGVuVGltZXIiLCJvbkNsb3NlIiwic2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudCIsIm9uU2l6ZUNoYW5nZUVuZCIsIlBsYWNlaG9sZGVyJDEiLCJtZW1vIiwiaXNCb29sZWFuIiwicnVuQ2hlY2tzIiwiY2hlY2tzIiwiY2hlY2siLCJib29sZWFuIiwic3RhbmRhcmQiLCJnZXRQbGFjZWhvbGRlclJlZiIsInZpcnR1YWwiLCJoYXNDbG9uZSIsIl9yZWY1IiwicmVuZGVyQ2xvbmUiLCJoYXNOb1BsYWNlaG9sZGVyIiwiX3JlZjYiLCJ1c2VWYWxpZGF0aW9uIiwiQW5pbWF0ZUluT3V0IiwiUHVyZUNvbXBvbmVudCIsIm9uIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiRHJvcHBhYmxlIiwiZHJvcHBhYmxlUmVmIiwicGxhY2Vob2xkZXJSZWYiLCJ1c2VDbG9uZSIsImdldENvbnRhaW5lckZvckNsb25lIiwic2V0RHJvcHBhYmxlUmVmIiwic2V0UGxhY2Vob2xkZXJSZWYiLCJvblBsYWNlaG9sZGVyVHJhbnNpdGlvbkVuZCIsInNob3VsZEFuaW1hdGVQbGFjZWhvbGRlciIsImRyb3BwYWJsZVByb3BzIiwiZ2V0Q2xvbmUiLCJub2RlIiwiZHJhZ2dhYmxlUHJvdmlkZWQiLCJkcmFnZ2FibGVTbmFwc2hvdCIsImNyZWF0ZVBvcnRhbCIsIkRyb3BwYWJsZSQxIiwiZ2V0Qm9keSIsImRlZmF1bHRQcm9wcyIsImF0dGFjaERlZmF1bHRQcm9wc1RvT3duUHJvcHMiLCJtZXJnZWRQcm9wcyIsImRlZmF1bHRQcm9wS2V5IiwiaXNNYXRjaGluZ1R5cGUiLCJnZXREcmFnZ2FibGUiLCJtYWtlTWFwU3RhdGVUb1Byb3BzIiwiaWRsZVdpdGhBbmltYXRpb24iLCJpc0RyYWdnaW5nT3ZlciIsImRyYWdnaW5nT3ZlcldpdGgiLCJkcmFnZ2luZ0Zyb21UaGlzV2l0aCIsImlzVXNpbmdQbGFjZWhvbGRlciIsImlkbGVXaXRob3V0QW5pbWF0aW9uIiwiZ2V0RHJhZ2dhYmxlUnVicmljIiwiZ2V0TWFwUHJvcHMiLCJpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyIiwiaXNEcmFnZ2luZ092ZXJGb3JJbXBhY3QiLCJpc0hvbWUiLCJvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMiLCJ3YXNDb21iaW5pbmciLCJtYXBEaXNwYXRjaFRvUHJvcHMiLCJDb25uZWN0ZWREcm9wcGFibGUiLCJzdGF0ZVByb3BzIiwiZGlzcGF0Y2hQcm9wcyIsIkNvbm5lY3RlZERyb3BwYWJsZSQxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js\n");

/***/ })

};
;